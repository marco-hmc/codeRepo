## c++通用规范

这次培训从三个层次展开
1. 写出符合格式规范的代码
2. 写出好的代码
3. 个人经验分享

### 1. 好代码的基本原则
* 重复率低
    * 不存在不会被修改和删除的代码，修改重复代码的时候，如何避免遗漏是很头疼的。
    * 只能事先尽可能降低重复代码

* 圈复杂度低
    * 多层嵌套if-else很难读的

* 可读的代码就是好代码
```c++
if(Math::isZero((pnt2-pn1)*line)) // not east for understanding.
if(isVertical(pnt2-pnt1, line)) // easy for understanding
```

* 简单的代码就是好代码

### 2. 命名规范
* 类型-大驼峰
* 函数-小驼峰
* 全局变量-小驼峰
* 静态变量-无特殊函数
* 宏-大写+下划线
* 枚举值-k+大驼峰

```c++
// bim_moduleA_train.cpp

struct BmFoo
{

};

class BmBar;

int g_foo;

enum 
{
    kOne,
    kTwo
}

void useFoo(){
    int foo;
    static int bar;
};

```

### 3. 格式规范
* utf8编码
* 4空格，不用tab
* 换行
    * for和if结尾的}一般换一行，嵌套且连续的不换
    * 文件结尾一个空行
    ```c++
    if(xxx)
    {
        if(xxx)
        {

        } // 嵌套且连续的不换
    }

    if(xxx)
    {

    } // 不嵌套，换一行

    for(xxx)
    {

    }

    ```
* 所有for,if的执行体都用{}括住，哪怕就一行
    ```c++
    if(xxx)
    {
        return xxx;
    }
    ```

### 5. 引用规范
* 引用顺序
  * 自己
  * 同模块
  * bim其他模块
  * 平台模块
  * stl
  ```c++
  #include "bm_moduleA_self.h"

  #include "bm_moduleA_aaa.h"
  #include "bm_moduleA_bbb.h"

  #include "bm_moduleB_aaa.h"
  #include "bm_moduleC_bbb.h"

  #include "wukong_moduleA_aaa.h"
  #include "wukong_moduleB_aaa.h"

  #include <map>
  ```
* 不引用多余头文件
  * vs-resharper插件可以检查
  * vs code-clangd插件可以检查

### 6. 类的设计规范
* 三五零原则
  * 如果一个类需要自定义析构函数、拷贝构造函数或拷贝赋值运算符中的任何一个，那么它很可能需要自定义所有这三个。
    这是因为这个类可能管理着它自己的资源，如动态内存，需要确保复制和销毁的正确性。
  * C++11引入了移动语义和两个新的特殊成员函数：移动构造函数和移动赋值运算符。
    因此，如果你的类需要自定义析构函数、拷贝构造函数、拷贝赋值运算符中的任何一个，为了完全支持移动操作，你也应该考虑提供移动构造函数和移动赋值运算符。
  * "零法则"建议类不应该自定义任何特殊的成员函数，而是应该使用现有的资源管理类（如std::string、std::vector等）或智能指针（如std::unique_ptr、std::shared_ptr）来管理资源。
    遵循这一原则可以使得资源管理更加简单、安全。

* 成员函数形参，如果可以就是`const T&`类型

* 不改变成员变量的，且意图也是不能修改成员变量的成员函数，用`const`修饰

* `friend`会增加耦合，慎用

* 类的成员变量用`m_`前缀

* 单个形参的构造函数用`explicit`

* `final`, `default`, `delete`该用就用

* 不建议在头文件使用inline给出短函数的实现
    * 现代C++编译器会自己决定是否inline，你的inline用法，只是建议编译器怎么做，编译器可能会忽略的，而编译器肯定比我们聪明。
    * 头文件使用inline函数给出实现，不方便调试。


### 7. 现代c++编程范式
1. **what's too much for `auto`?**
    * 一般不要用auto去接函数返回值
    * 类型信息不重要/ 类型信息被变量名包含时，可以看情况用 
    * 减少信息重复度时可以用
    ```c++
    Vector<Foo> bmBar;
    std::for_each(bmBar.begin(), bmBar.end(), [](const auto& bar){...})

    auto enumType = static_cast<int>getEnumType();
    ```

2. **std::bind还要不要用？**
   `std::bind`在C++11中引入，用于生成可调用对象。但随着C++14引入的lambda表达式的增强，`std::bind`的使用变得不那么频繁。Lambda表达式通常提供了一种更清晰、更直接的方式来实现相同的功能。因此，除非有特定的理由，否则推荐使用lambda表达式代替`std::bind`。
   ```c++

   auto foo1 = [](int a, int b) { return a+b; };

   int aVal = 5;
   auto foo2 = [foo1, aVal](int b){ return foo1(aVal, b); };
   auto bar2 = std::bind(foo1, std::placeholders::_1, aVal);
   ```

3. **要不要用inline？**
   `inline`关键字建议编译器内联一个函数，以减少函数调用的开销。然而，现代编译器通常会自动决定是否内联函数，而不是依赖于`inline`关键字。`inline`主要的作用是允许在头文件中定义函数，以避免多重定义错误。
   因此，除非是为了解决头文件中的函数定义问题，通常不需要显式使用`inline`。

4. **异常安全**
   编写异常安全的代码意味着即使在面对异常抛出的情况下，程序也能保持一致的状态，不会泄露资源或导致数据损坏。
   实现异常安全通常涉及到三个级别：
   
    * 基本保证：出现异常不影响
    * 强保证：出现了异常通过guard, transaction等操作会回滚到初始状态
    * 不抛出：不会出现异常
 在设计和实现代码时，应该考虑其对异常的处理方式，确保资源管理正确（如使用智能指针）。
   
5. **push_back还是emplace_back?**
   `push_back`和`emplace_back`都用于向容器添加元素，但`emplace_back`可以直接在容器内构造元素，避免了额外的复制或移动操作。因此，当需要构造而非复制元素到容器时，`emplace_back`通常是更高效的选择。然而，如果已经有一个对象实例，使用`push_back`可能更直观。

6. **switch语句**
```c++
switch ()
{
    case BmEnum::kCase1:
    {
        ...
        break;
    }

    case BmEnum::kCase2:
    {
        ...
        break;
    }

    default:
        break;
}
```

7. **宏怎么用？**
  ```c++
  // 带副作用的宏，容易使用错，一般不要用这种带控制语句，或者修改入参的宏，这些行为叫副作用行为。
  #define BIM_CHECK_OK(input) \
    if ((input) != "ok") \
    { \
        return false; \
    }
  
  // 对于宏函数，有部分规范认为如果实在要用宏函数的话，会强调用do while(0)套起来，但bim这里不需要。为什么？
  #define BIM_FOO_BLOCK(block) \
  do                                 \
  {                                  \
    ...                              \
  }                                  \
  while (0)

  // 对于宏变量，规范一般都会认为用const类型代替，但bim一般还是选择用宏变量的方式。
  #define BIM_DEFAULT_VIEW_SCALE 100
  ```

8. **bim_to_do/ bim_unused**
    * 如果函数有一些没有使用的参数，需要用bim_unused消除警告。

9. **不用dynamic_cast**
    * dynamic_cast依赖type_info，运行时的执行，性能大一些。
    * dynamic_cast一般是判断父类是否能安全转子类的，用了这个就说明类的设计不太对。需要改。

10. **卫语句**
```c++
// 使用了卫语句
void foo()
{
    if(!isValid())
    {
        return;
    }

    if(isA())
    {
        ...
    }
}

// 没使用卫语句
void bar()
{
    if(isValid())
    {
        if(isA())
        {
            ...
        }
    }
}
```

11. **map在右边的时候要慎重使用**
```c++
// 不要把map放在右边用
if(curObj == myMap[idx])
```

### 8. 个人经验
* 正则搜索：
    `word1(?:.*\){0,10}.*word2` // 匹配word1开头，word2结尾，两个单词相差行数在0到10行的字符串
    `foo\(.*::kEnum1`  // 用于匹配某一个函数使用特定枚举值的

* 熟悉stl
    * container
    * iterator
    * algorithm
    * functor
    * type_traits

* git
    * 多用rebase而不是merge
    * `git push --force-with-lease`
    * 多用`git stash`

* 一些编程的手法范式了解一下
    * RAII
    * D/Q指针,pimpl


### 99. 习题

#### 1. 函数/ 变量命名
```c++
// 返回成员变量Bar bar值的函数怎么命名好，四选二
Bar getBar();                   // A
void getBar(Bar& bar);          // B
SystemStatus getBar(Bar& bar);  // C
Bar barValue();                 // D
```

```c++
// 一个变量用于判断是否需要提前跳出，下面哪一个变量命名最不好
bool earlyExit;                 // A
bool breakFlag;                 // B
bool shouldExit;                // C
bool exitEarly;                 // D
bool isBreak;                   // E
bool onlyContinueIfYes          // F
```

```c++
// bim风格命名，下面的变量要改成bim风格的
// db_wall.cpp
class Wall
{
    public:
        bool isModified;
        ObjectId wallId;
};

```

#### 2. 格式化 
```c++
// 主观题，改到比较符合我们规范
bool tmp = cur->foo() == other.foo()? BmEnumType::theSame : BmEnumType::notTheSame; 

// p.s.: 旧的规范是不提倡用三目表达式的，但我个人觉得能用就用，可以减少圈复杂度，代码也简洁一点。
//       BIM这边也没有要求。但是嵌套三目表达式一定是不可取的
```

```c++
// 主观题，提升可读性
if(cur.ctxInfo.environment.c_str() == "project_environment" && getCurStage() != BmStage::kFinish)
// p.s.: C++通用代码规范对这个有建议要求，BIM无要求
```

```c++
// 主观题，哪个可读性好
if(nullptr != dev)
if(dev)


// p.s.: 指针是可以隐式转换为bool量的，但如果是智能指针也想要这种隐式判断能力，需要重载operator bool()函数
// p.s.: C++通用代码规范对这个有明确要求，BIM无要求
```

#### 3. 个人偏好
* 少用前向声明来减少不必要的头文件引用

* 明确控制流
```c++
SystemStatus doSomething()
{
    auto ss = SystemStatus::Err_Ok;
    ss = subStage1();
    if(!BIM_SUCCESS(ss))
    {
        return ss;
    }

    ss = subStage2();
    if(!BIM_SUCCESS(ss))
    {
        return ss;
    }

    return SystemStatus::Err_Ok;
}
```

* if语句不写复杂语句，复杂语句为

##### 3.1 类成员变量的初始化

类成员变量的初始化方式取决于具体情况和编码风格。两种主要的初始化方式是：在头文件中直接初始化和在构造函数的初始化列表中初始化。每种方式都有其优点。

* 在头文件中直接初始化（非静态成员变量）

优点：
- **简洁性**：代码更简洁，易于理解，尤其是对于默认值。
- **减少错误**：确保即使添加了新的构造函数，成员变量也总是有初始值，减少忘记初始化成员变量的错误。
- **统一初始化**：对于所有构造函数，成员变量的初始值都是一致的，除非在构造函数初始化列表中明确指定了其他值。

```c++
class Example {
public:
    Example() = default;
    explicit Example(int val) : m_value(val) {}

private:
    int m_value{0}; // 在头文件中直接初始化
};
```

* 在构造函数的初始化列表中初始化

优点：
- **灵活性**：允许基于不同的构造函数参数进行不同的初始化。
- **性能**：对于某些类型（尤其是容器和复杂对象），在初始化列表中初始化可以更高效，因为它避免了先默认初始化然后再赋值的过程。
- **依赖关系**：如果成员变量的初始化依赖于构造函数的参数或者其他成员变量的值，初始化列表是必须的。

```c++
class Example {
public:
    Example(int val) : m_value(val) {} // 在构造函数的初始化列表中初始化

private:
    int m_value;
};
```

总结
- **简单类型和有明确默认值的情况**：推荐在头文件中直接初始化。
- **复杂类型或初始化依赖于构造函数参数**：推荐使用构造函数的初始化列表。

实际选择应基于具体情况，考虑代码的可读性、维护性以及性能。在某些项目或团队中，可能会有特定的编码风格指南来指导这一选择。

#### 4. 不要随便用c++黑魔法
```c++
for (int i = 0; i < n; i++) 
{
  cout << ans[i] << " \n"[i == n - 1];
}
```
c++黑魔法一般指利用隐式转换，编译器特殊行为，位操作等。
黑魔法后来维护者的可读性极差，实在不行也要用函数封装起来。


### 99. 语法补充

#### 1. explicit怎么用
`explicit`关键字在C++中用于防止类构造函数、转换运算符或其他特定函数进行隐式类型转换。其主要目的是增加代码的清晰度和预防意外的类型转换，从而避免可能的错误。

使用`explicit`的情况：

1. **对于单参数构造函数**：
   - 防止构造函数被隐式用作类型转换运算符。例如，如果有一个接受`int`参数的构造函数，没有`explicit`关键字，编译器可以自动将`int`类型的值转换为该类的对象。使用`explicit`可以阻止这种隐式转换。

   ```c++
   class Foo {
   public:
       explicit Foo(int x) {}
   };

   Foo obj = 10; // 错误：不能隐式转换
   Foo obj2(10); // 正确：显式调用构造函数
   ```

2. **对于构造函数接受`std::initializer_list`作为参数**：
   - 类似地，防止通过花括号初始化语法隐式转换。

3. **对于类型转换运算符**：
   - 防止类的对象被隐式转换为其他类型。

   ```c++
   class Foo {
   public:
       explicit operator bool() const { return true; }
   };

   Foo foo;
   bool x = foo; // 错误：不能隐式转换
   bool y = static_cast<bool>(foo); // 正确：显式转换
   ```

`explicit`的优点：

- **增加代码清晰度**：使用`explicit`可以明确表示构造函数或转换运算符需要显式调用，提高代码的可读性。
- **避免意外的类型转换**：防止编译器自动进行可能导致错误的类型转换。
- **提高类型安全**：通过限制隐式转换，`explicit`关键字有助于维护类型安全，减少运行时错误。

总的来说，`explicit`关键字是C++中一个重要的特性，它通过防止隐式类型转换来帮助程序员编写更安全、更清晰的代码。