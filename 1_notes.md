* git config
    配置被写在~/.git/config
    可以通过git config --list 查看

git config --global http.proxy 'socks5://127.0.0.1:7890'
git config --global https.proxy 'socks5://127.0.0.1:7890'

在js中,所有函数都有this对象吗?
js中,函数和类有什么区分?
js中,new有什么用?


* 
这篇blog试图讲明当一个c函数被调用时,一个**栈帧(stack frame)**是如何被建立,又如何被消除的.这些细节跟操作系统平台及编译器的实现有关,下面的描述是针对运行在Intel奔腾芯片上Linux的gcc编译器而言.c语言的标准并没有描述实现的方式,所以,不同的编译器,处理器,操作系统都可能有自己的建立栈帧的方式.
* 
那么这跟cpp的多态有什么关系呢?且等我娓娓道来,我们首先构建一个类,一个类首先我们必须知道编译器为他默默生成的四个函数(拷贝构造,构造,拷贝赋值运算符以及析构函数).

* C++之所以变成一门层次丰富、结构多变、语法繁冗的语言，是有着多层次的原因的。Bjarne在《The Design and Evolution of C++》一书中，详细的解释了C++为什么会变成如今（C++98/03）的模样。这本书也是我和陈梓瀚一直对各位已经入门的新手强烈推荐的一本书。通过它你多少可以明白，C++的诸多语法要素之所以变成如今的模样，实属迫不得已。


####  重构目的
1. 重构改进软件的设计
    如果没有重构,程序的内部设计(或者叫架构)会逐渐腐败变质.当人们只为短期目的而修改代码时,他们经常没有完全理解架构的整体设计,于是代码逐渐失去了自己的结构.程序员越来越难通过阅读源码来理解原来的设计.代码结构的流失有累积效应.越难看出代码所代表的设计意图,就越难保护其设计,于是设计就腐败得越快.经常性的重构有助于代码维持自己该有的形态.

2. 重构帮助找到 bug

3. 重构使软件更容易理解

####  什么时候重构
1. 修改的时候重构
    先重构,再修改.很多时候提前重构,便于更好修改.
2. 理解的时候重构
3. 能重构就重构
4. 一点一点重构
    但这种有计划的重构应该很少,大部分重构应该是不起眼的/见机行事的.
5. 复审代码时重构

#### 全局数据的问题
全局数据的问题在于,从代码库的任何一个角落都可以修改它,而且没有任何机制可以探测出到底哪段代码做出了修改.一次又一次,全局数据造成了那些诡异的 bug,而问题的根源却在遥远的别处,想要找到出错的代码难于登天.全局数据最显而易见的形式就是全局变量,但类变量和单例(singleton)也有这样的问题.

首要的防御手段是封装变量(132),每当我们看到可能被各处的代码污染的数据,这总是我们应对的第一招.你把全局数据用一个函数包装起来,至少你就能看见修改它的地方,并开始控制对它的访问.随后,最好将这个函数(及其封装的数据)搬移到一个类或模块中,只允许模块内的代码使用它,从而尽量控制其作用域.

可以被修改的全局数据尤其可憎.如果能保证在程序启动之后就不再修改,这样的全局数据还算相对安全,不过得有编程语言提供这样的保证才行.


学习的过程是先接触,再熟悉,再模仿,再创造.不管什么开源项目,在您心中没有任何思路或者解决方案时,您应该先接触熟悉,不断模仿,做到至少心中有一套对于某场景的解决方案,然后再来谈创新谈批判/改造别人的项目.

我个人学习一套陌生的开源项目时,总是喜欢将程序用调试器正常跑起来,然后再中断下来,统计当前的线程数目,然后通过程序入口 main 函数从主线程追踪其他工作线程是如何创建的;接着,分析和研究每个线程的用途以及线程之间交互的,这就是整体把握,接着找我感兴趣的细节去学习.

这里我以学习 **Redis** 为例.将 Redis 源码从官网下载下来以后,使用喜欢的代码阅读器进行管理.我这里使用的是 Visual Studio,如下图所示:

在大致了解了 Redis 有哪些代码模块以后,我们把代码拷贝到 Linux 平台,然后编译并使用 GDB 调试器跑起来.如下图所示:

然后按 `CTRL+C` 将 GDB 中断下来,输入 `info threads` 查看当前程序的所有线程:
接着挨个使用 `thread + 线程编号` 和 `bt` 命令去查看每个线程的上下文调用堆栈:
照每个线程的上下文堆栈,搞清楚其逻辑,并结合主线程,看看每个线程是在何时启动的,端口在何时启动侦听的,等等.做完这一步,关于 **redis-server** 的框架也基本清楚了.

接着我们可以选择一个自己感兴趣的命令,搞清楚 **redis-cli** 与 **redis-server** 命令的交互流程.

最后,如果对 **redis-server** 源码中各种数据结构和细节感兴趣,我们可以进一步深入到具体的代码细节.

当然,不熟悉 **GDB** 的读者看笔者这段操作流程比较困难,这是正常的,说明如果想通过调试去研究 **Redis** 这一款开源软件,您需要去补充一点 **GDB** 调试的知识.这就是我上文中所说的,针对性地补缺补差.


学习的过程是先接触,再熟悉,再模仿,再创造.不管什么开源项目,在您心中没有任何思路或者解决方案时,您应该先接触熟悉,不断模仿,做到至少心中有一套对于某场景的解决方案,然后再来谈创新谈批判/改造别人的项目.

我个人学习一套陌生的开源项目时,总是喜欢将程序用调试器正常跑起来,然后再中断下来,统计当前的线程数目,然后通过程序入口 main 函数从主线程追踪其他工作线程是如何创建的;接着,分析和研究每个线程的用途以及线程之间交互的,这就是整体把握,接着找我感兴趣的细节去学习.

这里我以学习 **Redis** 为例.将 Redis 源码从官网下载下来以后,使用喜欢的代码阅读器进行管理.我这里使用的是 Visual Studio,如下图所示:

在大致了解了 Redis 有哪些代码模块以后,我们把代码拷贝到 Linux 平台,然后编译并使用 GDB 调试器跑起来.如下图所示:

然后按 `CTRL+C` 将 GDB 中断下来,输入 `info threads` 查看当前程序的所有线程:
接着挨个使用 `thread + 线程编号` 和 `bt` 命令去查看每个线程的上下文调用堆栈:
照每个线程的上下文堆栈,搞清楚其逻辑,并结合主线程,看看每个线程是在何时启动的,端口在何时启动侦听的,等等.做完这一步,关于 **redis-server** 的框架也基本清楚了.

接着我们可以选择一个自己感兴趣的命令,搞清楚 **redis-cli** 与 **redis-server** 命令的交互流程.

最后,如果对 **redis-server** 源码中各种数据结构和细节感兴趣,我们可以进一步深入到具体的代码细节.

当然,不熟悉 **GDB** 的读者看笔者这段操作流程比较困难,这是正常的,说明如果想通过调试去研究 **Redis** 这一款开源软件,您需要去补充一点 **GDB** 调试的知识.这就是我上文中所说的,针对性地补缺补差.


#### **执行策略是如何工作的?**

执行策略会告诉我们的标准函数,以何种方式进行自动化并行.

`std::execution`命名空间下面,有三种策略类型:

| 策略                                                                                              | 含义                                                                                                                                                                              |
| ------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [sequenced_policy](https://zh.cppreference.com/w/cpp/algorithm/execution_policy_tag_t)            | 算法使用串行的方式执行,这与原始执行方式没有什么区别.全局可用的实例命名为`std::execution::seq`.                                                                                    |
| [parallel_policy](https://zh.cppreference.com/w/cpp/algorithm/execution_policy_tag_t)             | 算法使用多线程的方式进行执行.全局可用的实例命名为`std::execution::par`.                                                                                                           |
| [parallel_unsequenced_policy](https://zh.cppreference.com/w/cpp/algorithm/execution_policy_tag_t) | 算法使用多线程的方式进行执行.并允许对代码进行向量化.在这个例子中,线程间可以对内存进行交叉访问,向量化的内容可以在同一个线程中执行.全局可用的实例命名为`std::execution::par_unseq`. |

执行策略意味着我们需要进行严格限制.严格的约定,让我们有更多并行策略可以使用:

- 并行算法对所有元素的访问,必须不能导致死锁或数据竞争.
- 向量化和并行化中,所有可访问的函数不能使用任何一种阻塞式同步.

我们需要遵守这些规则,这样才不会将错误引入到程序中.

> Note:
>
> STL的自动并行化,并不总能保证有加速.因为具体的情况都不一样,所以可能在很多情况下并行化并没有加速.多核编程还是很有难度的.

#### **向量化是什么意思?**

向量化的特性需要编译器和CPU都支持,让我们先来简单的了解一下向量化是如何工作的.假设我们有一个非常大的`vector`.简单的实现可以写成如下的方式:

```c++
std::vector<int> v {1, 2, 3, 4, 5, 6, 7 /*...*/};

int sum {std::accumulate(v.begin(), v.end(), 0)};
```

编译器将会生成一个对`accumulate`调用的循环,其可能与下面代码类似:

```c++
int sum {0};

for (size_t i {0}; i < v.size(); ++i) {
	sum += v[i];
}
```

从这点说起,当编译器开启向量化时,就会生成类似如下的代码.每次循环会进行4次累加,这样循环次数就要比之前减少4倍.为了简单说明问题,我们这里没有考虑不为4倍数个元素的情况:

```c++
int sum {0};
for (size_t i {0}; i < v.size() / 4; i += 4) {
	sum += v[i] + v[i+1] + v[i + 2] + v[i + 3];
}
// if v.size() / 4 has a remainder,
// real code has to deal with that also.
```

为什么要这样做呢?很多CPU指令都能支持这种操作`sum += v[i] + v[i+1] + v[i+2] + v[i+3];`,只需要一个指令就能完成.使用尽可能少的指令完成尽可能多的操作,这样就能加速程序的运行.

自动向量化非常困难,因为编译器需非常了解我们的程序,这样才能进行加速的情况下,不让程序的结果出错.目前,至少可以通过使用标准算法来帮助编译器.因为这样能让编译器更加了解哪些数据流能够并行,而不是从复杂的循环中对数据流的依赖进行分析.


#### 这些是一些常见操作的成本的数量级的概念:

这些操作的精确耗时取决于许多因素,包括硬件/操作系统/网络条件等.以下是一些大致的估计:

1. **一次内存访问**:大约在100纳秒级别.这是从CPU访问主内存的时间,缓存访问会更快.

2. **一次函数调用**:大约在几十到几百纳秒.这取决于函数的复杂性和编译器优化.

3. **一次字符串比较**:取决于字符串的长度和比较算法,可能在几微秒到几十微秒.这假设字符串已经在CPU缓存中.

4. **一次系统调用**:大约在1-10微秒.这是进入内核并返回用户空间的时间,不包括系统调用本身的执行时间.

5. **一次磁盘访问**:
   - 对于固态硬盘(SSD),大约在0.1毫秒(100微秒).
   - 对于机械硬盘(HDD),大约在5-10毫秒.

6. **一个通过网络的消息的成本**:取决于网络的延迟和带宽,可能在几毫秒到几百毫秒.例如,一个典型的局域网延迟可能在0.1-1毫秒,而跨大洲的延迟可能在100-200毫秒.

#### 以下是一些C++标准库中的算法,以及它们的功能描述:

std::sort:对给定范围内的元素进行排序.
std::reverse:反转给定范围内的元素顺序.
std::copy:将一个范围内的元素复制到另一个范围.
std::find:在给定范围内查找特定的元素.
std::count:计算给定范围内等于特定值的元素的数量.
std::remove:从给定范围内移除所有等于特定值的元素.
std::replace:将给定范围内所有等于特定值的元素替换为另一个值.
std::generate:使用给定的生成器函数填充给定范围内的元素.
std::transform:对给定范围内的每个元素应用一个函数,并将结果存储在另一个范围内.
std::fill:将给定范围内的所有元素设置为特定值.
std::merge:将两个已排序的范围合并为一个排序的范围.
std::partition:根据给定的谓词函数,将给定范围内的元素分为两部分.
std::nth_element:部分排序范围,使得第n个元素在排序后的位置,并保证其左边的元素不大于它,右边的元素不小于它.