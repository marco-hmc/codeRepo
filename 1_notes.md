dom 解析和流式解析两种

- cygwin 是是什么？
- gflw 是什么？
- downDemo github

- 继承的析构函数一般要怎么处理？继承的特殊成员函数怎么处理？

有两个同名函数 func()，形参分别是 Foo 类型指针和 Bar 类型指针，Bar 类型是 Foo 类型的派生类。
如果有一个 Foo \*bar = new Bar(); 调用 func(bar)，调用的是那一个方法？

- 如何避免代码膨胀？
- 交互
  - 操作系统到 qt 到 bim
- bim 的架构
- bim 的命令调度
- bim 的显示
  - bim 的不同视图下的 ctp 数据差异体现在哪里
- bim 的构件类型
- 多线程开发指南
- 重生成
- 模型数据
  - viewItem
  - docItem
  - ctp
    https://confluence.zwcad.com/pages/viewpage.action?pageId=60720467
* 模型编辑
    * 自己
        * 预览模式
    * 重生成
* 模型显示
    * graphics
* undo实现
* 离线配置
* 特征/ 永久命名概念
* 

* 如果有一个全局变量存在，最后是提供统一的操作函数接口。哪怕是一个int的++操作也通过函数封装起来，这样可以方便调试。
* 知道哪些地方修改过。不然这个状态无法追踪在哪里被修改了。

#### 8. 设计class犹如设计type

+ 新的class对象应该被如何创建和构造
+ 对象的初始化和赋值应该有什么样的差别(不同的函数调用,构造函数和赋值操作符)
+ 新的class如果被pass by value(以值传递),意味着什么(copy构造函数)
+ 什么是新type的"合法值"(成员变量通常只有某些数值是有效的,这些值决定了class必须维护的约束条件)
+ 新的class需要配合某个继承图系么(会受到继承类的约束)
+ 新的class需要什么样的转换(和其他类型的类型变换)
+ 什么样的操作符和函数对于此type而言是合理的(决定声明哪些函数,哪些是成员函数)
+ 什么样的函数必须为private的 
+ 新的class是否还有相似的其他class,如果是的话就应该定义一个class template
+ 你真的需要一个新type么?如果只是定义新的derived class或者为原来的class添加功能,说不定定义non-member函数或者templates更好


比如内存映射，调用栈，同步对象等，连同公司本身的业务都需要有一定的了解。

### not re-organized

7、实现一个建议内存池
如何实现cpp的新feature比如协程?
如何用c实现template?

---

模板，模板特化，SFINAE，type_traits，形参包，
结构化绑定及其手搓，具名要求，迭代器trait，值类别，左右值、泛左值(glvalue)、

纯右值(prvalue)，移动语义，转发引用(俗称万能引用)，std::forward<T>()完美转发，RAII，表达式求值，弃值表达式，不求值表达式，潜在求值表达式，常量表达式，临时量实质化(C++17)，标准布局类，用元编程实现constexpr编译期算法(如编译期汉诺塔，编译期递归，拼接字符数组，打函数表)，用户定义字面量，构造函数异常处理，函数 try 块，模块，全局模块片段及其存在的意义，模块分区，在CMake工程中声明模块范围库(范围适配器，定制点对象(CPO)，niebloid，ADL实参依赖查找，常见的范围工厂，视图，老式迭代器对和新式迭代器+哨位概念的对比)，可变仿引用对象的 operator= 成员必须带 const 限定的依据，奇特重现模板模式(CRTP)以及其在C++20范围适配器中的应用概念库，requires子句，约束的归入(subsume)，约束的偏序，concept，原子约束，约束规范化过程，范围库中常用的concept(可间接写入，可间接读取)协程，协程promise_type，挂起点，等待体，范围生成器，协程抛异常，格式化器特化，基本格式化器，格式串格式，显式对象形参(C++23)

---
5.哈希表
对哈希表的细节要求很高，比如哈希表的冲突；
Linux 系统下可能还会问什么是 daemon 进程，如何产生 daemo 进程，什么是僵尸进程，僵尸进程如何产 生和消除(bilibili 问过)突检测、哈希函数常用实现、算法复杂度;比如百度二面就让我写一个哈希表插入元素算法，元素类型是任意类型，

1. AVL 树和 B 树的概念、细节。
例如会问 mysql 数据库的索引的实现原理，基本上就等于问你 B 树了
红黑树、b+树

----

3.操作系统原理性的东西
 Linux 下 elf 文件的节结构，映射到进程地址空间后分别对应哪些段
相关的问题还有，全局变量、静态存储在进程地址空间的哪里;
堆和栈的区别，栈的结构，栈的细节一点要搞的特别清楚，因为一些对技术要求比较高的公司会问的比较深入，例如京东的一面是让我先写一个从1加到 100 的求和函数，然后让我写出这个函数的汇编代码，如果你对栈的结构(如函数参数入栈顺序、函数局部变量在栈中的布局、栈帧指针和栈顶指针位置)不熟悉的话，这题目就无法答对了:
栈的问题，可能会以常见的函数调用方式来提问，常见的函数调用有如下cdecl/stdcal/ thiscal/ fastcall 的区别，比如像 printf这样具有不定参数的函数为什么不能使用 stdcall;
饿了么二面问了操作系统的保护模式实模式9，中断向量表，Linux 下的 CAS,
以上这些问题的答案，《程序员的自我修养9:链接、装载与库》这本程序员必读书只中都有。感谢某位网友的分享:


如果希望一个类B不可以被继承，首先得让B继承自A，A的构造函数是私有化，但声明B是A的友元，因此B能够正常构造，但是当C继承B的时候，C就不能调用A的构造。 从而使得C不可被构造，是这个意思吗？

图形学，游戏服务器，网络通讯架构，虚拟现实，嵌入式系统，设备驱动，音频视频，ai底层。
网络通讯架构能够拿到这个月薪；

std::variant + std::visit

```cpp
std::optional<std::reference_wrapper<int>> get(size_t index);

auto x = **vec.get(3);         // 性能读
auto x = *vec.get(3).value();  // 安全读
*vec.get(3) = 42;              // 性能写
vec.get(3).value() = 42;       // 安全写
```

C++17 的 CTAD 语法

## insert 不会替换现有值

```cpp
map<string, int> table;
table.insert({"小彭老师", 24});
table.insert({"小彭老师", 42});
```

这时，`table["小彭老师"]` 仍然会是 24，而不是 42。因为 insert 不会替换 map 里已经存在的值。


## insert 不会替换现有值
（避免不必要的构造？）
```cpp
map<string, int> table;
table["小彭老师"] = 24;
table["小彭老师"] = 42;
```

C++17 提供了比 `[]` 运算符更适合覆盖性插入的 insert_or_assign 函数：

```cpp
map<string, int> table;
table.insert_or_assign("小彭老师", 24);
table.insert_or_assign("小彭老师", 42);
```
## 高效删除 vector 元素
back swap erase

lower_bound


模板元编程的时候要明白，c++编译器能处理的是类型, 常量。
为了扩展能力，这些概念在编译器下都需要进一步发展。
* 类型
  * 类traits，类型能够特化和偏特化，
* 常量
  * 字面量/ 常量表达式/ 
编译器没有变量的概念。

如果是从计算机的角度出发. 我感觉可以这么理解.
计算机=程序+硬件
现代计算机=程序+硬件+操作系统

狭义的程序=命令段+数据段.

一些实时性要求很高的领域就不能用 unordered_map。

一门编程语言需要提供以下基本能力，以便开发者能够编写功能丰富、灵活且高效的程序：
1. 数据表示和操作
2. 条件判断能力（if）
3. 循环能力（loop）
4. 变量和常量
5. 函数和过程
6. 输入和输出
7. 错误处理
8. 模块化和命名空间
9. 面向对象编程（OOP）
10. 并发和并行

> 模板函数实现多态的解决方案是有的，那就是 std::variant + std::visit，但那是更后来出现的函数式设计模式了，今天我们先把面向对象学明白了再说。

内建函数是和机器指令直接相关的，不会产生函数调用。


编译器之所以能够实现所谓的“开洞”行为，主要是因为它在编译过程中对源代码有深入的理解和控制。编译器的工作流程大致可以分为以下几个阶段：

1. **预处理（Preprocessing）**：
   - 处理预处理指令，如宏定义的展开、条件编译指令、头文件的包含等。这一阶段，编译器会根据预处理指令修改源代码。

2. **词法分析（Lexical Analysis）**：
   - 将源代码分解成一系列的标记（Tokens），如关键字、标识符、字面量等。

3. **语法分析（Syntax Analysis）**：
   - 根据语言的语法规则，将标记序列组织成抽象语法树（Abstract Syntax Tree, AST）。

4. **语义分析（Semantic Analysis）**：
   - 检查AST中的语义错误，如类型不匹配、未定义的标识符等，并生成中间表示（Intermediate Representation, IR）。

5. **优化（Optimization）**：
   - 对IR进行优化，以提高程序的性能或减少资源消耗。这一阶段，编译器会利用其对程序结构和语义的深入理解来执行各种优化。

6. **代码生成（Code Generation）**：
   - 将优化后的IR转换成目标代码，可能是汇编代码或直接的机器代码。

7. **链接（Linking）**：
   - 将编译生成的目标代码与库文件和其他模块链接在一起，生成可执行文件。

编译器能够实现“开洞”行为的关键因素包括：

- **全局视角**：编译器可以看到整个源代码，因此可以进行全局优化和分析，而用户代码只能看到局部。

- **语言和平台特性**：编译器了解目标编程语言的规范和特性，以及目标平台的硬件特性，因此可以利用这些信息进行优化。

- **控制编译过程**：编译器控制着从源代码到目标代码的整个转换过程，可以在任何阶段插入特殊的处理逻辑。

- **访问底层信息**：编译器可以访问底层的硬件和操作系统信息，这使得它能够生成针对特定平台优化的代码。

- **编译器扩展和内置函数**：编译器通常提供一些特殊的内置函数和扩展，这些是专门为编译器设计的，用户代码无法直接使用。

通过这些能力，编译器能够在编译过程中实现那些用户代码难以或无法实现的特殊功能。

哑元表

```c++
#pragma omp parallel for default(shared) firstprivate(eps)  private(c, j)
    for (int i = 0; i < N_POINTS; i++) {
        for (int j = 0; j < N_POINTS; j++) {
            c.r = -2.0 + 2.5 * (double)(i) / (double)(N_POINTS) + eps;
            c.i = 1.125 * (double)(j) / (double)(N_POINTS) + eps;
            testpoint(c);
        }
    }
```

怎么理解操作系统？
你的理解基本是正确的，但可以稍微补充和澄清一些细节，以更全面地理解操作系统的概念和功能。以下是对你提供的内容的详细解释和补充：

### 操作系统的定义

操作系统（OS）是管理计算机硬件和软件资源的系统软件，为计算机程序提供一个运行环境。操作系统的主要功能包括：

1. **进程管理**：
   - 创建、调度和终止进程。
   - 提供进程间通信和同步机制。

2. **内存管理**：
   - 分配和释放内存。
   - 管理虚拟内存和物理内存。

3. **文件系统管理**：
   - 提供文件和目录的创建、删除、读写等操作。
   - 管理文件系统的结构和存储。

4. **设备管理**：
   - 管理输入输出设备，如键盘、鼠标、显示器、磁盘等。
   - 提供设备驱动程序，处理设备的中断和请求。

5. **用户接口**：
   - 提供命令行界面（CLI）或图形用户界面（GUI），供用户与系统交互。

### 操作系统对硬件的控制

操作系统能够对计算机设备的所有硬件进行控制，这种控制能力来源于指令集架构（ISA）。指令集是处理器支持的指令的集合，操作系统通过这些指令与硬件进行交互。

#### 指令执行过程

1. **获取指令**：
   - 指令可以通过输入输出（IO）设备获取，或者在程序运行时将指令加载到内存中，从内存读取指令。

2. **指令译码**：
   - CPU 从内存中读取指令，并对指令进行译码，确定需要执行的操作。

3. **执行操作**：
   - CPU 根据译码结果，调用相关硬件资源（如寄存器、算术逻辑单元等）执行操作。

4. **写回结果**：
   - 执行操作的结果写回到目标地址（寄存器或内存）。

### 操作系统的运行环境

操作系统为程序提供了一个完善的运行环境，控制流程如下：

1. **指令存储**：
   - 操作系统将指令存储在内存的特定区域，称为代码段（Code Segment）。程序运行时，指令加载到代码段中，实现了可编程性。

2. **事件中断**：
   - 当发生事件中断时，操作系统将中断信号插入到指令流中，实现交互操作。中断处理程序会处理中断事件，并恢复正常执行。

3. **内存管理**：
   - 操作系统负责内存的分配和释放，标记内存的使用状态。当程序需要申请内存时，操作系统会处理内存请求，并分配适当的内存区域。

### 操作系统的状态机模型

操作系统可以被看作是一个基于硬件的复杂状态机。状态机的状态存在于计算机设备的各个寄存器和内存中，CPU 会读取这些状态并执行相应的操作。

#### 状态机的状态

1. **寄存器状态**：
   - 寄存器保存当前指令的执行状态、程序计数器、堆栈指针等信息。

2. **内存状态**：
   - 内存保存程序的代码段、数据段、堆栈段等信息。

3. **设备状态**：
   - 输入输出设备的状态，如键盘缓冲区、显示器状态等。

### 总结

你的理解是正确的，操作系统确实为计算机设备提供了一个运行环境，并对硬件进行控制。操作系统通过指令集与硬件交互，管理进程、内存、文件系统和设备。操作系统可以被看作是一个基于硬件的复杂状态机，状态机的状态存在于寄存器和内存中，CPU 通过读取这些状态执行相应的操作。通过这些机制，操作系统能够高效地管理和调度计算机资源，确保系统的稳定和安全。


傅里叶变化，可以将一个任意曲线函数，转成若干个三角函数表示对吗？
然后如果一个曲线函数是有限时间域内的，就可以转成频域的多个三个函数内。