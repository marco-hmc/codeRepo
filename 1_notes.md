* git config
    配置被写在~/.git/config
    可以通过git config --list 查看

git config --global http.proxy 'socks5://127.0.0.1:7890'
git config --global https.proxy 'socks5://127.0.0.1:7890'

在js中,所有函数都有this对象吗?
js中,函数和类有什么区分?
js中,new有什么用?


* C++之所以变成一门层次丰富、结构多变、语法繁冗的语言，是有着多层次的原因的。Bjarne在《The Design and Evolution of C++》一书中，详细的解释了C++为什么会变成如今（C++98/03）的模样。这本书也是我和陈梓瀚一直对各位已经入门的新手强烈推荐的一本书。通过它你多少可以明白，C++的诸多语法要素之所以变成如今的模样，实属迫不得已。


### 重构目的
1. 重构改进软件的设计
    如果没有重构,程序的内部设计(或者叫架构)会逐渐腐败变质.当人们只为短期目的而修改代码时,他们经常没有完全理解架构的整体设计,于是代码逐渐失去了自己的结构.程序员越来越难通过阅读源码来理解原来的设计.代码结构的流失有累积效应.越难看出代码所代表的设计意图,就越难保护其设计,于是设计就腐败得越快.经常性的重构有助于代码维持自己该有的形态.

2. 重构帮助找到 bug

3. 重构使软件更容易理解

### 什么时候重构
1. 修改的时候重构
    先重构,再修改.很多时候提前重构,便于更好修改.
2. 理解的时候重构
3. 能重构就重构
4. 一点一点重构
    但这种有计划的重构应该很少,大部分重构应该是不起眼的/见机行事的.
5. 复审代码时重构

### 
全局数据的问题在于,从代码库的任何一个角落都可以修改它,而且没有任何机制可以探测出到底哪段代码做出了修改.一次又一次,全局数据造成了那些诡异的 bug,而问题的根源却在遥远的别处,想要找到出错的代码难于登天.全局数据最显而易见的形式就是全局变量,但类变量和单例(singleton)也有这样的问题.

首要的防御手段是封装变量(132),每当我们看到可能被各处的代码污染的数据,这总是我们应对的第一招.你把全局数据用一个函数包装起来,至少你就能看见修改它的地方,并开始控制对它的访问.随后,最好将这个函数(及其封装的数据)搬移到一个类或模块中,只允许模块内的代码使用它,从而尽量控制其作用域.

可以被修改的全局数据尤其可憎.如果能保证在程序启动之后就不再修改,这样的全局数据还算相对安全,不过得有编程语言提供这样的保证才行.
