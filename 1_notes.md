现今的编程语言都会强制保证每个函数只有一个入口

卫语句就是把复杂的条件表达式拆分成多个条件表达式,减少嵌套.嵌套了好几层的if - then-else语句,转换为多个if语句,实现它的逻辑,这多条的if语句就是卫语句.

卫语句将某些关键条件优先判断,简化程序流程走向.卫语句往往用于对 if 条件嵌套代码的优化

本书的第 1 版教很多人学会了重构,不过我的关注点是组织一本重构的参考书,而不是带领读者走过学习过程.如果你需要一本面向入门者的教材,我推荐 Bill Wake 的<重构手册>[Wake],其中包含了很多有用的重构练习.
本书聚焦讨论通用编程语言中的重构技巧.还有一些专门领域的重构,例如已经引起关注的<数据库重构>[Ambler &amp; Sadalage](由 Scott Ambler 和 Pramod Sadalage 所著)和<重构 HTML>[Harold](由 Elliotte Rusty Harold 所著).

尽管标题中没有"重构"二字,Michael Feathers 的<修改代码的艺术>[Feathers]也不得不提.这本书主要讨论如何在缺乏测试覆盖的老旧代码库上开展重构.


the lazy fox jumps over brown dog

什么是令牌环网络?

cout 不是一个变量,而是 C++ 标准库中用于标准输出的对象.它是 ostream 类型的对象,负责向标准输出设备(通常是终端)输出数据.

在 C++ 中,cout 被用于输出数据到控制台.例如,你可以使用 cout 输出文本/数字等信息.这是一个示例:

cpp
Copy code
#include <iostream>

int main() {
    std::cout << "Hello, World!" << std::endl;
    return 0;
}
在这个例子中,std::cout 用于输出字符串 "Hello, World!" 到控制台.std::endl 是用于输出换行符并刷新缓冲区的操作.

cout 并不是单例,而是一个全局对象.在 C++ 中,标准库中的一些对象(如 cin/cout/cerr等)是全局对象,可以在程序的任何地方使用.它们是标准库的一部分,提供了一种方便的方式来进行输入和输出操作.

要注意的是,cout 是 ostream 类型的一个对象,而不是一个单例类.单例是指一个类只能有一个实例,而 cout 并不符合这个概念,因为你可以在程序中的多个地方使用 cout,每个地方都使用的是同一个 ostream 类型的实例.

#### 配置文件
* 为什么有些配置修改了之后,需要重启客户端;而有些则不用?一般而言,具有什么性质的配置,需要重启客户端来生效?
配置的修改是否需要重启客户端取决于应用程序如何处理配置的更改.以下是一些可能需要重启的情况:

1. **初始化配置**:如果配置是在应用程序启动时读取并初始化的,那么任何对配置的更改都需要重启应用程序才能生效.这是因为应用程序在启动时将配置加载到内存中,并在运行过程中使用这些内存中的配置,而不是直接从配置文件中读取.

2. **依赖于配置的资源**:如果应用程序依赖于某些根据配置创建的资源(例如数据库连接/线程池等),那么更改这些配置可能需要重启应用程序,以便重新创建这些资源.

3. **安全性和稳定性**:对于一些可能影响应用程序安全性或稳定性的配置,应用程序可能会要求重启,以确保更改能够在一个清晰/定义良好的状态下生效.

相反,以下是一些可能不需要重启的情况:

1. **动态配置**:如果应用程序支持动态配置,那么它可能会在运行时检测配置的更改,并立即应用这些更改.这通常需要应用程序具有一种机制来监听配置文件的更改,并在更改发生时更新内存中的配置.

2. **无状态配置**:对于无状态的配置(即不影响应用程序的内部状态的配置),更改这些配置通常不需要重启应用程序.例如,更改日志级别通常不需要重启.

请注意,这些只是一般情况,具体情况取决于应用程序的具体实现.

#### **网络通信部分**

* 一般哪些函数可以使用noexcept?
    在C++中,`noexcept`关键字用于指定一个函数不会抛出任何异常.这对于提高代码的性能和可靠性非常有用.以下是一些常见的可以使用`noexcept`的函数:

    1. 析构函数:析构函数通常不应抛出任何异常,因为如果在析构函数中抛出异常,可能会导致程序的未定义行为.

    2. 移动构造函数和移动赋值操作符:这些函数通常应该被标记为`noexcept`,因为它们通常只涉及指针和基本类型的转移,不应抛出异常.此外,标记为`noexcept`的移动操作可以被标准库容器如`std::vector`更有效地使用.

    3. 交换函数:交换函数(如`std::swap`)通常应该被标记为`noexcept`,因为它们通常只涉及指针和基本类型的转移,不应抛出异常.

    4. 其他不会抛出异常的函数:如果你知道一个函数不会抛出异常,你应该使用`noexcept`关键字.这可以帮助编译器优化代码,并向其他开发者明确表明该函数不会抛出异常.

    在你提供的代码中,移动构造函数和移动赋值操作符被标记为`noexcept`,这是因为它们只涉及指针和基本类型的转移,不应抛出异常.
* 
* 网络通信部分,主要有两大块,
1. 第一个是程序启动时,与服务端的交互;
2. 第二个就是文件下载与分享的 P2P 网络.
Prerequisites:
1. 具体的就是 Socket 的各种 API 函数,以及基于这些 API 逻辑的组合
2. 当然可能也会用到操作系统平台所特有的网络 API 函数,如 **WSAAsyncSelect** 网络模型.
Design Points:
1. 网络通信部分如何与 UI 部分进行数据交换:
   是使用队列?
    如果使用队列,多线程之间如何保持资源的一致性和解决资源竞态,使用 Event/CriticalSection/Mutex/Semaphore 等?
   全局变量?
   或者相应的 Windows 操作平台提供的特殊通信技术,如 PostMessage 函数/管道?

#### 1. grep怎么用?请结合具体例子说明,给出一组命令,能够将某命令输出信息中,若某行存在某一单词,则将该行输出到指定文本文件上


这篇blog试图讲明当一个c函数被调用时,一个**栈帧(stack frame)**是如何被建立,又如何被消除的.这些细节跟操作系统平台及编译器的实现有关,下面的描述是针对运行在Intel奔腾芯片上Linux的gcc编译器而言.c语言的标准并没有描述实现的方式,所以,不同的编译器,处理器,操作系统都可能有自己的建立栈帧的方式.

#### **执行策略是如何工作的?**

执行策略会告诉我们的标准函数,以何种方式进行自动化并行.

`std::execution`命名空间下面,有三种策略类型:

| 策略                                                                                              | 含义                                                                                                                                                                              |
| ------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [sequenced_policy](https://zh.cppreference.com/w/cpp/algorithm/execution_policy_tag_t)            | 算法使用串行的方式执行,这与原始执行方式没有什么区别.全局可用的实例命名为`std::execution::seq`.                                                                                    |
| [parallel_policy](https://zh.cppreference.com/w/cpp/algorithm/execution_policy_tag_t)             | 算法使用多线程的方式进行执行.全局可用的实例命名为`std::execution::par`.                                                                                                           |
| [parallel_unsequenced_policy](https://zh.cppreference.com/w/cpp/algorithm/execution_policy_tag_t) | 算法使用多线程的方式进行执行.并允许对代码进行向量化.在这个例子中,线程间可以对内存进行交叉访问,向量化的内容可以在同一个线程中执行.全局可用的实例命名为`std::execution::par_unseq`. |

执行策略意味着我们需要进行严格限制.严格的约定,让我们有更多并行策略可以使用:

- 并行算法对所有元素的访问,必须不能导致死锁或数据竞争.
- 向量化和并行化中,所有可访问的函数不能使用任何一种阻塞式同步.

我们需要遵守这些规则,这样才不会将错误引入到程序中.

> Note:
>
> STL的自动并行化,并不总能保证有加速.因为具体的情况都不一样,所以可能在很多情况下并行化并没有加速.多核编程还是很有难度的.

#### **向量化是什么意思?**

向量化的特性需要编译器和CPU都支持,让我们先来简单的了解一下向量化是如何工作的.假设我们有一个非常大的`vector`.简单的实现可以写成如下的方式:

```c++
std::vector<int> v {1, 2, 3, 4, 5, 6, 7 /*...*/};

int sum {std::accumulate(v.begin(), v.end(), 0)};
```

编译器将会生成一个对`accumulate`调用的循环,其可能与下面代码类似:

```c++
int sum {0};

for (size_t i {0}; i < v.size(); ++i) {
	sum += v[i];
}
```

从这点说起,当编译器开启向量化时,就会生成类似如下的代码.每次循环会进行4次累加,这样循环次数就要比之前减少4倍.为了简单说明问题,我们这里没有考虑不为4倍数个元素的情况:

```c++
int sum {0};
for (size_t i {0}; i < v.size() / 4; i += 4) {
	sum += v[i] + v[i+1] + v[i + 2] + v[i + 3];
}
// if v.size() / 4 has a remainder,
// real code has to deal with that also.
```

为什么要这样做呢?很多CPU指令都能支持这种操作`sum += v[i] + v[i+1] + v[i+2] + v[i+3];`,只需要一个指令就能完成.使用尽可能少的指令完成尽可能多的操作,这样就能加速程序的运行.

自动向量化非常困难,因为编译器需非常了解我们的程序,这样才能进行加速的情况下,不让程序的结果出错.目前,至少可以通过使用标准算法来帮助编译器.因为这样能让编译器更加了解哪些数据流能够并行,而不是从复杂的循环中对数据流的依赖进行分析.


#### 这些是一些常见操作的成本的数量级的概念:

这些操作的精确耗时取决于许多因素,包括硬件/操作系统/网络条件等.以下是一些大致的估计:

1. **一次内存访问**:大约在100纳秒级别.这是从CPU访问主内存的时间,缓存访问会更快.

2. **一次函数调用**:大约在几十到几百纳秒.这取决于函数的复杂性和编译器优化.

3. **一次字符串比较**:取决于字符串的长度和比较算法,可能在几微秒到几十微秒.这假设字符串已经在CPU缓存中.

4. **一次系统调用**:大约在1-10微秒.这是进入内核并返回用户空间的时间,不包括系统调用本身的执行时间.

5. **一次磁盘访问**:
   - 对于固态硬盘(SSD),大约在0.1毫秒(100微秒).
   - 对于机械硬盘(HDD),大约在5-10毫秒.

6. **一个通过网络的消息的成本**:取决于网络的延迟和带宽,可能在几毫秒到几百毫秒.例如,一个典型的局域网延迟可能在0.1-1毫秒,而跨大洲的延迟可能在100-200毫秒.

#### 以下是一些C++标准库中的算法,以及它们的功能描述:

std::sort:对给定范围内的元素进行排序.
std::reverse:反转给定范围内的元素顺序.
std::copy:将一个范围内的元素复制到另一个范围.
std::find:在给定范围内查找特定的元素.
std::count:计算给定范围内等于特定值的元素的数量.
std::remove:从给定范围内移除所有等于特定值的元素.
std::replace:将给定范围内所有等于特定值的元素替换为另一个值.
std::generate:使用给定的生成器函数填充给定范围内的元素.
std::transform:对给定范围内的每个元素应用一个函数,并将结果存储在另一个范围内.
std::fill:将给定范围内的所有元素设置为特定值.
std::merge:将两个已排序的范围合并为一个排序的范围.
std::partition:根据给定的谓词函数,将给定范围内的元素分为两部分.
std::nth_element:部分排序范围,使得第n个元素在排序后的位置,并保证其左边的元素不大于它,右边的元素不小于它.