
<Modern C++ Design>中(别问我为什么老举这本书,因为<C++ Templates>和<Generic Programming>

```cpp
// * C++14 允许 auto 作为返回类型,它通过 return 语句推断返回类型,C++11 则需要额外指定尾置返回类型,对于三目运算符,其结果类型为两个操作数类型中更公用的类型,比如 int 和 double 的公用类型是 double
#include <cassert>

namespace jc {

template <typename T, typename U>
auto max(const T& a, const U& b) -> decltype(true ? a : b) {
  return a < b ? b : a;
}

}  // namespace jc

int main() { assert(jc::max(1, 3.14) == 3.14); }
```

# 2.1 线程管理的基础
## 2.1.1 启动线程

有件事需要注意,当把函数对象传入到线程构造函数中时,需要避免"[最令人头痛的语法解析](http://en.wikipedia.org/wiki/Most_vexing_parse)"\(_C++'s most vexing parse_, [中文简介](http://qiezhuifeng.diandian.com/post/2012-08-27/40038339477)\).如果你传递了一个临时变量,而不是一个命名的变量;C++编译器会将其解析为函数声明,而不是类型对象的定义.

启动了线程,你需要明确是要等待线程结束\(_加入式___参见2.1.2节\),还是让其自主运行\(_分离式___参见2.1.3节\).如果`std::thread`对象销毁之前还没有做出决定,程序就会终止\(`std::thread`的析构函数会调用`std::terminate()`\).因此,即便是有异常存在,也需要确保线程能够正确的_加入_\(joined\)或_分离_\(detached\).2.1.3节中,会介绍对应的方法来处理这两种情况.需要注意的是,必须在`std::thread`对象销毁之前做出决定,否则你的程序将会终止\(std::thread的析构函数会调用std::terminate\(\),这时再去决定会触发相应异常\).

the lazy fox jumps over brown dog

* 一般哪些函数可以使用noexcept?
    在C++中,`noexcept`关键字用于指定一个函数不会抛出任何异常.这对于提高代码的性能和可靠性非常有用.以下是一些常见的可以使用`noexcept`的函数:

    1. 析构函数:析构函数通常不应抛出任何异常,因为如果在析构函数中抛出异常,可能会导致程序的未定义行为.
    2. 移动构造函数和移动赋值操作符:这些函数通常应该被标记为`noexcept`,因为它们通常只涉及指针和基本类型的转移,不应抛出异常.此外,标记为`noexcept`的移动操作可以被标准库容器如`std::vector`更有效地使用.
    3. 交换函数:交换函数(如`std::swap`)通常应该被标记为`noexcept`,因为它们通常只涉及指针和基本类型的转移,不应抛出异常.
    4. 其他不会抛出异常的函数:如果你知道一个函数不会抛出异常,你应该使用`noexcept`关键字.这可以帮助编译器优化代码,并向其他开发者明确表明该函数不会抛出异常.
    在你提供的代码中,移动构造函数和移动赋值操作符被标记为`noexcept`,这是因为它们只涉及指针和基本类型的转移,不应抛出异常.

#### **执行策略是如何工作的?**

执行策略会告诉我们的标准函数,以何种方式进行自动化并行.

`std::execution`命名空间下面,有三种策略类型:

| 策略                                                                                              | 含义                                                                                                                                                                              |
| ------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [sequenced_policy](https://zh.cppreference.com/w/cpp/algorithm/execution_policy_tag_t)            | 算法使用串行的方式执行,这与原始执行方式没有什么区别.全局可用的实例命名为`std::execution::seq`.                                                                                    |
| [parallel_policy](https://zh.cppreference.com/w/cpp/algorithm/execution_policy_tag_t)             | 算法使用多线程的方式进行执行.全局可用的实例命名为`std::execution::par`.                                                                                                           |
| [parallel_unsequenced_policy](https://zh.cppreference.com/w/cpp/algorithm/execution_policy_tag_t) | 算法使用多线程的方式进行执行.并允许对代码进行向量化.在这个例子中,线程间可以对内存进行交叉访问,向量化的内容可以在同一个线程中执行.全局可用的实例命名为`std::execution::par_unseq`. |

执行策略意味着我们需要进行严格限制.严格的约定,让我们有更多并行策略可以使用:

- 并行算法对所有元素的访问,必须不能导致死锁或数据竞争.
- 向量化和并行化中,所有可访问的函数不能使用任何一种阻塞式同步.


#### 这些是一些常见操作的成本的数量级的概念:

这些操作的精确耗时取决于许多因素,包括硬件/操作系统/网络条件等.以下是一些大致的估计:

1. **一次内存访问**:大约在100纳秒级别.这是从CPU访问主内存的时间,缓存访问会更快.

2. **一次函数调用**:大约在几十到几百纳秒.这取决于函数的复杂性和编译器优化.

3. **一次字符串比较**:取决于字符串的长度和比较算法,可能在几微秒到几十微秒.这假设字符串已经在CPU缓存中.

4. **一次系统调用**:大约在1-10微秒.这是进入内核并返回用户空间的时间,不包括系统调用本身的执行时间.

5. **一次磁盘访问**:
   - 对于固态硬盘(SSD),大约在0.1毫秒(100微秒).
   - 对于机械硬盘(HDD),大约在5-10毫秒.

6. **一个通过网络的消息的成本**:取决于网络的延迟和带宽,可能在几毫秒到几百毫秒.例如,一个典型的局域网延迟可能在0.1-1毫秒,而跨大洲的延迟可能在100-200毫秒.

#### 以下是一些C++标准库中的算法,以及它们的功能描述:

std::reverse:反转给定范围内的元素顺序.
std::copy:将一个范围内的元素复制到另一个范围.
std::find:在给定范围内查找特定的元素.
std::count:计算给定范围内等于特定值的元素的数量.
std::remove:从给定范围内移除所有等于特定值的元素.
std::replace:将给定范围内所有等于特定值的元素替换为另一个值.
std::generate:使用给定的生成器函数填充给定范围内的元素.
std::transform:对给定范围内的每个元素应用一个函数,并将结果存储在另一个范围内.
std::fill:将给定范围内的所有元素设置为特定值.
std::merge:将两个已排序的范围合并为一个排序的范围.
std::partition:根据给定的谓词函数,将给定范围内的元素分为两部分.
std::nth_element:部分排序范围,使得第n个元素在排序后的位置,并保证其左边的元素不大于它,右边的元素不小于它.