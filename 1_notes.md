此外，`C++`标准并未对进程间通信提供任何原生支持，所以使用多进程的方式实现，这会依赖与平台相关的API。
---
the lazy fox jumps over brown dog


* 一般哪些函数可以使用noexcept?
    在C++中,`noexcept`关键字用于指定一个函数不会抛出任何异常.这对于提高代码的性能和可靠性非常有用.以下是一些常见的可以使用`noexcept`的函数:

    1. 析构函数:析构函数通常不应抛出任何异常,因为如果在析构函数中抛出异常,可能会导致程序的未定义行为.

    2. 移动构造函数和移动赋值操作符:这些函数通常应该被标记为`noexcept`,因为它们通常只涉及指针和基本类型的转移,不应抛出异常.此外,标记为`noexcept`的移动操作可以被标准库容器如`std::vector`更有效地使用.

    3. 交换函数:交换函数(如`std::swap`)通常应该被标记为`noexcept`,因为它们通常只涉及指针和基本类型的转移,不应抛出异常.

    4. 其他不会抛出异常的函数:如果你知道一个函数不会抛出异常,你应该使用`noexcept`关键字.这可以帮助编译器优化代码,并向其他开发者明确表明该函数不会抛出异常.

    在你提供的代码中,移动构造函数和移动赋值操作符被标记为`noexcept`,这是因为它们只涉及指针和基本类型的转移,不应抛出异常.

#### **网络通信部分**
 
* 网络通信部分,主要有两大块,
1. 第一个是程序启动时,与服务端的交互;
2. 第二个就是文件下载与分享的 P2P 网络.
Prerequisites:
1. 具体的就是 Socket 的各种 API 函数,以及基于这些 API 逻辑的组合
2. 当然可能也会用到操作系统平台所特有的网络 API 函数,如 **WSAAsyncSelect** 网络模型.
Design Points:
1. 网络通信部分如何与 UI 部分进行数据交换:
   是使用队列?
    如果使用队列,多线程之间如何保持资源的一致性和解决资源竞态,使用 Event/CriticalSection/Mutex/Semaphore 等?
   全局变量?
   或者相应的 Windows 操作平台提供的特殊通信技术,如 PostMessage 函数/管道?

#### **执行策略是如何工作的?**

执行策略会告诉我们的标准函数,以何种方式进行自动化并行.

`std::execution`命名空间下面,有三种策略类型:

| 策略                                                                                              | 含义                                                                                                                                                                              |
| ------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [sequenced_policy](https://zh.cppreference.com/w/cpp/algorithm/execution_policy_tag_t)            | 算法使用串行的方式执行,这与原始执行方式没有什么区别.全局可用的实例命名为`std::execution::seq`.                                                                                    |
| [parallel_policy](https://zh.cppreference.com/w/cpp/algorithm/execution_policy_tag_t)             | 算法使用多线程的方式进行执行.全局可用的实例命名为`std::execution::par`.                                                                                                           |
| [parallel_unsequenced_policy](https://zh.cppreference.com/w/cpp/algorithm/execution_policy_tag_t) | 算法使用多线程的方式进行执行.并允许对代码进行向量化.在这个例子中,线程间可以对内存进行交叉访问,向量化的内容可以在同一个线程中执行.全局可用的实例命名为`std::execution::par_unseq`. |

执行策略意味着我们需要进行严格限制.严格的约定,让我们有更多并行策略可以使用:

- 并行算法对所有元素的访问,必须不能导致死锁或数据竞争.
- 向量化和并行化中,所有可访问的函数不能使用任何一种阻塞式同步.

我们需要遵守这些规则,这样才不会将错误引入到程序中.


#### 这些是一些常见操作的成本的数量级的概念:

这些操作的精确耗时取决于许多因素,包括硬件/操作系统/网络条件等.以下是一些大致的估计:

1. **一次内存访问**:大约在100纳秒级别.这是从CPU访问主内存的时间,缓存访问会更快.

2. **一次函数调用**:大约在几十到几百纳秒.这取决于函数的复杂性和编译器优化.

3. **一次字符串比较**:取决于字符串的长度和比较算法,可能在几微秒到几十微秒.这假设字符串已经在CPU缓存中.

4. **一次系统调用**:大约在1-10微秒.这是进入内核并返回用户空间的时间,不包括系统调用本身的执行时间.

5. **一次磁盘访问**:
   - 对于固态硬盘(SSD),大约在0.1毫秒(100微秒).
   - 对于机械硬盘(HDD),大约在5-10毫秒.

6. **一个通过网络的消息的成本**:取决于网络的延迟和带宽,可能在几毫秒到几百毫秒.例如,一个典型的局域网延迟可能在0.1-1毫秒,而跨大洲的延迟可能在100-200毫秒.

#### 以下是一些C++标准库中的算法,以及它们的功能描述:

std::reverse:反转给定范围内的元素顺序.
std::copy:将一个范围内的元素复制到另一个范围.
std::find:在给定范围内查找特定的元素.
std::count:计算给定范围内等于特定值的元素的数量.
std::remove:从给定范围内移除所有等于特定值的元素.
std::replace:将给定范围内所有等于特定值的元素替换为另一个值.
std::generate:使用给定的生成器函数填充给定范围内的元素.
std::transform:对给定范围内的每个元素应用一个函数,并将结果存储在另一个范围内.
std::fill:将给定范围内的所有元素设置为特定值.
std::merge:将两个已排序的范围合并为一个排序的范围.
std::partition:根据给定的谓词函数,将给定范围内的元素分为两部分.
std::nth_element:部分排序范围,使得第n个元素在排序后的位置,并保证其左边的元素不大于它,右边的元素不小于它.