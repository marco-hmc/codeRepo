
#### 配置文件
* 为什么有些配置修改了之后,需要重启客户端;而有些则不用?一般而言,具有什么性质的配置,需要重启客户端来生效?
配置的修改是否需要重启客户端取决于应用程序如何处理配置的更改.以下是一些可能需要重启的情况:

1. **初始化配置**:如果配置是在应用程序启动时读取并初始化的,那么任何对配置的更改都需要重启应用程序才能生效.这是因为应用程序在启动时将配置加载到内存中,并在运行过程中使用这些内存中的配置,而不是直接从配置文件中读取.

2. **依赖于配置的资源**:如果应用程序依赖于某些根据配置创建的资源(例如数据库连接/线程池等),那么更改这些配置可能需要重启应用程序,以便重新创建这些资源.

3. **安全性和稳定性**:对于一些可能影响应用程序安全性或稳定性的配置,应用程序可能会要求重启,以确保更改能够在一个清晰/定义良好的状态下生效.

相反,以下是一些可能不需要重启的情况:

1. **动态配置**:如果应用程序支持动态配置,那么它可能会在运行时检测配置的更改,并立即应用这些更改.这通常需要应用程序具有一种机制来监听配置文件的更改,并在更改发生时更新内存中的配置.

2. **无状态配置**:对于无状态的配置(即不影响应用程序的内部状态的配置),更改这些配置通常不需要重启应用程序.例如,更改日志级别通常不需要重启.

请注意,这些只是一般情况,具体情况取决于应用程序的具体实现.

#### **网络通信部分**

* 一般哪些函数可以使用noexcept?
    在C++中,`noexcept`关键字用于指定一个函数不会抛出任何异常.这对于提高代码的性能和可靠性非常有用.以下是一些常见的可以使用`noexcept`的函数:

    1. 析构函数:析构函数通常不应抛出任何异常,因为如果在析构函数中抛出异常,可能会导致程序的未定义行为.

    2. 移动构造函数和移动赋值操作符:这些函数通常应该被标记为`noexcept`,因为它们通常只涉及指针和基本类型的转移,不应抛出异常.此外,标记为`noexcept`的移动操作可以被标准库容器如`std::vector`更有效地使用.

    3. 交换函数:交换函数(如`std::swap`)通常应该被标记为`noexcept`,因为它们通常只涉及指针和基本类型的转移,不应抛出异常.

    4. 其他不会抛出异常的函数:如果你知道一个函数不会抛出异常,你应该使用`noexcept`关键字.这可以帮助编译器优化代码,并向其他开发者明确表明该函数不会抛出异常.

    在你提供的代码中,移动构造函数和移动赋值操作符被标记为`noexcept`,这是因为它们只涉及指针和基本类型的转移,不应抛出异常.
* 
* 网络通信部分,主要有两大块,
1. 第一个是程序启动时,与服务端的交互;
2. 第二个就是文件下载与分享的 P2P 网络.
Prerequisites:
1. 具体的就是 Socket 的各种 API 函数,以及基于这些 API 逻辑的组合
2. 当然可能也会用到操作系统平台所特有的网络 API 函数,如 **WSAAsyncSelect** 网络模型.
Design Points:
1. 网络通信部分如何与 UI 部分进行数据交换:
   是使用队列?
    如果使用队列,多线程之间如何保持资源的一致性和解决资源竞态,使用 Event/CriticalSection/Mutex/Semaphore 等?
   全局变量?
   或者相应的 Windows 操作平台提供的特殊通信技术,如 PostMessage 函数/管道?

#### 1. grep怎么用?请结合具体例子说明,给出一组命令,能够将某命令输出信息中,若某行存在某一单词,则将该行输出到指定文本文件上

* 显示指定头5行
    -m 5

* nc
    **nc** 即 **n**et**c**at 命令,这个工具在排查网络故障时非常有用,功能非常强大,因而被业绩称为网络界的"瑞士军刀",请读者务必掌握.
    **nc** 命令常见的用法是模拟一个服务器程序被其他客户端连接,或者模拟一个客户端连接其他服务器,连接之后就可以进行数据收发.我们来逐一介绍一下:
    * -v: 这是verbose(详细)模式的开关,会显示更多的信息.
    * -l: 这是listen(监听)模式的开关,使得netcat在指定端口监听进来的连接.
    * nc -v -l 127.0.0.1 6000
    * 

* lsof
    `lsof` 是一个在 Unix 和类 Unix 系统(如 Linux)上用于列出打开的文件的实用程序.以下是一些常见和有用的 `lsof` 参数:

  - `-u`:按照用户或用户组来筛选文件.例如,`lsof -u username` 会列出所有由用户 `username` 打开的文件.
  - `-c`:按照命令名来筛选文件.例如,`lsof -c ssh` 会列出所有由 `ssh` 命令打开的文件.
  - `-p`:按照进程 ID 来筛选文件.例如,`lsof -p 1234` 会列出所有由进程 ID 为 `1234` 的进程打开的文件.
  - `-i`:按照网络连接来筛选文件.例如,`lsof -i TCP` 会列出所有使用 TCP 协议的网络连接.
  - `-d`:按照文件描述符来筛选文件.例如,`lsof -d 2` 会列出所有使用文件描述符 `2` 的文件.
  - `+D`:列出指定目录下被打开的文件.例如,`lsof +D /path/to/directory` 会列出 `/path/to/directory` 目录下所有被打开的文件.

* grep常用的参数
  `grep` 是一个强大的文本搜索工具，它有许多常用的参数来帮助你定制搜索。以下是一些常用的 `grep` 参数：
    - `-i`：忽略大小写。例如，`grep -i "hello" file.txt` 会在 `file.txt` 中搜索 "hello"，不区分大小写。
    - `-v`：反向匹配，即列出不匹配指定模式的行。例如，`grep -v "error" file.txt` 会列出 `file.txt` 中不包含 "error" 的行。
    - `-r` 或 `-R`：递归搜索。例如，`grep -r "hello" dir/` 会在 `dir/` 目录及其所有子目录中搜索 "hello"。
    - `-l`：只列出包含匹配行的文件名，而不是匹配行本身。例如，`grep -l "hello" file1.txt file2.txt` 会列出包含 "hello" 的文件名。
    - `-n`：显示匹配行的行号。例如，`grep -n "hello" file.txt` 会在 `file.txt` 中搜索 "hello"，并显示匹配行的行号。
    - `-e`：允许使用多个模式进行搜索。例如，`grep -e "hello" -e "world" file.txt` 会在 `file.txt` 中搜索 "hello" 或 "world"。
    - `-w`：只匹配整个单词，而不是字符串的一部分。例如，`grep -w "log" file.txt` 会匹配 "log" 这个单词，而不会匹配 "blog" 或 "logs"。
    - `-c`：计算匹配行的数量。例如，`grep -c "hello" file.txt` 会计算 `file.txt` 中 "hello" 的数量。
    * your_command | grep -e "要搜索的单词" -n -m 1 -B 1 > 输出文件名
    * (your_command | head -n 1; your_command | grep "你的单词") > 输出文件名 

* telnet命令
`telnet` 是一个网络协议和命令行工具,用于在互联网或局域网中的主机之间创建一个基于文本的交互式通信连接.以下是一些常见的 `telnet` 用法:

    1. 连接到远程主机:最基本的 `telnet` 用法是连接到远程主机.你只需要提供主机名(或 IP 地址)和端口号.例如,`telnet example.com 80` 会尝试连接到 `example.com` 的 80 端口.

    2. 检查端口是否开放:你可以使用 `telnet` 来检查远程主机的特定端口是否开放.如果 `telnet` 能够成功连接,那么端口就是开放的.例如,`telnet example.com 22` 会尝试连接到 `example.com` 的 22 端口(通常用于 SSH).

    3. 发送 HTTP 请求:你可以使用 `telnet` 来手动发送 HTTP 请求.首先,连接到 Web 服务器的 80 端口(或 443 端口用于 HTTPS),然后手动输入 HTTP 请求头.例如:

    ```bash
    telnet example.com 80
    GET / HTTP/1.1
    Host: example.com
    ```

    4. 使用 `telnet` 进行邮件传输协议(SMTP)会话:你可以使用 `telnet` 连接到邮件服务器的 25 端口(SMTP 的默认端口),然后手动输入 SMTP 命令来发送电子邮件.

    请注意,`telnet` 不提供任何加密,所有的通信内容都是明文的.因此,对于需要安全通信的场景,应该使用 SSH 或其他加密的协议,而不是 `telnet`.

* 
这篇blog试图讲明当一个c函数被调用时,一个**栈帧(stack frame)**是如何被建立,又如何被消除的.这些细节跟操作系统平台及编译器的实现有关,下面的描述是针对运行在Intel奔腾芯片上Linux的gcc编译器而言.c语言的标准并没有描述实现的方式,所以,不同的编译器,处理器,操作系统都可能有自己的建立栈帧的方式.

#### **执行策略是如何工作的?**

执行策略会告诉我们的标准函数,以何种方式进行自动化并行.

`std::execution`命名空间下面,有三种策略类型:

| 策略                                                                                              | 含义                                                                                                                                                                              |
| ------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [sequenced_policy](https://zh.cppreference.com/w/cpp/algorithm/execution_policy_tag_t)            | 算法使用串行的方式执行,这与原始执行方式没有什么区别.全局可用的实例命名为`std::execution::seq`.                                                                                    |
| [parallel_policy](https://zh.cppreference.com/w/cpp/algorithm/execution_policy_tag_t)             | 算法使用多线程的方式进行执行.全局可用的实例命名为`std::execution::par`.                                                                                                           |
| [parallel_unsequenced_policy](https://zh.cppreference.com/w/cpp/algorithm/execution_policy_tag_t) | 算法使用多线程的方式进行执行.并允许对代码进行向量化.在这个例子中,线程间可以对内存进行交叉访问,向量化的内容可以在同一个线程中执行.全局可用的实例命名为`std::execution::par_unseq`. |

执行策略意味着我们需要进行严格限制.严格的约定,让我们有更多并行策略可以使用:

- 并行算法对所有元素的访问,必须不能导致死锁或数据竞争.
- 向量化和并行化中,所有可访问的函数不能使用任何一种阻塞式同步.

我们需要遵守这些规则,这样才不会将错误引入到程序中.

> Note:
>
> STL的自动并行化,并不总能保证有加速.因为具体的情况都不一样,所以可能在很多情况下并行化并没有加速.多核编程还是很有难度的.

#### **向量化是什么意思?**

向量化的特性需要编译器和CPU都支持,让我们先来简单的了解一下向量化是如何工作的.假设我们有一个非常大的`vector`.简单的实现可以写成如下的方式:

```c++
std::vector<int> v {1, 2, 3, 4, 5, 6, 7 /*...*/};

int sum {std::accumulate(v.begin(), v.end(), 0)};
```

编译器将会生成一个对`accumulate`调用的循环,其可能与下面代码类似:

```c++
int sum {0};

for (size_t i {0}; i < v.size(); ++i) {
	sum += v[i];
}
```

从这点说起,当编译器开启向量化时,就会生成类似如下的代码.每次循环会进行4次累加,这样循环次数就要比之前减少4倍.为了简单说明问题,我们这里没有考虑不为4倍数个元素的情况:

```c++
int sum {0};
for (size_t i {0}; i < v.size() / 4; i += 4) {
	sum += v[i] + v[i+1] + v[i + 2] + v[i + 3];
}
// if v.size() / 4 has a remainder,
// real code has to deal with that also.
```

为什么要这样做呢?很多CPU指令都能支持这种操作`sum += v[i] + v[i+1] + v[i+2] + v[i+3];`,只需要一个指令就能完成.使用尽可能少的指令完成尽可能多的操作,这样就能加速程序的运行.

自动向量化非常困难,因为编译器需非常了解我们的程序,这样才能进行加速的情况下,不让程序的结果出错.目前,至少可以通过使用标准算法来帮助编译器.因为这样能让编译器更加了解哪些数据流能够并行,而不是从复杂的循环中对数据流的依赖进行分析.


#### 这些是一些常见操作的成本的数量级的概念:

这些操作的精确耗时取决于许多因素,包括硬件/操作系统/网络条件等.以下是一些大致的估计:

1. **一次内存访问**:大约在100纳秒级别.这是从CPU访问主内存的时间,缓存访问会更快.

2. **一次函数调用**:大约在几十到几百纳秒.这取决于函数的复杂性和编译器优化.

3. **一次字符串比较**:取决于字符串的长度和比较算法,可能在几微秒到几十微秒.这假设字符串已经在CPU缓存中.

4. **一次系统调用**:大约在1-10微秒.这是进入内核并返回用户空间的时间,不包括系统调用本身的执行时间.

5. **一次磁盘访问**:
   - 对于固态硬盘(SSD),大约在0.1毫秒(100微秒).
   - 对于机械硬盘(HDD),大约在5-10毫秒.

6. **一个通过网络的消息的成本**:取决于网络的延迟和带宽,可能在几毫秒到几百毫秒.例如,一个典型的局域网延迟可能在0.1-1毫秒,而跨大洲的延迟可能在100-200毫秒.

#### 以下是一些C++标准库中的算法,以及它们的功能描述:

std::sort:对给定范围内的元素进行排序.
std::reverse:反转给定范围内的元素顺序.
std::copy:将一个范围内的元素复制到另一个范围.
std::find:在给定范围内查找特定的元素.
std::count:计算给定范围内等于特定值的元素的数量.
std::remove:从给定范围内移除所有等于特定值的元素.
std::replace:将给定范围内所有等于特定值的元素替换为另一个值.
std::generate:使用给定的生成器函数填充给定范围内的元素.
std::transform:对给定范围内的每个元素应用一个函数,并将结果存储在另一个范围内.
std::fill:将给定范围内的所有元素设置为特定值.
std::merge:将两个已排序的范围合并为一个排序的范围.
std::partition:根据给定的谓词函数,将给定范围内的元素分为两部分.
std::nth_element:部分排序范围,使得第n个元素在排序后的位置,并保证其左边的元素不大于它,右边的元素不小于它.