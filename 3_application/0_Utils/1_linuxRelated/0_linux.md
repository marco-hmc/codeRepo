## 基础知识

### 1. Linux目录结构

- `/bin`: 存放基本的用户命令二进制文件。
- `/boot`: 存放系统启动加载器文件。
- `/dev`: 存放设备文件。
- `/etc`: 存放与系统配置相关的文件。
- `/home`: 用户的主目录，每个用户都有一个自己的目录。
- `/lib`: 存放共享库模块。
- `/media`: 用于挂载可移动媒体文件，如CD-ROM。
- `/mnt`: 用于临时挂载文件系统。
- `/opt`: 存放附加的应用程序软件包。
- `/proc`: 一个自动生成的文件系统，提供关于系统的信息。
- `/root`: 系统管理员（root用户）的主目录。
- `/run`: 存放运行时程序数据。
- `/sbin`: 存放系统管理命令的二进制文件。
- `/srv`: 存放由该系统提供的站点特定数据。
- `/sys`: 一个虚拟目录，提供关于系统的信息。
- `/tmp`: 存放临时文件。
- `/usr`: 存放只读的用户文件。
  - `/usr/lib`： 存放系统和应用程序使用的库文件。这里的库文件通常是共享库（`.so` 文件）。
  - `/usr/include`：存放 C/C++ 头文件。这里的头文件通常是系统和应用程序开发所需的头文件。
  - `/usr/share`：存放架构无关的共享数据文件。这里的文件通常是应用程序的共享数据、文档、配置文件等。
- `/var`: 存放预期会不断变化的文件，如日志文件和邮箱。

### 2. 文件管理
* 文件储存原理

  * 文件储存在硬盘上，硬盘的**最小存储单位叫做"扇区"**（Sector）。**每个扇区储存512字节**（相当于0.5KB）。
  * 操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个"块"（block）。这种由多个扇区组成的"块"，是**文件存取的最小单位**。**"块"的大小，最常见的是4KB**，即**连续八个 sector组成一个 block**。
  * 文件数据都储存在"块"中，那么很显然，我们还必须**找到一个地方储存文件的元信息**，比如**文件的创建者、文件的创建日期、文件的大小**等等。**这种储存文件元信息的区域就叫做inode，中文译名为"索引节点"**。

* inode概念

  * 每一个文件都有对应的inode，里面包含了与该文件有关的一些信息

* inode内容

  * 文件的字节数
  * 文件拥有者的User ID
  * 文件的Group ID
  * 文件的读、写、执行权限
  * 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间
  * 链接数，即有多少文件名指向这个inode
  * 文件数据block的位置

* 可以用`stat`命令，查看某个文件的inode信息：`stat filename`

* inode的大小

  * inode也会消耗硬盘空间，所以硬盘格式化的时候，**操作系统自动将硬盘分成两个区域**。一个是**数据区**，存放文件数据；另一个是**inode区**（inode table），存放**inode所包含的信息**
  * 每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是**每1KB或每2KB就设置一个inode**。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。
  * 查看每个硬盘分区的inode总数和已经使用的数量，可以使用`df`命令：`df -i`
  * 查看每个inode节点的大小，可以用：`sudo dumpe2fs -h /dev/hda | grep "Inode size"`
  * 由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件

* **inode号码**

  * 每个inode都有一个号码，操作系统用inode号码来识别不同的文件
  * 这里值得重复一遍，Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号
  * 表面上，用户通过文件名，打开文件。实际上，系统内部这个过程**分成三步**：首先，**系统找到这个文件名对应的inode号码**；其次，**通过inode号码，获取inode信息**；最后，**根据inode信息，找到文件数据所在的block，读出数据**
  * 查看文件名对应的inode号码：`ls -i filename`

* **目录文件**

  * Unix/Linux系统中，目录（directory）也是一种文件。**打开目录，实际上就是打开目录文件**
  * 目录文件的结构非常简单，就是一系列目录项（dirent）的列表。**每个目录项，由两部分组成：所包含文件的文件名，以及该文件名对应的inode号码**
  * 列出整个目录文件，即文件名和inode号码：`ls -i dir`
  * 要查看文件的详细信息，就必须根据inode号码，访问inode节点，读取信息。`ls -l`命令列出文件的详细信息
  * 目录权限
    * 理解了上面这些知识，就能理解目录的权限。目录文件的读权限（r）和写权限（w），都是针对目录文件本身，即**不同用户能以什么权限访问操作对该目录文件**。
    * 例如这里不同用户对tmp目录文件（d可以查出tmp是目录文件，d表示directory，即目录）分别为rwxr-xr-x，第一组的三个字符，即rwx，表示文件拥有者用户的对该文件的读写权限，第二组的三个字符，即r-x，表示文件拥有者用户所在的用户组里的其他用户对该文件的读写权限，第三组的三个字符，即r-x，表示文件拥有者用户所在的用户组以外的用户对该文件的读写权限。一个某个用户下运行的进程访问操作该目录文件只能以该用户所具有的对该目录文件的权限进行操作
    * 由于目录文件内**只有文件名和inode号码**，所以**如果只有读权限，只能获取文件名**，无法获取其他信息，因为其他信息都储存在inode节点中，而读取inode节点内的信息需要目录文件的执行权限（x）

* 硬链接

  * 一般情况下，文件名和inode号码是"一一对应"关系，每个inode号码对应一个文件名
  * **但是，Unix/Linux系统允许，多个文件名指向同一个inode号码。这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为"硬链接"（hard link）。**
  * ln命令可以创建硬链接：`ln sourcefile destfile`
  * 运行上面这条命令以后，源文件与目标文件的inode号码相同，都指向同一个inode。**inode信息中有一项叫做"链接数"，记录指向该inode的文件名总数，**这时就会增加1。
  * **反过来，删除一个文件名，就会使得inode节点中的"链接数"减1。当这个值减到0，表明没有文件名指向这个inode，系统就会回收这个inode号码，以及其所对应block区域。**
  * 这里顺便说一下目录文件的"链接数"。创建目录时，默认会生成两个目录项："."和".."。前者的inode号码就是当前目录的inode号码，等同于当前目录的"硬链接"；后者的inode号码就是当前目录的父目录的inode号码，等同于父目录的"硬链接"。所以，任何一个目录的"硬链接"总数，总是等于2（某一目录的目录名和该目录的当前目录名）

* 软连接

  * 除了硬链接以外，还有一种特殊情况
  * **文件A和文件B的inode号码虽然不一样**，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的"软链接"（soft link）或者"符号链接（symbolic link）
  * 这意味着，**文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错**："No such file or directory"。这是软链接与硬链接最大的不同：文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode"链接数"不会因此发生变化。
  * ln -s命令可以创建软链接：`ln -s sourcefile destfile`

* **inode的特殊作用**

  * 由于inode号码与文件名分离，这种机制导致了一些Unix/Linux系统特有的现象
    * 有时，**文件名包含特殊字符，无法正常删除**。这时，**直接删除inode节点，就能起到删除文件的作用**
    * **移动文件或重命名文件，只是改变文件名，不影响inode号码**
    * 打开一个文件以后，系统就以inode号码来识别这个文件，不再考虑文件名。因此，通常来说，系统无法从inode号码得知文件名
  * 第3点使得软件更新变得简单，可以在不关闭软件的情况下进行更新，不需要重启。因为系统通过inode号码，识别运行中的文件，不通过文件名。更新的时候，新版文件以同样的文件名，生成一个新的inode，不会影响到运行中的文件。等到下一次运行这个软件的时候，文件名就自动指向新版文件，旧版文件的inode则被回收


### 3. Linux的启动过程

* **内核引导**：当计算机打开电源后，首先是**BIOS开机自检**，按照BIOS中设置的启动设备（通常是硬盘）来启动。操作系统接管硬件以后，首先读入 /boot 目录下的内核文件

* **运行init**：init 进程是系统所有进程的起点，你可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动。init 程序首先是需要读取配置文件 /etc/inittab

  * 运行级别
    * 许多程序需要开机启动。它们在Windows叫做"服务"（service），在Linux就叫做"守护进程"（daemon）。init进程的一大任务，就是去运行这些开机启动的程序。但是，**不同的场合需要启动不同的程序**，比如用作服务器时，需要启动Apache，用作桌面就不需要
    * Linux允许为**不同的场合，分配不同的开机启动程序，这就叫做"运行级别"（runlevel）**。也就是说，启动时**根据"运行级别"，确定要运行哪些程序**
    * Linux系统有7个运行级别(runlevel)：
      - 运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动
      - 运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆
      - 运行级别2：多用户状态(没有NFS)
      - 运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式
      - 运行级别4：系统未使用，保留
      - 运行级别5：X11控制台，登陆后进入图形GUI模式
      - 运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动

* 系统初始化：在init的配置文件中有这么一行： si::sysinit:/etc/rc.d/rc.sysinit　它调用执行了/etc/rc.d/rc.sysinit，而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。它主要完成的工作有：**激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务**

* 建立终端：rc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。init接下来会打开6个终端，以便用户登录系统。在inittab中的以下6行就是定义了6个终端

  ```shell
  1:2345:respawn:/sbin/mingetty tty1
  2:2345:respawn:/sbin/mingetty tty2
  3:2345:respawn:/sbin/mingetty tty3
  4:2345:respawn:/sbin/mingetty tty4
  5:2345:respawn:/sbin/mingetty tty5
  6:2345:respawn:/sbin/mingetty tty6
  ```

  从上面可以看出在2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。同时它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份。

* 用户登录系统：一般来说，用户的登录方式有三种：

  - 命令行登录
  - ssh登录
  - 图形界面登录

* 对于运行级别为5的图形方式用户来说，他们的登录是通过一个图形化的登录界面。登录成功后可以直接进入 KDE、Gnome 等窗口管理器。而本文主要讲的还是文本方式登录的情况：当我们看到mingetty的登录界面时，我们就可以输入用户名和密码来登录系统了。Linux 的账号验证程序是 login，login 会接收 mingetty 传来的用户名作为用户名参数。然后 login 会对用户名进行分析：如果用户名不是 root，且存在 /etc/nologin 文件，login 将输出 nologin 文件的内容，然后退出。这通常用来系统维护时防止非root用户登录。**只有/etc/securetty中登记了的终端才允许 root 用户登录**，如果不存在这个文件，则 root 用户可以在任何终端上登录。/etc/usertty文件用于对用户作出附加访问限制，如果不存在这个文件，则没有其他限制

* 图形模式与文字模式的切换方式

  * Linux预设提供了**六个命令窗口终端机让我们来登录**
  * 默认我们登录的就是第一个窗口，也就是tty1，这个六个窗口分别为tty1,tty2 … tty6，你可以按下Ctrl + Alt + F1 ~ F6 来切换它们
  * 如果你安装了图形界面，默认情况下是进入图形界面的，此时你就可以按Ctrl + Alt + F1 ~ F6来进入其中一个命令窗口界面
  * 当你进入命令窗口界面后再返回图形界面只要按下Ctrl + Alt + F7 就回来了
  * 如果你用的vmware 虚拟机，命令窗口切换的快捷键为 Alt + Space + F1~F6. 如果你在图形界面下请按Alt + Shift + Ctrl + F1~F6 切换至命令窗口

### 4. 文件描述符和句柄

> [彻底搞懂文件描述符/文件句柄/文件指针的区别与联系](https://blog.csdn.net/nazeniwaresakini/article/details/104220111)
>
> [Linux文件描述符到底是什么?](http://c.biancheng.net/view/3066.html)

文件描述符和句柄的本质是类似的,都是各种东西的标示符.而windows下,使用句柄作为这种标示符集合的名字;而linux,使用文件描述符作为标示符集合的名字.而在具体处,会因为两者的设计理念略有区别.

* ***那为什么要有文件描述符?***

  ​	首先,Linux 中一切皆文件,比如 C++ 源文件/视频文件/Shell脚本/可执行文件等,就连键盘/显示器/鼠标等硬件设备也都是文件.

  ​	 一个 Linux 进程可以打开成百上千个文件,为了表示和区分已经打开的文件,Linux 会给每个文件分配一个编号(一个 ID),这个编号就是一个整数,被称为文件描述符(File Descriptor).

* ***为什么用非负整数表示文件描述符?而不是直接用路径?***

  ​	路径存储会带来很多麻烦.

  ​	而且需要区分已经打开的文件,即有文件描述符

  ​	除此创建的socket套接字在linux也有一个文件描述符,这个socket是存在内存中的,不存在路径.

* ***文件描述符是如何工作的?***

  ![Linux文件描述符表示意图](https://s2.loli.net/2022/02/06/Wpcz168d2NSxwmG.gif)

  ​	文件描述符表每个进程都有一个,打开文件表和 i-node 表整个系统只有一个,它们三者之间的关系如上图所示.

  ​	每个进程的PCB块中,会有一个文件描述符表,不同进程可以有相同的文件描述符,但它们的指向不一定相同.从图中不难得出,通过内部的映射,可以实现将文件描述符号准确地对应到文件中.可打开文件表/i-node表实际做了什么呢?

* ***打开文件表有哪些功能?***
  
  - 文件偏移量,也就是文件内部指针偏移量.调用 read() 或者 write() 函数时,文件偏移量会自动更新,当然也可以使用 lseek() 直接修改.
  - 状态标志,比如只读模式/读写模式/追加模式/覆盖模式等.
  - i-node 表指针.
  
* ***i-node表有哪些功能?***
  
  - 文件类型,例如常规文件/套接字或 FIFO.
  - 文件大小.
  - 时间戳,比如创建时间/更新时间.
  - 文件锁.


Linux 系统下可能还会问什么是 daemon 进程，如何产生 daemo 进程，什么是僵尸进程，僵尸进程如何产生和消除(bilibili 问过)。

