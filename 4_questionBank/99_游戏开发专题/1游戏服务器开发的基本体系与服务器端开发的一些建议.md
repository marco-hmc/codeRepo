# 1 游戏服务器开发的基本体系与服务器端开发的一些建议

**这里我把一些游戏开发方面的东西整理一下，希望能对那些想做游戏服务器开发的朋友有所帮助。**

1. 系统初始化 
2. 游戏逻辑
3. 数据库系统
4. 缓存系统
5. 游戏日志
6. 游戏管理工具
7. 公共服务组件

### 二，游戏逻辑

**游戏逻辑是游戏的核心功能实现，也是整个游戏的服务中心，它被开发的好坏，直接决定了游戏服务器在运行中的性能。**那在**游戏逻辑的开发中我们要注意些什么呢？**

1. **协议层，**也叫前后台交互层，它主要负责与前台交互协议的解析和返回数据。在这一层基本上没有什么业务逻辑实现。**与前台交互的数据都在这一层开始，也在这一层终止。**比如你使用了Netty框架，那么Netty的ChannelHandlerContext即Ctx只能出现在这一层，他不能出现到游戏业务逻辑代码的实现中
接收到客户端的请求，在这一层把需要的参数解析出来，再把参数传到业务逻辑方法中，业务逻辑方法处理完后，把要返回给客户端的数据再返回到这一层，在这一层组织数据，返回给客户端，这样就可以把业务逻辑和网络层分离，业务逻辑只关心业务实现，而且也方便对业务逻辑进行单元测试。

### 四，缓存系统

游戏中，**客户端与服务器的交互是要求低延迟的**，延迟越低，用户体验越好。像之前说过的一样，低延迟就是要求服务器处理业务尽量的快，客户端一个请求过来，要在最短的时间内响应结果，最低不得超过500ms，因为加上来回的网络传输耗时，基本上就是600ms-到700ms了，再长玩家就会觉得游戏卡了。

**游戏中常见的缓存**有两种：

1. 直接把数据存储在jvm或服务器内存中
2. 使用**第三方的缓存工具，这里推荐Redis**，详细的用法可以自己去查询。**（本公号内有系列文章，详情见【菜单栏】- 【技术文章】 - 【基础系列】 - 【实战R1，实战R2】）**

### 五，游戏日志

1. **系统日志**，主要记录游戏服务器的系统情况。比如：数据库能否正常连接，服务器是否正常启动，数据是否正常加载；
2. **玩家行为日志**，比如玩家发送了什么请求，得到了什么物品，消费了多少货币等等；
3. **统计日志，**这种日志是对游戏中所有玩家某种行为的一种统计，根据这个统计来分析大部分玩家的行为，得出一些共性或不同之处，以方法运营做不同的活动吸引用户消费。

在**构架设计中，日志记录一定要做为一种强制行为**，因为不强制的话，可能由于某种原因某个功能忘记加日志了，那么当这个功能出问题了，或者运营跟我们要这个功能的一些数据库，就傻眼了。又得加需求，改代码了。**日志一定要设计一种良好的格式**，日志记录的数据要容易读取，分解。**日志行为可以用枚举描述**，在功能最后的处理方法里面加上这个枚举做为参数，这样不管谁在调用这个方法时，都要去加参数描述。
俗话说，工欲善其事，必先利其器。**游戏管理工具是对游戏运行中的一系列问题处理的一种工具。**它不仅是给开发人员用，大多数是给运营使用。游戏上线后，我们需要针对线上的问题进行不同的处理。不可能把所有问题都让程序员去处理吧，于是程序员们想到了一个办法，给你们做一个工具，你们爱谁处理谁处理去吧。

### 六， 游戏管理工具

游戏管理工具是一个不断增涨的系统，因为它很多时候是伴随着游戏中遇到的问题而实现的。

但是根据经验，**有一些功能是必须有的**，比如：

- 服务器管理，主要负责服务器的开启，关闭，服务器配置信息，玩家信息查询；
- 玩家管理，比如踢人，封号；
- 统计查询，玩家行为日志查询，统计查询，次留率查询，邮件服务，修改玩家数据等。

根据游戏的不同要求，**凡是可以能过工具实现的，都做到游戏管理工具里面。**它是针对所有服务器的管理。

一个好的，全的游戏管理工具，可以提高游戏运营中遇到问题处理的效率，为玩家提供更好的服务。

### 七，公共组件

公共组件是为游戏运行中提供公共的服务。例如：

- 充值服务器，我们没必须一个服用一个充值，而且你也不能对外提供多个充值服务器地址，和第三方公司对接，他们绝对不干，这是要疯呀；
- 还有运营搞活动时的礼包码；
- 还有注册用户的管理，玩家一个注册账号可以进不同的区等。

**这些都是针对所有区服提供的服务，所以要单独做，与游戏逻辑分开**，这样方便管理，部署和负载均衡。

还有**SDK的登陆验证**，现在手游比较多，与渠道对接里要进行验证，这往往是很多http请求，速度慢，所以这个也**要拿出来单独做**，不要在游戏逻辑中去验证，因为网络IO的访问时间是不可控制的，http是阻塞的请求。

所以，综上来看，**一个游戏服务器起码有几个大的功能模块组成**：

1. 游戏逻辑工程；
2. 日志处理工程；
3. 充值工程；
4. 游戏管理工具工程；
5. 用户登陆工程；
6. 公共活动工程等。

根据游戏的不同需要，可能还有其它的。**所在构架的设计中，一定要考虑到系统的分布式部署，尽量把公共的功能拆出来做**，这样可以增强系统的可扩展性。

### 服务器端开发的一些建议

本文作为游戏服务器端开发的基本大纲，是游戏实践开发中的总结。

1. 第一部分 —— **专业基础**，用于指导招聘和实习考核；
2. 第二部分 —— **游戏入门**，讲述游戏服务器端开发的基本要点；
3. 第三部分 —— **服务端架构**，介绍架构设计中的一些基本原则。

**希望能帮到大家！**


## 一、专业基础

### 1.1网络

#### 1.1.1理解TCP/IP协议

- 网络传输模型
- 滑动窗口技术
- 建立连接的三次握手与断开连接的四次握手
- 连接建立与断开过程中的各种状态
- TCP/IP协议的传输效率

**思考：**

1. 请解释DOS攻击与DRDOS攻击的基本原理
2. 一个100Byte数据包，精简到50Byte, 其传输效率提高了50%
3. TIMEWAIT状态怎么解释？

#### 1.1.2掌握常用的网络通信模型

- Select
- Epoll，边缘触发与平台出发点区别与应用
- Select与Epoll的区别及应用

### 1.2存储

- 计算机系统存储体系
- 程序运行时的内存结构
- 计算机文件系统，页表结构
- 内存池与对象池的实现原理，应用场景与区别
- 关系数据库MySQL的使用
- 共享内存

## 二、游戏开发入门

### 2.3网络模型

- **自造轮子:** Select, Epoll， **Epoll一定比Select高效吗？**
- **开源框架**: Libevent, libev, ACE。**（本公众号内有Libevent源码详解，详情见【菜单】-【开源软件】-【源码分析】-【网络库I】）**

### **2.4数据持久化**

- 自定义文件存储，如《梦幻西游》
- 关系数据库: MySQL
- NO-SQL数据库: MongoDB
- 选择存储系统要考虑到因素：稳定性，性能，可扩展性

### 2.5内存管理

- 使用内存池和对象池，禁止运行期间动态分配内存
- 写内存保护，使用带内存保护的函数(strncpy, memcpy, snprintf, vsnprintf等)

### 2.6日志系统

- **简单高效**，大量日志操作不应该影响程序性能
- **稳定**，做到服务器崩溃是日志不丢失
- **完备**，玩家关键操作一定要记日志，理想的情况是通过日志能重建任何时刻的玩家数据
- **开关**，开发日志的要加级别开关控制

### 2.7通信协议

- 采用**PDL(Protocol Design Language)**， 如Protobuf，可以同时生成前后端代码，减少前后端协议联调成本， 扩展性好
- **JSON**，文本协议，简单，自解释，无联调成本，扩展性好，也很方便进行包过滤以及写日志
- **自定义二进制协议**，精简，有高效的传输性能，完全可控，几乎无扩展性

### 2.9多线程与同步

- 消息队列进行同步化处理

### 2.10状态机

- 强化角色的状态
- 前置状态的检查校验

### 2.11数据包操作

- 合并, 同一帧内的数据包进行合并，减少IO操作次数
- 单副本, 用一个包尽量只保存一份，减少内存复制次数
- AOI同步中减少中间过程无用数据包

### 2.12状态监控

- 随时监控服务器内部状态
- 内存池，对象池使用情况
- 帧处理时间
- 网络IO
- 包处理性能
- 各种业务逻辑的处理次数

### 2.13包频率控制

- 基于每个玩家每条协议的包频率控制，瘫痪变速齿轮

### 2.14开关控制

- 每个模块都有开关，可以紧急关闭任何出问题的功能模块

### 2.15反外挂反作弊

- 包频率控制可以消灭变速齿轮
- 包id自增校验，可以消灭WPE
- 包校验码可以消灭或者拦截篡改的包
- 图形识别码，可以踢掉99%非人的操作
- **魔高一尺，道高一丈**

### 2.16热更新

- 核心配置逻辑的热更新，如防沉迷系统，包频率控制，开关控制等
- 代码基本热更新，如Erlang，Lua等

### 2.17防刷

- 关键系统资源（如元宝，精力值，道具，装备等）的产出记日志
- 资源的产出和消耗尽量依赖两个或以上的独立条件的检测
- 严格检查各项操作的前置条件
- 校验参数合法性

### 2.18防崩溃

- 系统底层与具体业务逻辑无关，可以用大量的机器人压力测试暴露各种bug，确保稳定
- 业务逻辑建议使用脚本
- 系统性的保证游戏不会崩溃

### 2.19性能优化

- IO操作异步化
- IO操作合并缓写 （事务性的提交db操作，包合并，文件日志缓写）
- Cache机制
- 减少竞态条件 (避免频繁进出切换，尽量减少锁定使用，多线程不一定由于单线程) 多线程不一定比单线程快
- 减少内存复制
- 自己测试，用数据说话，别猜

### 2.20运营支持

- 接口支持：实时查询，控制指令，数据监控，客服处理等
- 实现考虑提供http接口

### 2.21容灾与故障预案

略

## 三、服务器端架构

### 3.1什么是好的架构？

- 满足业务要求
- 能迅速的实现策划需求，响应需求变更
- 系统级的稳定性保障
- 简化开发。将复杂性控制在架构底层，降低对开发人员的技术要求，逻辑开发不依赖于开发人员本身强大的技术实力，提高开发效率
- 完善的运营支撑体系

### 3.2架构实践的思考

游戏服务器的设计是一项颇有挑战性的工作，游戏服务器的发展也由以前的单服结构转变为多服机构，甚至出现了bigworld引擎的分布式解决方案，最近了解到Unreal的服务器解决方案atlas也是基于集群的方式。

 负载均衡是一个很复杂的课题，这里暂不谈bigworld和atlas的这类服务器的设计，更多的是基于功能和场景划分服务器结构。

首先说一下**思路**，**服务器划分基于以下原则**：

1. 分离游戏中占用系统资源（cpu，内存，IO等）较多的功能，独立成服务器。
2. 在同一服务器架构下的不同游戏，应尽可能的复用某些服务器（进程级别的复用）。
3. 以多线程并发的编程方式适应多核处理器。
4. 宁可在服务器之间多复制数据，也要保持清晰的数据流向。
5. 主要按照场景划分进程，若需按功能划分，必须保持整个逻辑足够的简单，并满足以上1，2点。
    服务器结构图：

![img](https://mmbiz.qpic.cn/mmbiz_png/axIncRj5l4e3WnEIEibOmaf1W4QE71eZHiaW5FUiaiaASHibrib8DDXeP0B9gdEiaJBJCkiaq8aOvJosaia24RicEals2ocg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



### 各个服务器的简要说明：

**Gateway** 是应用网关，主要用于保持和client的连接，该服务器需要2种IO：

1. 对client采用高并发连接，低吞吐量的网络模型，如IOCP等
2. 对服务器采用高吞吐量连接，如阻塞或异步IO。

**网关主要有以下用途：**

- 分担了网络IO资源，同时，也分担了网络消息包的加解密，压缩解压等cpu密集的操作。
- 
    隔离了client和内部服务器组，对client来说，它只需要知道网关的相关信息即可（ip和port）。client由于一直和网关保持常连接，所以切换场景服务器等操作对client来说是透明的。
- 维护玩家登录状态。

**World Server** 是一个控制中心，它负责把各种计算资源分布到各个服务器，**它具有以下职责：**

- **
    **管理和维护多个Scene Server。
- 管理和维护多个功能服务器，主要是同步数据到功能服务器。
- 复杂转发其他服务器和Gateway之间的数据。
- 实现其他需要跨场景的功能，如组队，聊天，帮派等。

**Phys Server** 主要用于玩家移动，碰撞等检测。
所有玩家的移动类操作都在该服务器上做检查，所以该服务器本身具备所有地图的地形等相关信息。具体检查过程是这样的：首先，**Worldserver**收到一个移动信息，WorldServer收到后向**Phys Serve**r请求检查，Phys Server检查成功后再返回给**world Server**，然后world server传递给相应的**Scene Server**。

**Scene Server**场景服务器，按场景划分，每个服务器负责的场景应该是可以配置的。理想情况下是可以动态调节的。

**ItemMgr Server** 物品管理服务器，负责所有物品的生产过程。在该服务器上存储一个物品掉落数据库，服务器初始化的时候载入到内存。任何需要产生物品的服务器均与该服务器直接通信。

**AIServer** 又一个功能服务器，负责管理所有NPC的AI。AI服务器通常有2个输入：

- 一个是Scene Server发送过来的玩家相关操作信息
- 另一个时钟Timer驱动

在这个设计中，对其他服务器来说，AIServer就是一个拥有很多个NPC的客户端。AIserver需要同步所有与AI相关的数据，包括很多玩家数据。由于AIServer的Timer驱动特性，可在很大程度上使用TBB程序库来发挥多核的性能。

**把网络游戏服务器分拆成多个进程，分开部署。**

- 这种设计的**好处**是模块自然分离，可以单独设计。分担负荷，可以提高整个系统的承载能力。
- **缺点**在于，网络环境并不那么可靠。跨进程通讯有一定的不可预知性。服务器间通讯往往难以架设调试环境，并很容易把事情搅成一团糨糊。而且正确高效的管理多连接，对程序员来说也是一项挑战。

前些年，我也曾写过好几篇与之相关的设计。这几天在思考一个问题：**如果我们要做一个底层通用模块，让后续开发更为方便。到底要解决怎样的需求？**这个需求应该是单一且基础的，每个应用都需要的。
我们可以在一条 TCP 连接之上做到这一点。一旦实现，可以给游戏服务的开发带来极大的方便。
可以把游戏系统内的各项服务，包括并不限于登陆，拍卖，战斗场景，数据服务，等等独立服务看成网络上的若干终端。每个玩家也可以是一个独立终端。它们一起构成一个网络。在这个网络之上，终端之间可以进行可靠的连接和通讯。
**实现可以是这样的：**

- 每个虚拟终端都在游戏虚拟网络(Game Network)上有一个**唯一地址** (Game Network Address , GNA) 。这个地址可以预先设定，也可以动态分配。每个**终端**都可以通过游戏网络的若干接入点 ( GNAP ) **通过唯一一条 TCP 连接接入网络。**
- 接入过程需要通过**鉴权**。
    鉴权过程依赖内部的安全机制，可以包括密码证书，或是特别的接入点区分。（例如，玩家接入网络就需要特定的接入点，这个接入点接入的终端都一定是玩家）
- 鉴权通过后，网络为终端分配一个**固定的游戏域名**。例如，玩家进入会分配到 player.12345 这样的域名，数据库接入可能分配到 database 。
- 游戏网络**默认提供一个域名查询服务**（这个服务可以通过鉴权的过程注册到网络中），让每个终端都能通过域名查询到对应的地址。
- 然后，游戏网络里**所有合法接入的终端都可以通过其地址相互发起连接并通讯**了。
- **整个协议建立在 TCP 协议之上，工作于唯一的这个 TCP 连接上**。和直接使用 TCP 连接不同。游戏网络中每个终端之间相互发起连接都是可靠的。不仅玩家可以向某个服务发起连接，反过来也是可以的。玩家之间的直接连接也是可行的（是否允许这样，取决于具体设计）。
    由于每个虚拟连接都是建立在单一的 TCP 连接之上。所以减少了互连网上发起 TCP 连接的各种不可靠性。**鉴权**过程也是**一次性唯一**的。
- 并且我们**提供域名反查服务**，我们的游戏服务可以清楚且安全的知道连接过来的是谁。
- **系统**可以**设计为，****游戏网络上每个终端离网，域名服务将广播这条消息**，通知所有人。这种广播服务在互联网上难以做到，但无论是广播还是组播，在这个虚拟游戏网络中都是可行的。
    在这种设计上。在逻辑层面，我们**可以**让玩家直接把聊天信息从玩家客互端发送到聊天服务器，而不需要建立多余的 TCP 连接，也不需要对转发处理聊天消息做多余的处理。聊天服务器可以独立的存在于游戏网络。**也****可以**让广播服务主动向玩家推送消息，由服务器向玩家发起连接，而不是所有连接请求都是由玩家客互端发起。
- 虚拟游戏网络的构成是一个独立的层次，完全可以撇开具体游戏逻辑来实现，并能够单独去按承载量考虑具体设计方案。非常利于剥离出具体游戏项目来开发并优化。
- 最终，我们或许需要的**一套 C 库**，用于游戏网络内的通讯。api 可以和 socket api 类似。额外多两条接入与离开游戏网络即可。