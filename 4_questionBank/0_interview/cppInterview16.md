#### 进程间的通信方式有哪些？互斥的具体原理？
进程的通信方式分为管道、socket和XSI(System V)。<br>
* XSI又分为msg(消息队列)，sem(信号量数组)，shm(共享内存)

管道pipe有一个管道pipe函数，它是一个半双工通信，同一时间，数据只能从一端流向另一端。一端为读端一端为写端。pipefd[0]是读端，pipefd[1]为写端。pipe是一个匿名管道，只能用于具有亲缘关系的进程使用。<br>
不同于mkfifo，mkfifo是一个命名的管道，不同进程都可以使用。<br>
因为半双工的关系，如果要实现全双工通信，就需要两个管道，分别对应同一进程的读写。<br>

XSI是System V规范的进程通信手段而不是POSIX标准。<br>
包括消息队列，信号量数组以及共享内存。<br>
这些通信手段都需要进程使用同一个协议文件。就是通信协议。<br>

互斥的具体原理是，互斥适用于线程。互斥具体就是保护临界区，防止竞争条件的发生。<br>
#### 用过数据库吗？masql数据库中会用到哪些锁？
乐观锁与悲观锁。
#### 谈一下对乐观锁和悲观锁的认识
乐观锁就是很乐观，觉得所有的资源都没有被同时访问，所以到了访问的最后才上锁。悲观锁很悲观，每次访问的时候都绝对所有的资源都被同时访问，所以，每次访问资源都会先上锁。<br>
具体:
* 悲观锁，总是觉得被人会修改数据，所以每次拿数据都会先上锁，这样别的进程还是线程都不能访问，直到它自己拿到锁。这种在传统关系型数据库就会常常用到，比如行锁，表锁，读写锁等，操作之前先上锁。
* 乐观锁，就不会觉得别人会修改数据，不上锁，在更新版本的时候，判断一下此期间别人是否更新棵数据，可以适用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似与写机制，其实都是提供乐观锁

乐观锁适用于写少的情况，冲突少发生，加大吞吐量。悲观锁就适合写多的情况，冲突发生多。
#### 流量控制是怎么实现的？（滑动窗口）滑动窗口的大小具体是怎么变化的？
流量控制是通过滑动窗口和拥塞窗口共同控制的。滑动窗口的大小，在TCP传输层，建立链接的时候，接收端会给发送端报一个窗口大小，就叫做Advertised window。就是告诉发送端，一次接受的只可以那么多，多了，就可能丢包。在窗口上就会有NBE与LBR，他们的差就是应用层没读取的部分，叫做MaxRcvBuffer。而且TCP按顺序ACK，后面来了，前面没来，那么也要先缓存，不发确认包。<br>
具体是怎么变化？慢启动和快速重传试。<br>

#### 慢启动曲线
慢启动，先发一个，可以就发两个，两个可以发四个，如此下去，遇到sshread？那就线性，一个一个加，咦？拥塞了，丢包了？两种方案，快速重传或者将shhresh设为窗口的一半，然后又一个发，两个发，三个发，遇到sshresh的点，就一个一个发，这时就会看见网络卡顿。快速重传就将减半的sshresh+3，然后又一个一个发。
#### https在平时的项目中有用到过吗？
用过，套了一层SSL层。非对称加密到对称加密🔐
#### 301和302的区别？
301 redirect，302 temoperary redirect。
* 301 永久重定向，也就是在HEAD请求下，头部Location字段中明确指出新的URI，在响应体永久URI，若是客户端使用POST请求，需要客户同意，而且默认资源缓存
* 302 临时重定向，也就是只是临时本次重定向，不修改书签中的指向，但是301是会修改的。而重定向时使用GET请求返回报文中Location字段指明的URL，响应缓存只有在Cache-control或Expires进行指定才缓存，并不是默认缓存
#### 三次握手的具体实现，time_wait原理？
满足双方一发一收请求和响应。客户端发送seq=x,ACK=0,SYN给接收端，接收端接收到了，就发送SYN=1，ACK=1，ack=x+1，seq=y。然后客户端收到了接收端的包就发送SYN，ACK，seq=x+1，ack=y+1给接收端，然后建立了链接。就开始发送数据。time_wait一般用于挥手的时候，实现等待接收端跟客户端挥手时候，客户端响应挥手的等待时间FIN_WAIT，那么按理说到这里，A就可以结束了，但是TCP协议要求A等待TIME_WAIT时间，足够长，等待B收不到包，B就会重发，这样A就有足够的时间到达B。这就是TIME_WAIT的原理，是TCP为了保证可靠。<br>
#### 怎么求两个节点的最近公共祖先？

#### 100万个ip，找出最多的100个（内存放得下的时候，放不下的时候）
100万个IP，很多。分10万个ip，分别在散列表中进行计数。然后将分批计算的IP取前十个。组合，将相同的加一起计算，如果够100个就输出，不够就继续每批再取100个，再组合，加上原来的，继续通过快速排序，得出最多的100个ip(内存肯定放不下)。
#### poll和epoll的区别
epoll是poll的升级版。其实poll和epoll都是用于同时监视多个文件描述符的。poll需要自己管理一组文件描述符的集合，而epoll就使得内核为我们管理这个结构体的数组，通过epoll_create。epoll不是一个函数，他是一组函数的实现。<br>
* poll布置完监视任务就需要取得监视的结果，而epoll就是用epoll_wait函数进行阻塞监视并返回监视结果。
epoll更成熟。<br>
标准:
