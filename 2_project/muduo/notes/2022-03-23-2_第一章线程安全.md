---
title: "(2)c++线程安全的对象声明周期管理"
subtitle: "muduo阅读笔记"
layout: post
author: "Marco"
header-style: text
hidden: true
tags:
  - 计算机网络

---

## c++析构竞态

### 1. 基本概念

> [参考自](https://blog.csdn.net/Solstice/article/details/5238671)

- ***什么是析构竞态？***

  ​	与其他面向对象语言不同，C++ 要求程序员自己管理对象的生命期，这在多线程环境下显得尤为困难。当一个对象能被多个线程同时看到，那么对象的销毁时机就会变得模糊不清，可能出现多种竞态条件：

  - 在即将析构一个对象时，从何而知是否有另外的线程正在执行该对象的成员函数？
  - 如何保证在执行成员函数期间，对象不会在另一个线程被析构？
  - 在调用某个对象的成员函数之前，如何得知这个对象还活着？它的析构函数会不会刚执行到一半？

  ​	解决这些 race condition 是 C++ 多线程编程面临的基本问题。本文试图以 shared_ptr 一劳永逸地解决这些问题，减轻 C++ 多线程编程的精神负担。

- ***什么是线程安全？***

  ​	依据《Java 并发编程实践》/《Java Concurrency in Practice》一书，一个线程安全的 class 应当满足三个条件：

  - 从多个线程访问时，其表现出正确的行为
  - 无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织
  - 调用端代码无需额外的同步或其他协调动作

  ​	依据这个定义，C++ 标准库里的大多数类都不是线程安全的，无论 std::string 还是 std::vector 或 std::map，因为这些类通常需要在外部加锁。



### 2. 实战篇

- ***如何从构造函数，实现线程安全？***

  对象构造要做到线程安全，惟一的要求是在构造期间不要泄露 this 指针，即

  - 不要在构造函数中注册任何回调
  - 也不要在构造函数中把 this 传给跨线程的对象
  - 即便在构造函数的最后一行也不行

  之所以这样规定，是因为在构造函数执行期间对象还没有完成初始化，如果 this 被泄露 (escape) 给了其他对象（其自身创建的子对象除外），那么别的线程有可能访问这个半成品对象，这会造成难以预料的后果。

- ***为什么线程安全的，析构函数这么麻烦？***

  ​	因为一般线程安全方法都是依赖于互斥锁的，而析构函数会在析构的过程中把锁给销毁。

- ***怎么才能够实现析构安全？***

  - 对象池
    - 很简单，对象只创建不释放，这样就可以避免锁被析构了。这种简单的做法，会带来很多缺点
    - **缺点**
      - 问题从如何安全地析构转换为，如果安全地将对象放回池子了。可能出现线程A以为对象已经放回，线程B以为对象还或者

  - 智能指针
    - 用智能指针的方法，线程甲操作的是指向对象x的智能指针A，线程甲操作的是指向对象x的智能指针B，这时候x的引用计数为2，因为被两次引用。智能指针A执行析构的时候，只是A不用了，但对象x不会被析构，只有当引用次数为0的时候，对象x才会真正被析构。

  

  