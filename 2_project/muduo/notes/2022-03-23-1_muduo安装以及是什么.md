---
title: "(1)muduo安装以及是什么"
subtitle: "muduo阅读笔记"
layout: post
author: "Marco"
header-style: text
hidden: true
tags:
  - 计算机网络
---

 ## muduo配置

### 1. 基本概念

- ***什么是muduo***

  ​	muduo是一个网络库，而muduo被认为是多线程网络服务器的正规做法。

- ***为什么选择muduo阅读？***

  ​	相比较业界在用的`libevent`而言，muduo的阅读难度会相对小一些。这是因为muduo本身是一个带有教学性质的库，有更多的中文讲解资料，而且配套了一些example示例。

  ​	除此之外，从代码角度出发，libevent是跨平台的，而muduo是linux平台下的。单一平台的代码更容易阅读。

- ***如何安装***

  ​	`sudo apt install g++ cmake libboost-dev libboost-test-dev`

  ​	`sudo apt-get install protobuf-compiler`

  ​	muduo主要是有两个大的第三方库，`protobuf`和`boost`。安装完这两个依赖之后，跟着去make就好了。
  
  

### 2. 进阶概念

- ***TCP网络如何学***

  > [引用](原文链接：https://blog.csdn.net/Solstice/article/details/6171831)

  - 我认为，TCP 网络编程最本质的是处理三个半事件：

    - 连接的建立，包括服务端接受 (accept) 新连接和客户端成功发起 (connect) 连接。

    - 连接的断开，包括主动断开 (close 或 shutdown) 和被动断开 (read 返回 0)。
    - 消息到达，文件描述符可读。这是最为重要的一个事件，对它的处理方式决定了网络编程的风格（阻塞还是非阻塞，如何处理分包，应用层的缓冲如何设计等等）。
    - 消息发送完毕，这算半个。对于低流量的服务，可以不必关心这个事件；另外，这里“发送完毕”是指将数据写入操作系统的缓冲区，将由 TCP 协议栈负责数据的发送与重传，不代表对方已经收到数据。

  - 这其中有很多难点，也有很多细节需要注意，比方说：

    - 如果要主动关闭连接，如何保证对方已经收到全部数据？如果应用层有缓冲（这在非阻塞网络编程中是必须的，见下文），那么如何保证先发送完缓冲区中的数据，然后再断开连接。直接调用 close(2) 恐怕是不行的。
    - 如果主动发起连接，但是对方主动拒绝，如何定期 (带 back-off) 重试？
      非阻塞网络编程该用边沿触发(edge trigger)还是电平触发(level trigger)？（这两个中文术语有其他译法，我选择了一个电子工程师熟悉的说法。）如果是电平触发，那么什么时候关注 EPOLLOUT 事件？会不会造成 busy-loop？如果是边沿触发，如何防止漏读造成的饥饿？epoll 一定比 poll 快吗？
    - 在非阻塞网络编程中，为什么要使用应用层缓冲区？假如一次读到的数据不够一个完整的数据包，那么这些已经读到的数据是不是应该先暂存在某个地方，等剩余的数据收到之后再一并处理？见 lighttpd 关于 /r/n/r/n 分包的 bug。假如数据是一个字节一个字节地到达，间隔 10ms，每个字节触发一次文件描述符可读 (readable) 事件，程序是否还能正常工作？lighttpd 在这个问题上出过安全漏洞。
    - 在非阻塞网络编程中，如何设计并使用缓冲区？一方面我们希望减少系统调用，一次读的数据越多越划算，那么似乎应该准备一个大的缓冲区。另一方面，我们系统减少内存占用。如果有 10k 个连接，每个连接一建立就分配 64k 的读缓冲的话，将占用 640M 内存，而大多数时候这些缓冲区的使用率很低。muduo 用 readv 结合栈上空间巧妙地解决了这个问题。
    - 如果使用发送缓冲区，万一接收方处理缓慢，数据会不会一直堆积在发送方，造成内存暴涨？如何做应用层的流量控制？
    - 如何设计并实现定时器？并使之与网络 IO 共用一个线程，以避免锁。
      这些问题在 muduo 的代码中可以找到答案。

  