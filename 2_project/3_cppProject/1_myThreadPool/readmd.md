## 线程池

### 1. concepts
#### 1.1 线程池的意义是什么？
线程池是一种用于管理和复用线程的设计模式，最主要意义就在于复用线程。因为线程的创建和销毁的开销不容忽视。
所以当任务完成后，不希望销毁线程，而是希望放着下次使用；同样地，但新建任务的时候，也不需要创建线程，复用已有线程即可。
除此之外，也简化了多线程编程的复杂性。
而复用线程还可以带来提升性能，方便资源管理等等其他意义。
但本质来说就是为了复用线程。

#### 1.2 线程池的如何实现？
因此实现线程池最主要的就是保证线程复用。为了保证线程复用，有以下几点需要做到。

1. 线程管理：
    * 线程池在实例化的时候就会创建足够大的线程。
    * 线程池要负责管理、创建和销毁线程。
    * 确保线程能够正常结束。
2. 任务管理：
    * 有一个线程安全的队列存储任务。
    * 任务会被分配到空闲线程中去运行。
    * 当没有任务的时候，不要忙占用。
3. 错误管理：
    * 处理任务的异常状态。
4. 扩展性：
    * 线程池是否需要动态调整大小。

具体实现的原理层面：
创建线程池的时候就直接创建了固定的线程，让这些线程去消费任务队列，如果任务队列为空，就等待；如果不为空就运行任务队列的任务。
简单来说使用了线程池之后，任务不是直接绑定到线程上；而是任务放到任务队列。线程池的所有线程都是活跃状态，都会一直去消费任务队列。

### 2. quiz

#### 1. 如果添加的任务是竞争的，怎么办？
如果任务是竞争的，由任务自身维护。
线程池只是负责对任务的的调度管理而已。

#### 2. 线程池可以无限添加任务吗？
一般情况下，线程的任务队列是有大小限制的。
这体现在线程池的资源管理方面。
如果无限多的队列，会导致队列尾的任务完成时间不可预测。
因此，一般当超出最大限制长度的时候，可以拒绝任务。
为了异常安全性，也可以返回一个future值，只是这个future值不是通过线程池去管理的。

#### 3. 如何设置有优先级别的线程池？
任务队列不要用queue，改成大根堆即可。
std有一个std::priority_queue。

#### 4. 如何处理不同返回值，不同入参的任务？
一句话，模板。
```c++
template <typename Func, typename... Args>
auto ThreadPool::submitTask(Func &&func, Args &&...args)
    -> std::future<decltype(func(args...))> {
    using ReturnType = decltype(func(args...));
    /////
}
```
