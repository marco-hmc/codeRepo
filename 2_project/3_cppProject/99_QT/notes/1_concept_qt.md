## QT
### 1. concepts

#### 1.1 什么是moc
  元对象编译器(Meta-Object Compiler,简称moc)是Qt框架的一个重要组成部分,它用于处理QObject类及其子类中的一些特殊代码.moc的主要任务是读取包含Q_OBJECT宏的类的头文件,并生成包含元对象系统所需的额外C++代码的源文件.

  moc的主要功能包括:

  生成元信息:moc会生成一个元对象(Meta-Object),其中包含了类的元信息,如类名/父类/信号和槽/属性等.这些信息可以在运行时通过元对象系统进行访问.

  实现信号和槽机制:moc会生成用于实现信号和槽机制的代码.这包括信号的发射代码,以及用于在运行时查找和调用槽的代码.

  实现动态属性:moc会生成用于实现动态属性的代码.动态属性是在运行时添加到对象的属性,它们不需要在类声明中预先定义.

  判断一个类是否需要使用元对象编译器,主要看这个类是否需要使用到元对象系统提供的功能.如果一个类需要使用信号和槽机制,或者需要定义动态属性,或者需要在运行时访问类的元信息,那么这个类就需要使用元对象编译器.具体来说,如果一个类满足以下条件之一,那么这个类就需要使用元对象编译器:

  类中定义了信号(signals).
  类中定义了槽(slots).
  类中使用了Q_PROPERTY宏定义了属性.
  类需要使用Q_INVOKABLE宏将方法暴露给元对象系统,以便在运行时通过元对象系统调用这些方法.
  在这些情况下,你需要在类声明中添加Q_OBJECT宏,并确保在编译项目时运行元对象编译器.

#### 1.2 Q_PROPERTY有什么用
  使用 Q_PROPERTY 宏和直接在 public 部分定义变量有几个主要的区别:

  元对象系统:Q_PROPERTY 定义的属性可以通过 Qt 的元对象系统进行访问.这意味着你可以在运行时动态地获取和设置属性的值,或者查询属性的类型等信息.而直接公开的变量则无法通过元对象系统访问.

  工具支持:Q_PROPERTY 定义的属性可以被 Qt Designer 和其他工具识别和编辑.例如,你可以在 Qt Designer 中直接编辑 QWidget 对象的属性,或者使用 QML 绑定到 QObject 的属性.而直接公开的变量则无法享受这些工具的支持.

* Q_OBJECT有什么用?
  只有需要使用到Qt元对象系统(Meta-Object System)的类才需要在类声明中添加Q_OBJECT宏.

* 什么是Q_SIGNALS?
  在Qt中,Q_SIGNALS和connect()是用于实现信号和槽机制的关键部分.

  1. Q_SIGNALS:这是一个宏,用于在类声明中定义信号.信号是QObject类的一种特殊成员函数,它在某些事件发生时被发射(emit).信号没有实现,只有声明.例如,你可以这样定义一个信号:
  ```cpp
      class MyClass : public QObject
    {
        Q_OBJECT

    public:
        // 定义一个名为valueChanged的信号,它有一个int类型的参数
        Q_SIGNALS:
        void valueChanged(int newValue);
    };
  ```
  2. **connect()**:这是一个函数,用于将信号和槽连接起来.当信号被发射时,与之连接的槽会被自动调用.connect()函数的基本用法如下:
  ```cpp
      // 假设sender是发射信号的对象,receiver是接收信号的对象
    QObject::connect(sender, SIGNAL(valueChanged(int)), receiver, SLOT(updateValue(int)));
  ```
  
  在这个例子中,当sender对象发射valueChanged信号时,receiver对象的updateValue槽会被自动调用,信号的参数会被传递给槽.

  总的来说,Q_SIGNALS和connect()是Qt中实现对象间通信的重要机制.通过信号和槽,你可以在不增加对象间耦合度的情况下,实现对象间的信息传递.

#### 1.3 什么是.ui文件?
  ui文件是Qt框架中使用的一种文件格式,用于描述用户界面的布局和元素.它是使用Qt设计师(Qt Designer)工具创建的,可以包含各种UI元素,如按钮/文本框/标签等..ui文件使用XML格式编写,其中包含了界面的层次结构/布局和属性信息.

  .ui文件通常会被Qt的用户界面编译器(uic)解析并生成对应的C++头文件(通常命名为ui_xxx.h).这个生成的头文件包含了一个Ui类,这个类中定义了所有在.ui文件中描述的界面元素,并提供了一个setupUi()函数,这个函数会创建并初始化这些界面元素.

  这个过程通常在构建系统(如qmake或CMake)中自动完成,你不需要手动运行uic.当你修改了.ui文件并重新构建项目时,对应的ui_xxx.h文件会自动更新.

  一旦.ui文件被加载和解析,开发人员可以通过编程方式访问和操作界面元素,例如修改文本内容/设置按钮的点击事件等.这使得界面的开发和维护变得更加方便和灵活.

  这种方式的好处是,你可以使用Qt Designer等可视化工具来创建和编辑.ui文件,而无需手动编写界面代码.同时,由于界面代码是自动生成的,所以你可以随时更新.ui文件,而不需要手动同步界面代码.

#### 1.4 什么是样式？
  在Qt中,样式(Style)是用来定义应用程序用户界面的外观和感觉的.Qt提供了一套强大的样式系统,你可以使用它来定制几乎所有的Qt控件的外观.

  样式表:Qt的样式表提供了一种类似于CSS的语法,你可以使用它来定制Qt控件的外观.例如,你可以使用样式表来设置控件的背景颜色/字体/边框等属性.样式表可以应用于单个控件,也可以应用于整个应用程序.

  ```cpp
    // 设置一个按钮的背景颜色和字体颜色
  button->setStyleSheet("QPushButton { background-color: red; color: white; }");
  ```

#### 1.5 什么是event()和eventFilter()
  **event()**:这是一个成员函数,通常在一个QWidget或者其子类中被重写,用于处理该对象接收到的所有事件.当一个事件被发送到一个对象时,这个对象的event()函数会被调用.在这个函数中,你可以根据事件的类型进行不同的处理.例如,你可以处理鼠标点击事件/键盘按键事件等.

  ```cpp
      bool MyWidget::event(QEvent *event)
    {
        if (event->type() == QEvent::MouseButtonPress) {
            // 处理鼠标点击事件
        } else {
            // 对于其他类型的事件,调用基类的event()函数进行默认处理
            return QWidget::event(event);
        }
    }
  ```
  **eventFilter()**:这也是一个成员函数,通常在一个QObject或者其子类中被重写,用于过滤其他对象的事件.你可以安装一个事件过滤器到一个对象,然后当这个对象接收到事件时,事件过滤器的eventFilter()函数会被调用.在这个函数中,你可以决定是否要拦截这个事件,或者对这个事件进行特殊处理.

  ```cpp
      bool MyFilter::eventFilter(QObject *obj, QEvent *event)
    {
        if (obj == targetObject && event->type() == QEvent::KeyPress) {
            // 对目标对象的键盘按键事件进行特殊处理
        } else {
            // 对于其他对象或其他类型的事件,调用基类的eventFilter()函数进行默认处理
            return QObject::eventFilter(obj, event);
        }
    }
  ```
  event()和eventFilter()的主要区别在于,event()是用于处理对象自身的事件,而eventFilter()是用于处理其他对象的事件.

#### 1.6 summary
* 信号槽和event()的对比
  信号槽(Signal-Slot)机制和event()函数都是Qt中用于处理事件和实现对象间通信的机制,但它们的使用场景和方式有所不同.

  信号槽(Signal-Slot):这是Qt特有的一种事件处理机制,主要用于实现对象间的通信.当某个事件发生时(例如,按钮被点击),一个信号会被发射.这个信号可以连接到一个或多个槽函数,当信号被发射时,所有连接的槽函数都会被调用.信号槽机制是异步的,是一种松耦合的通信方式,使得事件的发送者和接收者不需要知道对方的存在.

  event()函数:这是Qt中用于处理各种事件(如鼠标点击/键盘按键等)的函数.当一个事件被发送到一个对象时,这个对象的event()函数会被调用.你可以通过重写这个函数来实现自定义的事件处理逻辑.event()函数是同步的,它会直接处理事件,并且可以决定是否要继续传递这个事件.


