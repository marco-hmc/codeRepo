## RTTI
RTTI（Runtime Type Identification，运行时类型识别）是C++语言中的一项机制，允许程序在运行时动态地确定对象的类型。这项机制对于实现诸如类型安全的向下转型（downcasting）、实现基于类型的行为以及调试等场景非常有用。
RTTI的能力主要通过两个关键特性实现：``typeid``操作符和``dynamic_cast``操作符。

* **c++和rtti**
	c++比较特殊，类型是编译时才需要的信息，运行的时候如果要利用类型信息做多态行为，一般也是通过虚指针。虚指针也是编译期确定的，运行期间也没有存储类型信息了。
	简单来说，类型信息对于一个已经打包成二进制文件的c++程序不是必须的，这个二进制文件可以不包含任何类型信息（理论上也可以通过虚指针解引用得到的虚函数表地址进行比较，来判断是不是同一个类型），即没办法判断任意两个类型是否存在继承关系。
	如果需要判断两个类型是不是存在继承关系的时候，就需要开启rtti，简单来说就是开一个编译器选项，允许编译器为类型创建类型信息，这个类型信息一般还会包含相关继承体系信息，简单来说就是有家谱。

* **反射**
	反射 对于其他语言来说，类型信息更加完善，反射机制允许程序在运行时检查和使用类型信息。反射通常用于框架和库中，以实现更高的灵活性和动态行为。例如，Java 和 C# 都支持反射，可以在运行时获取类的属性、方法和构造函数等信息，并进行调用。

* **类型信息不能滥用**
	在多态场景中，父类不应该认识子类，在父类通过 dynamic_cast 判断是哪个类型，然后执行操作的做法是错误的。这种场景应该使用虚函数。虚函数允许子类重写父类的方法，从而实现多态行为，而不需要在运行时判断类型。

### 1. 编译器提供的rtti能力
#### 1.1 typeid操作符
typeid是一个C++关键字，用于在编译时或运行时获取表达式或类型的名字。当应用于一个对象时，它会返回一个包含该对象实际类型信息的std::type_info对象的引用。std::type_info对象包含了类型的名字（通常为人类可读的字符串形式）以及其他可能的类型相关信息，可以用来比较类型是否相同。

使用typeid的一个典型场景是确定对象的动态类型，尤其是在多态环境中。例如，当你有一个指向基类的指针，但实际上它指向的是一个派生类对象，typeid可以帮助你识别出这一点。

#### 1.2 dynamic_cast操作符
dynamic_cast是另一个C++提供的运行时类型转换操作符，它允许安全地将基类的指针或引用转换为派生类的指针或引用。与C风格的强制类型转换（如reinterpret_cast或旧式的C样式cast）不同，dynamic_cast会在转换前检查转换的安全性。如果转换是合法的（即对象实际上是目标派生类的实例），则转换成功；否则，dynamic_cast会返回一个空指针（对于指针类型）或抛出一个std::bad_cast异常（对于引用类型，仅在使用RTTI时）。

dynamic_cast依赖于对象的类型信息，因此只有当转换的源类型含有至少一个虚函数（从而具有虚函数表）时，dynamic_cast才能工作。这是因为虚函数的存在表明了类型系统中存在多态性，而这是dynamic_cast实现其功能的基础。

#### 1.3 RTTI的启用与禁用
RTTI默认在大多数编译器中是启用的，但也可以通过编译器选项禁用，以减少代码体积或提高性能，尤其是在不需要类型识别的环境下。禁用RTTI意味着typeid和dynamic_cast将无法正常工作。

### 2. 自定义rtti

一些大型库和工程选择自己实现 RTTI 能力，而不是使用编译器提供的 RTTI，主要原因包括以下几点：

- **编译器提供的 RTTI**：
  - 优点：使用方便，标准化，适用于大多数常见的类型检查和转换需求。
  - 缺点：可能引入额外的性能开销和代码体积，灵活性较低。

- **自定义 RTTI**：
  - 优点：性能优化、灵活性高、可移植性强，适用于需要精细控制类型信息和高性能的场景。
  - 缺点：实现复杂度高，维护成本较大。

最主要的原因就是性能能够优化，而且灵活，可以添加很多功能。一些知名的库和框架选择自己实现 RTTI 能力，包括：

1. **Qt**：
   Qt 是一个广泛使用的 C++ 框架，用于开发跨平台应用程序。Qt 使用自己的元对象系统（Meta-Object System）来实现 RTTI 能力，包括信号和槽机制、属性系统等。
2. **LLVM**：
   LLVM 是一个用于构建编译器的基础设施项目。LLVM 使用自定义的 RTTI 系统来实现类型信息的管理和检查，以确保高效和灵活的类型处理。
3. **Boost**：
   Boost 是一个广泛使用的 C++ 库集合，其中的一些库（如 Boost.Any 和 Boost.Variant）实现了自定义的 RTTI 能力，以提供更强的类型安全性和灵活性。
4. **Unreal Engine**：
   Unreal Engine 是一个流行的游戏引擎，使用自定义的 RTTI 系统来管理游戏对象的类型信息和反射能力，以提高性能和灵活性。

其中，个人对自定义rtti性能优于编译器rtti产生了怀疑。自己写一个看看。