---
title: "编译过程与原理"
layout: post
author: "Marco"
header-style: text
hidden: true
tags:
  - 编译原理
---

## 编译过程与原理

### 1. 编译过程 - 编译器在做什么？

如果想要机器按照我们的设想执行我们的命令，我们需要一个能够跟机器沟通的方式，而这种方式也就是==机器语言(第一代计算机语言)==，一堆`01`构成的指令。我们需要事先设计好指令集到机器上，比如说规定好从某寄存器阅读值的指令为什么。

可这种方式面临的第一个问题就是，不同机器之间指令集不一致，比如说DSP和ARM在实现加法上，可能就会出现不同寄存器的调用方法。那很显然就会设想出一种统一的语言，即==汇编语言(第二代计算机语言)==。而汇编实现的只是将`01`等机器码指令使用一个统一的命名，如`ADD`而已。令所有机器指令集可与汇编语言转换即可。

汇编语言仍存在很多问题，主要表现为阅读性极差、开发难度大、开发周期长、移植问题没有彻底解决。因此也就出现了==高级语言(第三代语言)==，在汇编语言的基础上实现了抽象，避免了繁琐寄存器的操作。

那源代码(高级语言)是如何让计算机理解的呢？其步骤是？

* 如果源代码在操作系统上：源代码生成汇编代码，再通过汇编和链接方式形成可执行文件，然后通过加载器加载到操作系统执行。
* 如果源代码在虚拟机(解释器)上：源代码生成中间代码(人可以直接理解的，而汇编则认为人无法理解)，如字节码等。

在Linux系统下，可用以下指令完成源程序到目标程序的转化：

> gcc -o hello hello.c main.c

gcc 编译器驱动程序读取源文件hello.c和main.c，经过预处理、编译、汇编、链接（分别使用预处理器、编译器、汇编器、链接器，这四个程序构成了编译系统）四个步骤，将其翻译成可执行目标程序hello。如下图所示： 

![image-20200228004704609](https://s2.loli.net/2022/01/26/VGdicgwP6QvRBT8.png)



#### 1.1 预处理

预处理器(CPP)根据源程序中以字符”#”开头的命令，修改源程序，得到另一个源程序，常以.i作为文件扩展名。修改主要包括#include、#define和条件编译三个方面。

> gcc -o main.i -E main.c

预处理只是对源文件进行了扩展，得到的仍然是C语言源程序。

#### 1.2 编译

编译程序所要作得工作就是通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。

编译器(CCL)将经过预处理器处理得到的文本文件hello.i和main.i翻译成hello.s与main.s，其中包含了汇编语言程序，汇编语言程序以一种标准的文本格式确切描述一条低级机器语言指令。 
 运行以下命令进行编译：

> gcc -S main.i hello.i

#### 1.3 汇编

汇编器(AS)将hello.s和main.s翻译成机器语言指令，并打包成可重定位目标程序，一般以.o为文件扩展名。可重定位目标程序是二进制文件，它的字节编码是机器语言指令而不是字符。 
 运行以下指令可得到重定位目标程序main.o和hello.o：

> gcc -c main.s hello.s

用文本编辑器打开main.o和hello.o发现文件是乱码，因为此时已经是二进制文件。

#### 1.4 链接

链接程序(LD）将main.o和hello.o以及一些其他必要的目标文件组合起来，创建可执行目标文件。

> gcc -o hello main.o hello.o

得到可执行程序hello. 
 在终端运行./hello，程序加载并运行.

根据开发人员指定的同库函数的链接方式的不同，链接处理可分为两种： 

* 静态链接 
  在这种链接方式下，函数的代码将从其所在的静态链接库中被拷贝到最终的可执行程序中。这样该程序在被执行时这些代码将被装入到该进程的虚拟地址空间中。静态链接库实际上是一个目标文件的集合，其中的每个文件含有库中的一个或者一组相关函数的代码。 
* 动态链接 
  在此种方式下，函数的代码被放到称作是动态链接库或共享对象的某个目标文件中。链接程序此时所作的只是在最终的可执行程序中记录下共享对象的名字以及其它少量的登记信息。在此可执行文件被执行时，动态链接库的全部内容将被映射到运行时相应进程的虚地址空间。动态链接程序将根据可执行程序中记录的信息找到相应的函数代码。 
   对于可执行文件中的函数调用，可分别采用动态链接或静态链接的方法。使用动态链接能够使最终的可执行文件比较短小，并且当共享对象被多个进程使用时能节约一些内存，因为在内存中只需要保存一份此共享对象的代码。但并不是使用动态链接就一定比使用静态链接要优越。在某些情况下动态链接可能带来一些性能上损害。

[动态链接](https://kshttps0.wiz.cn/ks/note/view/2336be1c-7b66-490d-91e0-240081977c3d/e730f0ac-0a19-4994-8f7f-1355d3c86eec/#动态链接)
[动态库的编译](https://kshttps0.wiz.cn/ks/note/view/2336be1c-7b66-490d-91e0-240081977c3d/e730f0ac-0a19-4994-8f7f-1355d3c86eec/#动态库的编译)



### 2. 编译原理 - 编译器是如何实现的？

[编译原理入门篇|一篇文章理解编译全过程](https://www.cnblogs.com/fisherss/p/13905395.html)



![image-20220126215910369](https://s2.loli.net/2022/01/26/xVbeED8TKaYIG2w.png)

### 3. 实战篇

#### 3.1 gcc的基本用法

[gcc编译器30分钟入门篇](http://c.biancheng.net/gcc/)

​	从上面看下来，应该大概知道了编译的大概过程以及为什么了。而gcc就是代表的C语言的编译器。除了gcc之外还有很多，但是GCC是免费且开源的，因此更广为使用。最开始的时候是 GNU C Compiler, 就是一个c编译器。但是后来因为这个项目里边集成了更多其他不同语言的编译器，GCC就代表 the GNU Compiler Collection，所以表示一堆编译器的合集。 g++则是GCC的c++编译器。

​	现在你在编译代码时调用的gcc，已经不是当初那个c语言编译器了，更确切的说他是一个驱动程序，根据代码的后缀名来判断调用c编译器还是c++编译器 (g++)。比如你的代码后缀是*.c，他会调用c编译器还有linker去链接c的library。如果你的代码后缀是cpp, 他会调用g++编译器，当然library call也是c++版本的。

​	但一般来说,gcc指c语言编译器，g++值c++语言编译器.

#### 3.2 make

[makefile-example](https://github.com/remonbonbon/makefile-example)

​	在运行代码前，需要使用make完成构建(build)的工作，即告诉代码要包含那些库目录，要引入哪些头文件。gcc当然也是提供简单的链接指令的，但是当工程够大的时候，就必须有一个工具来完成。这个工具就叫做make。可以理解为make就是通过makefile这一种脚本文件的形式去运行gcc。



#### 3.3 cmake

[CMakeLists.txt 语法介绍与实例演练](https://blog.csdn.net/afei__/article/details/81201039)

[CMake 语法 - 详解 CMakeLists.txt](https://juejin.im/post/5ceb7fb0f265da1b5e72d12f)

[cmake-example](https://github.com/ttroy50/cmake-examples)

​	但是make语法仍然繁琐了，makefile往往写得又臭又长，这时候就出来了cmake。cmake可以理解为是make语法的抽象。通过写cmakelists的方式生成makefile达到我们想要的目的。

### 4. Conclusion

本文分为三部分，编译过程，编译原理和实战，其中前者是我们在生产环境中实际接触到的部分，后者更像是如何制作编译器。后者非笔者所熟悉的，因此附上我认为比较好的资料。最后一部分实战篇，鉴于已经有很多好的资料，我就一并附上了。本文初衷仅在于梳理。



### 5.附录

#### 1. cpp编译器有那些

- GCC
  - 移植到windows版本对应的就是MinGW和TDM-GCC

- llvm+clang

- MSVC
  - 与Visual Studio集成发布，微软自己的编译器

#### 2. GCC和G++的区别

* GCC:GNU Compiler Collection(GUN 编译器集合)，它可以编译C、C++、JAV、Fortran、Pascal、Object-C等语言。
* gcc是GCC中的GUN C Compiler（C 编译器）
* g++是GCC中的GUN C++ Compiler（C++编译器）

由于编译器是可以更换的，所以gcc不仅仅可以编译C文件

所以，更准确的说法是：gcc调用了C compiler，而g++调用了C++ compiler

**gcc和g++的主要区别**

1. 对于 *.c和*.cpp文件，gcc分别当做c和cpp文件编译（c和cpp的语法强度是不一样的）

2. 对于 *.c和*.cpp文件，g++则统一当做cpp文件编译

3. 使用g++编译文件时，**g++会自动链接标准库STL，而gcc不会自动链接STL**

4. gcc在编译C文件时，可使用的预定义宏是比较少的

5. gcc在编译cpp文件时/g++在编译c文件和cpp文件时（这时候gcc和g++调用的都是cpp文件的编译器），会加入一些额外的宏。
6. 在用gcc编译c++文件时，为了能够使用STL，需要加参数 –lstdc++ ，但这并不代表 gcc –lstdc++ 和 g++等价，它们的区别不仅仅是这个。

#### 3. 静态库和动态库的用法

##### 3.1 定义

​	静态库和动态库从字面意思来看，区别就是静态和动态。**而这里的静态和动态指的是库的链接阶段**。可以看如下的编译过程。

* 静态库：在链接阶段库将会与目标汇编后的目标文件.o一起打包生成可执行文件。成为可执行文件的一部分，后续此库就可以消失了。**也就是说在编译的最后一步（链接阶段），如果程序需要使用静态库，在这一步都会一起打包到可执行文件中。**
* 动态库：而动态库在编译阶段都不会有什么动作，**只有在程序运行时才被加载，也就是动态库的链接是发生在程序运行时期的，它和可执行文件是分开的，只是可执行文件在运行的某个时期调用了它。**

##### 3.2  优缺点

|        | 优点                                                         | 缺点                                                         |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 静态库 | 1、  使可执行文件依赖项少，已经被打包到可执行文件中了<br/>2、  编译阶段完成链接，执行期间代码装载速度快 | 1、  使可执行文件变大<br/>2、  若作为其他库的依赖库，将会造成多余的副本，因为必须与目标文件打包<br/>3、  升级不方便，升级必须重新编译 |
| 动态库 | 1、  动态库可以实现进程之间资源共享，有一份就行<br/> 2、  升级程序简单，不需要重新编译 | 1、  运行期间在加载，将会减慢代码执行速度 <br/>2、  增加程序的依赖项，必须跟着可执行文件一起 |

##### 3.3 文件形式

|        | windows    | linux     |
| ------ | ---------- | --------- |
| 静态库 | .lib       | Libxxx.a  |
| 动态库 | .dll与.lib | libxxx.so |

## 参考

[手把手教你构建C语言编译器](https://lotabout.me/2015/write-a-C-interpreter-0/)

[DLL文件与so文件的区别](https://blog.csdn.net/wuchuanpingstone/article/details/50259947)