
### 2 What is a unit test?

    这里共享指的是会影响其他测试的结果
    运行测试的时候总会在内存中新建被测系统（SUT），所以共享依赖都是进程外的
    但是进程外的系统不一定是共享依赖，只要其返回结果总是不变的，就不会影响到测试结果
    比如数据库是一个共享依赖，配置文件

    是一个私有且不变的依赖，内存缓存是一个私有且可变的依赖
    一个共享或者可变的依赖称为一个交互方

伦敦派声称的优点包括了：

    提供更细的测试粒度，每次只专注一个类
    对于一组相关关联的复杂的类，因为所有交互方都mock了
    因为测试的粒度很小，在测试失败的时候也很容易定位原因

然而问题在于：
    对于单元的理解就不合理，关注单个功能才是合理的。
    一个测试用例应当是对一个系统功能的内聚

    （cohesive）且有意义的描述
    以类的角度强行拆分，会导致测试用例支离破碎难以理解
    如果因为类之间的关联关系复杂导致难以测试，这是设计的问题，mock只是隐藏了问题，并没有解决问题
    对于单测来说，定位原因总是相对简单的事情，因此这里的差距很小

    其实直观感受上，伦敦派对于单元测试的定义可能是现在接受度更广泛的。但是整体上我非常认同本书作者的观点，尤其同意每一个测试用例都应当表达业务意义，也就是用户故事

    。实质上这也是BDD或者活文档的核心观点，因为测试用例本身是可以运行保证正确的，再加上合理的语义信息，就是对于领域模型的精确的表达。

两个流派在TDD和over-specification的问题上也有区别
    伦敦派采用从上之下（outside-in）的TDD方式，通过mock掉交互方，可以先写高层的测试来为整体功能设定目标，再逐步细化具体实现
    经典派往往采用自下而上（inside-out）的TDD流程，优先建立核心的领域模型，再逐步添加周边功能

两个流派最为重大的区别在于过度规范（over-specification）的问题，即测试用例与系统实现细节的耦合。伦敦派更容易产生这种耦合，这也是本书对于伦敦派和滥用mock最为反对的地方。

伦敦派认为所有包含真实交互方的测试都集成测试，本书更多采用经典派的观点，因此不符合经典派单元测试标准的才认为是集成测试。端到端（end-to-end）测试是集成测试的一种，从最终用户的角度来验证系统行为。

    个人认为单元测试和集成测试的边界是模糊的，实际中也不一定要特别明确的区分，因为两者的最终目标和衡量标准其实都是类似的。


## Part 2 Making your tests work for you

### 4 The four pillars of a good unit test

完美的测试

如果给上面每个属性一个分数，那么四个数值相乘就可以认为是测试的价值。相乘意味着，在任何一个属性上得到零分，就代表了测试的价值归零。当然实际中无法给出精确的分值，但我们可以进行相对精确的估算。

然而完美的测试是不存在的，召回率、精确率、快速反馈是互斥的，不可能同时得到最高分，只能通过权衡来使得整体得分最高。比如端对端测试在召回率和精确率上能够得到高分，但是却难以做到快速反馈；无关紧要的测试（trivial test）只能保证精确率和快速反馈；脆弱的测试（brittle tests）或许能做到召回率和快速反馈，但是在精确率上表现很差。

实际中，精确率不应当被妥协，因为其取值往往只有0和1，所以需要在召回率和快速反馈中进行取舍。

    作者还拿CAP的例子做了对比，支出分区容忍性也是无法选择的，所以只能在一致性和可用性之间取舍。我很同意精确率的重要性，不过我觉得这里有点过于绝对，精确的程度还是有相当大的变动空间。

测试金字塔

测试金字塔

提倡了不同测试类型的使用比例，从单元测试到集成测试再到端对端测试，逐步减少占比。这三类测试，依据前面的分析，在保证精确率的前提下，就是其侧重点就是从快速反馈到召回率的变化。

一般情况下，维持测试金字塔的比例是合理的，因为端对端测试需要最高的维护成本。但是也有些例外，比如对于CRUD类的简单场景，单元测试带来的收益不大，如果集成测试和端对端测试的成本不高，可以更多的使用。

    在我们的实际场景中，大量使用了Spring框架，因为代码的设计问题使得要做纯粹的单元测试反而成本较高，而集成测试可以通过一些方案使得开发成本更低，因此在运行速度可以接受的情况下，我自己更加推荐适当粒度的集成测试。

黑盒测试
是指在不了解系统内部结构的情况下测试系统功能，白盒测试则恰好相反。显然白盒测试

更容易导致与具体实现的紧密耦合，因此更加推荐使用黑盒测试。
### 5 Mocks and test fragility

    本章讨论测试替身的使用，也涉及了对于系统架构的讨论

测试替身(test double)指代了所有测试中用到的非生产环境的依赖，包括 dummy, stub, spy, mock, fake，本质上可以分为两种类型。



Mock是为了模拟和检查 由内向外（outcoming）的交互，即SUT用于改变外部依赖的调用。Stub是为了模拟由外向内（incoming）的交互，即SUT用于获取信息的调用，细分dummy/stub/fake

只是在智能程度上的差别而已。对于stub不应该验证其交互，因为这些只是中间过程，属于实现细节。

    感觉这个分类非常有道理！注意这些概念不要和Mock框架的方法混淆，比如Mockito中的mock对象

    和spy对象，如果我们只是为方法设置了返回值，而不去验证其调用的话，就只是一个Stub，只有验证了调用才算是Mock。

代码可以从两个维度来分类：公共API

vs 私有API，可观测行为 vs 实现细节。

    公共/私有是通过代码访问权限控制的
    可观测行为指对外暴露的提供用户功能的操作或者状态，其它的则是实现细节
    理想情况下，系统的公共API就应当是其可观测行为，而实现细节都不应当对外暴露
    需要通过封装来实现更好的设计，保护代码的不变性（invariant）；对外暴露实现细节很容易导致不变性被违反（invariant violations）
    良好的API设计自然会提高测试的质量



六边形架构关注三个重要的方面：

    领域层和应用服务层的关注点分离

    。领域层为业务逻辑负责，应用服务层编排流程
    只有应用服务层到领域层的单向依赖
    外部应用通过应用服务层来连接系统，不能直接访问领域层

跨系统的通信是可观测行为，而系统内部的通信都是实现细节。进程外的依赖，如果使用方只有SUT自己，那么也不应该归类到可观测行为，而应该属于实现细节，比如数据库。Mock应该只关注系统的可观测行为，而不应该用于验证实现细节，否则会使得测试非常脆弱。

    这里有一个隐含的假设，那就是公共API要比私有API

    更加稳定。这应该是非常合理的假设，因为公共API是对外的承诺，对其修改总是需要协调多个系统甚至团队，因此天然就要求稳定性。而实现细节本身就需要在项目开发过程中不断调整优化的，所以一旦在测试中依赖了实现细节，就更有可能受到影响。如果大家对于这一点感受不强，那可能恰好说明了平时系统重构做的太少了。。。
    书中没有提到的点，是在不同场景下，我们关注的SUT的粒度可能不一样，“系统功能”的粒度也可能不一样。因此可观测行为与实现细节的边界在不同的场景下不是一成不变的。所以我个人认为，还是可以淡化单元测试和集成测试的边界，只需要明确在其场景下清晰的定义可观测行为和公共API，然后在这个边界去验证SUT的行为。

### 6 Styles of unit testing

    本章讨论不同的测试风格，主要是指验证方式的区别，同时介绍了函数式编程

单元测试可以分为三种风格：

    基于输出（output-based）的测试只校验SUT的输出
    这是假设SUT没有隐藏的状态，其运行的唯一结果就是返回值
    这种风格的测试拥有最好的测试质量，因为所有交互都基于公共API而无需关注实现细节，实现上也很简洁
    基于状态（state-based）的测试指在运行结束后验证SUT的状态
    与基于输出的测试相比较，基于状态的测试总是需要和更多的API打交道以获取状态，因此与系统的耦合还是多了一些，所以精确率上有所不如
    此外在测试用例书写时由于需要校验状态，也不是非常简洁，所以可维护性也不如
    基于交互（communication-based）的测试，是指使用mock来验证系统间的交互行为
    伦敦派的写法会大量使用这种风格的测试
    这种风格需要使用大量的mock，因此在精确率和可维护性上都是最差的

基于输出的测试需要代码本身是函数式的。函数式编程的代码会分为两个部分：内部是无状态的业务逻辑部分，包含了主要的复杂度，外部则是处理状态的壳，应该越简单越好。外部需要收集所有的输入信息，函数式的核心部分会产生决策，外部再基于决策来产生各类副作用。我们的目标是尽量用基于输出的测试来覆盖核心部分，而外部流程则留给少量的集成测试。与六边形架构相比，函数式把所有的状态都放到了领域逻辑之外，而六边形架构则允许内部状态。



当然函数式也有其成本，以上面的流程来看，需要在第一阶段就获取所有可能需要的信息，而这里有部分可能是不必要的。另外要把代码按函数式来划分也需要很多额外的代码。所以只有复杂度较高的部分才值得做这么大的改动。
### 7 Refactoring toward valuable unit tests

    在上面讨论了“什么是好的测试”之后，本章介绍“如何写出好的测试”。

上一章讨论了如何把代码重构为函数式的风格，本章讨论更加通用的方法。

代码的复杂度指其中决策点的数量，既包括在代码中直接声明的，也包括通过类库间接声明的。复杂的代码一般来说应当也是对于问题领域影响最大的代码，也是从单测中收益最明显的部分。



代码可以从复杂度/领域重要性 和 交互方数量 的维度分为四个象限

    左上角的部分应当是领域模型和算法，它们拥有最高的复杂度，但是不应该有太多交互方
    左下角是一些琐碎（trivial）的代码，复杂度和交互方都很少
    右下角的部分是控制器，不应当包含太复杂的业务逻辑，主要是承担编排其他组件的功能
    右上角的象限既有高复杂度又有大量交互对象

右上角的部分难以测试，可以通过humble object的模式把其中的业务逻辑抽取出来进入领域逻辑象限，而使得剩余部分
能够落入控制器的象限。可以把复杂度和交互方数量理解为代码的深度和宽度，代码要么很深要么很宽，不能两者兼有。六边形架构和函数式编程

都是这种思想的体现，只不过函数式编程做到了极致。

领域逻辑是单元测试最能发挥作用的地方，而控制器部分只需要通过集成测试来简要覆盖，琐碎代码则完全不必测试。我们应当关注的合理的测试覆盖率，而不应该追求100%的覆盖率，让测试发挥最好的价值。

把业务逻辑从流程编排

中隔离出来，也需要平衡三个方面

    领域模型的可测试性，交互方越少越容易测试
    控制器的简单性，决策点越少越简单
    性能，主要体现在进程外交互的数量

因为很多交互流程取决于业务逻辑的判断，所以各种方案都可能导致某个方向受损：

    如果把所有交互方都放在控制器层，则需要在领域逻辑外准备好所有可能用到的数据，导致性能降低
    如果把交互逻辑

    放到领域模型内，会影响可测试性
    拆分领域模型，把决策流程分为多个小步骤，又会增加控制器的复杂度

第三种方案是相对合理的取舍。也可以使用一些模式来减少对于控制器复杂度的影响

    canExecute/execute模式，也就是由领域模型提供canExecute的判断，避免业务逻辑的碎片化并收敛在领域模型内部
    领域事件模式，把领域模型内的重要变化通过事件来通知控制器层，使得模型变化的信息可以被追踪

    这一章的内容继续深化前面的讨论，并且提出了比较通用的方案，就是隔离业务逻辑和控制器。这个和DDD中倡导的隔离业务复杂度和技术复杂度异曲同工，本质上也是关注点分离原则的体现，使得各个部分能够有各自适合的测试策略。作者这里的讨论也远远超过了测试本身，而是对于整体架构设计的分析讨论。

## Part 3 Integration testing
### 8 Why integration testing?

    本章继续讨论集成测试



不符合单元测试标准的都可以认为是集成测试，一般来说集成测试总是需要验证系统和交互方的集成

    集成测试关注控制器，单元测试则覆盖算法和领域模型
    集成测试能够有更好的召回率和准确率，单元测试运行更快也更加容易维护

测试金字塔体现了这种权衡，让大部分测试用例都是低成本的单元测试。边缘场景尽量使用单元测试来覆盖，集成测试只覆盖关键的happy path

。但如果项目本身的领域逻辑比较简单，那么也可以减少单元测试的比例。

使用集成测试去覆盖边缘场景是得不偿失的，对于这类场景的问题，应当遵循快速失败原则（fail fast principle)，一旦发生预期外的错误就停止当前操作，尽早暴露错误，并保护系统状态不受到损坏。

    作者在书中多次提醒，要关注测试的价值，价值不高的测试是坏的测试，还不如不写。

集成测试需要处理进程外的依赖，可以分为两类

    受控依赖(managed dependencies)是只有自己的应用会访问的外部依赖，不算是可观测行为（比如数据库），而是实现的细节，建议在测试中使用真实的实例
    非受控依赖(unmanaged dependencies)是其他应用也需要访问的依赖，属于外部可观测行为，应当在集成测试中使用mock

    作者建议对受控依赖采用真实实例，更多还是从提高测试的召回率角度来考虑，前提也是集成测试的占比应该不高。但是为了快速反馈，也可以采用各种变通的方式。比如对于数据库，很多时候可以采用内存数据库

    来模拟大部分的流程。

接口常常被用来对依赖进行抽象，但是如果一个接口只有一种实现，那么这个接口并不会提供更低的耦合，而且可能违反了YAGNI(You aren’t gonna need it)原则。只有这类依赖是我们需要mock的外部依赖时，接口才有意义。

集成测试的一些最佳实践：

    让领域模型

的边界更为显式和清晰
减少代码的层级，太多层级使得代码难以理解和推理（reason about），大多数系统使用领域层、控制器层和基础架构层

    就足够了
    消除循环依赖，也会加重认知负荷，难以理清
    act部分不应当有多个语句，除非难以达到目标状态。单测中不应该出现，集成测试可能会出现。

### 9 Mocking best practices

我们应当使得mock的价值最大化，只用在系统边缘的非受控依赖。对包装非受控依赖的最后一个类型进行Mock，这样能提高测试的召回率和准确率，因为测试中包含的代码最多，同时也贴近系统真正的对外交互。

Spy是mock的一种，区别在于是单独手写的对象，而非通过框架生成。实践表明使用spy来做mock可以提供更加优雅的测试语句，因为我们可以在spy

上扩展相应的功能。

    注意这里的spy和mockito框架里的概念不一致，可以理解为自己对依赖实现一份内存实现，而不是用框架来设置各个方法的返回值。这样确实可以使得mock过程更加容易理解。而且这样的实现可以在多个场景复用，而不需要每次都痛苦的思考该设置什么输入输出。

一些最佳实践：

    理论上只有controller需要和非受控依赖打交道，所以单测是不需要mock的，只有集成测试要使用mock
    在测试中不要依赖生产代码的逻辑，可以重新定义常量和字面值，否则无法进行有效的检查。
    对于log这样的非受控依赖，可以不需要太关注具体的结构，只需要验证其存在以及核心信息即可
    在mock中验证交互的次数，既要关注预期发生的交互，也要关注预期不发生的交互。
    不要mock不属于自己的类型，对于非受控的依赖应当写一个适配器（adaptor），并mock这个适配器。适配器就是反腐层，可以使用本应用的领域语言，并且只需要包含真正使用到的功能。

### 10 Testing the database

如前所述，数据库一般是作为系统的受控依赖，因此不要mock数据库，而是采用真实的数据库系统。

数据库的schema

应当作为代码管理，reference data（应用不能修改的数据）也应当作为schema的一部分。

因为要连接真实数据库，所以在测试中并行是非常困难的，建议还是串行的运行。另外也应该连接本地的数据库实例来加速。也可以使用Docker镜像来进一步加速，但是必要性不太大。

    这个还是建立在需要数据库的测试用例不多的前提下，否则带来的运行速度问题还是比较明显的。如果本身应用中使用的SQL语句不太复杂，我个人认为内存数据库还是不错的方案。

数据库schama可以使用state-based模式或者migration-based模式，前者相当于记录最新的snapshot，后者则记录所有的变更。大部分情况下推荐使用migration-based模式，因为更加容易在schema变更的时候处理现有数据。

为了保证测试结果不要互相影响，需要在多次运行之间清理数据库，建议在每次测试开始的时候清理数据库。

    要注意系统状态可能分布在多个组件，数据库只是其中一种，还包括内存状态、缓存、Redis、MQ等，其中有一些需要进行mock。要想在测试之间避免影响，其实需要清理所有的状态，如果设计不好有可能会漏掉或者导致测试速度太慢。

## Part 4 Unit testing anti-patterns
### 11 Unit testing anti-patterns

在测试中使用私有方法加重了测试与实现的耦合，应当采用间接的方式来访问。

如果私有方法太过于复杂，以致于公共API无法测试，这可能说明了抽象的问题。应当把这部分抽象抽出为一个单独的类。

不要为了单元测试而暴露内部状态，所有的交互都应当和生产环境一样。

在测试中不要依赖具体的实现方式，用黑盒的方式来验证。

code pullution是指为了测试而增加生产代码，这是一个反模式，提升了生产代码的维护成本。

不要mock一个具体类，而应该使用接口。

在测试中依赖时间会导致测试的脆弱性，可以把时间依赖注入
到逻辑中，便于在测试时进行mock。