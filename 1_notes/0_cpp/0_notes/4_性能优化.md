性能优化
* 编译器优化
* 高效使用C++
  * 优化算法实现,避免不必要的递归;避免在循环中创建和销毁对象
  * 避免不必要的计算和wait;避免不必要的参数copy
  * 利用计算资源,现在cpu很多时候都可以对指令并行化,利用simd特性
  * 编写硬件友好型的代码
* 面向硬件优化

## 编译器选项
### 1. 设置target architecture
对于一般的客户端软件,设置目标架构并进行特定优化通常不是必需的,因为大多数情况下,编译器默认生成的代码已经足够高效,并且可以在各种不同的处理器上运行.

然而,如果你正在开发一些性能关键的软件,如游戏/图形渲染器/科学计算软件等,那么针对特定架构进行优化可能会带来显著的性能提升.在这种情况下,你可以考虑为你的目标平台设置目标架构,并使用相应的优化选项.

需要注意的是,如果你为一个特定的处理器优化了代码,那么这段代码在其他类型的处理器上可能无法运行,或者运行效率较低.因此,你需要考虑你的软件将在哪些平台上运行,并可能需要提供多个版本的二进制文件,以支持不同的处理器.

此外,设置目标架构并进行优化可能会使编译过程变得更复杂,并可能使得代码更难以调试和维护.因此,在决定是否进行这种优化时,你需要权衡其可能带来的好处和代价.

### 2. fast-math库
对于一些对计算精度要求低/计算性能要求高的场景,使用fast-math库是一个可选项,fast-math的计算结果可能和标准不一致.

在GCC/LLVM中,使用"-ffast-math"使能编译优化,该选项包含在"-Ofast"选项中;MSVC使用"/fp:fast"选项使能.

### 3. 禁用exception和rtti
GCC/LLVM中使用"-fno-exceptions"选项禁用异常,该选项对所有使用"throw"抛出异常的地方,替换为std::abrot()调用,参考GCC说明:Exceptions.禁用后的好处是编译器不再生成异常处理相关的代码,

但是,在现代C++中,异常的使用对于正常运行的代码基本没有开销,抛出异常并处理带来的性能开销非常小(<3%),所以对于非关键性能实现,可以不考虑禁用异常.以上分析来自(Standard C++):

### 3. Use Unity builds
Unity build的主要目标是提高编译效率,将多个文件合并为一个文件也能为编译器提供更多的优化机会.

### 4. pgo
PGO,全称为 Profile-Guided Optimization(基于分析的优化),是一种编译器优化技术,它通过收集程序运行时的性能信息来指导编译器优化.

PGO 的工作流程通常包括以下几个步骤:

1. **编译**:首先,你需要使用特殊的编译器选项来编译你的程序,这会使得程序在运行时收集性能信息.

2. **运行**:然后,你需要运行你的程序,并让它处理一些典型的工作负载.这会生成一个性能分析文件,其中包含了程序运行时的性能信息.

3. **优化编译**:最后,你需要再次使用特殊的编译器选项来编译你的程序,这次编译器会使用性能分析文件中的信息来指导优化.

通过这种方式,编译器可以了解到程序的实际运行情况,例如哪些代码经常被执行,哪些代码很少被执行,哪些条件分支的预测结果通常是什么等等.然后,编译器可以使用这些信息来进行更有效的优化,例如更精确地进行内联,更智能地安排代码布局,更准确地预测条件分支等等.

PGO 可以显著提高程序的运行速度,特别是对于那些性能敏感的应用程序.然而,PGO 也有一些缺点,例如它会增加编译时间和编译复杂性,因此并不是所有的项目都适合使用 PGO.

## 高效使用C++
### 1. constexpr all the things
constexpr变量和函数
### 2. noexcept all the things
void f(); // 可能抛出异常
void f() noexcept; // 不会抛出异常
使用noexcept修饰后,可以让编译器省去生成的异常处理代码,有很多的优化机会.

noexcept对于移动语义,swap,内存释放函数和析构函数非常有用

### 3. Use static for internal linkage
在定义函数时,如果函数仅在文件内调用,将函数定义为static,可以让编译器更好进行inline优化.

代码示例:

使用inline hint:

