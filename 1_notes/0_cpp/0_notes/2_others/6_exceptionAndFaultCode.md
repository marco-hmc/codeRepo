
**15. 理解异常处理所付出的代价**

编译器带来的开销（很难消除，因为所有的编译器都是支持异常的
try块语句的开销：大概会降低5%-10%的速度和增加相应的代码尺寸

**10. 防止构造函数里的资源泄漏**

这一条主要是防止在构造函数中出现异常导致资源泄露：
    
    BookEntry::BookEntry(){
        theImage     = new Image(imageFileName);
        theAudioClip = new AudioClip(audioClipFileName);
    }
    BookEntry::~BookEntry(){
        delete theImage;
    }

如果在构造函数new AudioClip里面出现异常的话，那么~BookEntry析构函数就不会执行，那么NewImage就永远不会被删除，而且因为new BookEntry失败，导致delete BookEntry也无法释放theImage，那么只能在构造函数里面使用异常来避免这个问题
    
    BookEntry::BookEntry(){
        try{
            theImage     = new Image(imageFileName);
            theAudioClip = new AudioClip(audioClipFileName);
        }
        catch(...){
            delete theImage;
            delete theAudioClip;
            //上面一段代码和析构函数里面的一样，所以可以直接封装成一个成员函数cleanup：
            cleanup();
            throw;
        }
    }

更好的做法是将theImage和theAudioClip做成成员来进行封装：
    
    class BookEntry{
    public:......
    private:
        const auto_ptr<Image> theImage;
        const auto_ptr<AudioClip> theAudioClip;
    }

**11. 阻止异常传递到析构函数以外**

如果析构函数抛出异常的话，会导致程序直接调用terminate函数，中止程序而不释放对象，所以不应该让异常传递到析构函数外面，而是应该在析构函数里面直接catch并且处理掉

另外，如果析构函数抛出异常的话，那么析构函数就不会完全运行，就无法完成希望做的一些其他事情例如：
    
    Session::~Session(){
        logDestruction(this);
        endTransaction(); //结束database transaction,如果上面一句失败的话，下面这句就没办法正确执行了
    }

异常安全

## 错误码和异常处理

程序出错几乎是必然事件，有可能是由于上游任务提供的数据就是错的。也有可能是程序内部实现，出现了bug。

对于程序出错的这种情况，需要有一套机制能够帮忙定位是什么错误，以及出现了错误之后如何处理的。

一般而言错误处理方式有两种处理方法
* 错误码
* 异常机制

### 1. 错误码

简单来说，网络请求返回的相应信息中的状态码其实也是一种错误码（`404`等）；宽带拨号上网失败也会产生错误码；程序运行崩溃生成日志，日志里面可能也带着错误码信息。

常见的错误码的设计，一般而言有这些：
* 错误码分模块处理：不同模块的错误码不是共同一个值域。
* 错误码分正负处理：正值为上游服务出问题；负值为程序内部实现出问题；零值表示没问题。

### 2. 异常

#### 2.1 抛出异常,没有捕获会怎么样?
如果在C++程序中抛出了异常,但没有被捕获,那么程序会调用函数 `std::terminate`,然后立即终止.这通常会导致程序的非正常退出.

在调用 `std::terminate` 之前,C++ 还会尝试调用一个名为 `std::unexpected` 的函数.你可以通过 `std::set_unexpected` 函数来设置 `std::unexpected` 的行为.如果 `std::unexpected` 函数没有调用 `std::terminate` 并且能够处理异常,那么程序可能会继续执行.但是,通常情况下,`std::unexpected` 函数会调用 `std::terminate`.

`std::terminate` 函数的默认行为是调用 `abort` 来终止程序,但你可以通过 `std::set_terminate` 函数来改变这个行为.

总的来说,如果抛出了异常但没有被捕获,那么程序通常会立即终止.这就是为什么在编写可能会抛出异常的代码时,应该总是提供一个异常处理机制,以防止程序的非正常退出.

#### 2.2 别让异常逃离析构函数
应避免让析构函数抛出异常.如果在析构过程中可能会产生异常,那么应该在析构函数内部捕获并处理这些异常,而不是让它们传播到析构函数的外部.

这里主要是因为如果循环析构10个Widgets,如果每一个Widgets都在析构的时候抛出异常,就会出现多个异常同时存在的情况,这里如果把每个异常控制在析构的话就可以解决这个问题.

因为C++标准规定程序必须立即调用 std::terminate 函数来终止程序.这是因为C++不允许在同一时间处理两个异常.

### 3. 总结

目前C++提供了统一的异常机制机制,但是没有提供统一的错误码机制.
#### 3.1 c++为什么没有提供统一的错误码
  1. **灵活性**:C++是一种通用的编程语言,用于各种不同的应用领域.在不同的应用领域中,可能需要处理的错误类型和数量都会有所不同.如果标准库提供了统一的错误码,可能无法满足所有应用领域的需求.

  2. **异常处理**:C++提供了异常处理机制,这是一种更强大/更灵活的错误处理方式.通过抛出异常,可以提供比错误码更丰富的错误信息,而且可以处理更复杂的错误情况.

  3. **历史原因**:C++的设计者选择了异常处理作为主要的错误处理机制,而不是错误码.这是一个设计决策,可能受到了历史原因的影响.

  虽然C++标准库没有提供统一的错误码,但是它提供了一些类和函数来处理错误.例如,`std::error_code`和`std::error_condition`类可以用来表示和处理错误,`std::system_error`异常可以用来抛出包含错误码的异常.此外,许多C++标准库函数(如文件I/O函数)会设置`errno`变量来表示错误,这可以看作是一种错误码机制.

#### 3.2 异常处理机制和错误码机制都是处理错误的方式,它们各有优点和适用场景.

**异常处理机制**更适合以下情况:

1. **错误无法预见或无法立即处理**:例如,内存分配失败/无效的类型转换等情况,这些错误无法预见,也无法立即处理,使用异常可以将错误处理逻辑和正常逻辑分离,使代码更清晰.

2. **错误需要跨越多个调用层次**:如果错误需要跨越多个调用层次传播,使用异常可以简化代码,避免在每一层都检查和传递错误码.

3. **面向对象编程**:在面向对象编程中,构造函数不能返回错误码,因此使用异常是处理构造函数错误的唯一方式.

**错误码机制**更适合以下情况:

1. **错误可以预见并立即处理**:例如,打开文件失败/找不到指定的元素等情况,这些错误可以预见,也可以立即处理,使用错误码可以让调用者直接知道函数是否成功.

2. **性能敏感的代码**:异常处理可能会对性能产生影响,尤其是当异常被频繁抛出时.对于性能敏感的代码,使用错误码可以避免这种性能损失.

3. **与C语言代码交互**:C++的异常不能跨越C++和C语言的边界.如果你的C++代码需要与C语言代码交互,使用错误码是更好的选择.

总的来说,选择使用异常处理还是错误码,取决于具体的应用场景和需求.

### 99. quiz

#### 1. C/C++程序的异常处理问题
在 C++ 中，异常处理机制是通过栈展开（stack unwinding）来实现的。当一个异常被抛出时，程序会沿着调用栈向上查找，直到找到一个匹配的异常处理程序（`catch` 块）。如果在调用栈中没有找到匹配的异常处理程序，程序将会终止。

1. **C++ 异常处理**：
   - C++ 支持异常处理机制，可以使用 `try`、`throw` 和 `catch` 关键字来抛出和捕获异常。
   - 当 C++ 代码抛出异常时，编译器会生成额外的代码来管理栈展开和异常处理。

2. **C 异常处理**：
   - C 语言本身不支持异常处理机制，没有 `try`、`throw` 和 `catch` 关键字。
   - C 代码通常使用返回值或错误码来处理错误情况。

当 C++ 代码与 C 代码混合使用时，可能会出现以下情况：

1. **C++ 代码调用 C 代码**：
   - 如果 C++ 代码调用 C 代码，并且 C 代码中没有异常处理机制，那么如果 C++ 代码抛出异常，异常会沿着调用栈传递到 C 代码中。
   - 由于 C 代码中没有异常处理机制，栈展开过程可能无法正确进行，导致未定义行为或程序崩溃。

2. **C 代码调用 C++ 代码**：
   - 如果 C 代码调用 C++ 代码，并且 C++ 代码抛出异常，异常会沿着调用栈传递到 C 代码中。
   - 同样，由于 C 代码中没有异常处理机制，栈展开过程可能无法正确进行，导致未定义行为或程序崩溃。

为了避免 C++ 异常传递到没有异常处理机制的 C 代码中，可以采取以下措施：

1. **在 C++ 代码中捕获异常**：
   - 在 C++ 代码中捕获所有可能的异常，确保异常不会传递到 C 代码中。

   ```cpp
   extern "C" void c_function_wrapper() {
       try {
           // 调用实际的 C++ 函数
           cpp_function();
       } catch (const std::exception& e) {
           // 处理异常
           std::cerr << "Exception caught: " << e.what() << std::endl;
       } catch (...) {
           // 处理所有其他类型的异常
           std::cerr << "Unknown exception caught" << std::endl;
       }
   }
   ```

2. **使用 `extern "C"` 进行函数声明**：
   - 使用 `extern "C"` 进行函数声明，以确保 C++ 函数可以被 C 代码调用，同时在 C++ 函数中捕获异常。

   ```cpp
   extern "C" void cpp_function();
   ```

3. **避免在 C 代码中调用可能抛出异常的 C++ 代码**：
   - 尽量避免在 C 代码中调用可能抛出异常的 C++ 代码，或者确保所有异常在 C++ 代码中被捕获。

C++ 代码抛出异常时，如果异常传递到没有异常处理机制的 C 代码中，可能会导致未定义行为或程序崩溃。为了避免这种情况，可以在 C++ 代码中捕获所有可能的异常，使用 `extern "C"` 进行函数声明，并尽量避免在 C 代码中调用可能抛出异常的 C++ 代码。通过这些措施，可以确保异常处理机制在混合使用 C 和 C++ 代码时的正确性和安全性。

#### 2. 不用异常的理由
C++ 社区中有一部分开发者不喜欢使用异常，主要有以下几个理由：

* **1. 性能开销**

- **异常处理的开销**：虽然在没有异常抛出的情况下，异常处理的开销通常很小，但一旦抛出异常，栈展开和捕获异常的过程会带来显著的性能开销。
- **代码优化**：异常处理机制可能会影响编译器的优化能力，因为编译器需要生成额外的代码来支持异常处理。

* **2. 可预测性和可控性**

- **代码流控制**：异常会改变正常的代码执行路径，使得代码流变得难以预测和理解。特别是在大型代码库中，异常的传播路径可能会非常复杂。
- **隐藏错误处理**：异常机制可能会隐藏错误处理的细节，使得代码的行为变得不透明。相比之下，显式的错误处理（如返回错误码）更容易理解和调试。

* **3. 兼容性问题**

- **与 C 代码的兼容性**：C 语言不支持异常处理机制，因此在混合使用 C 和 C++ 代码时，异常处理可能会导致兼容性问题。
- **跨语言调用**：在与其他编程语言（如 Python、Java）进行互操作时，异常处理机制可能会带来额外的复杂性。

* **4. 资源管理**

- **RAII 和智能指针**：C++ 提供了 RAII（Resource Acquisition Is Initialization）和智能指针等机制来管理资源，这些机制在大多数情况下可以替代异常处理来确保资源的正确释放。
- **手动资源管理**：在某些情况下，开发者可能更喜欢手动管理资源，以便更精细地控制资源的分配和释放。

* **5. 调试和维护**

- **调试困难**：异常的传播路径可能会跨越多个函数和模块，使得调试变得更加困难。相比之下，显式的错误处理更容易跟踪和调试。
- **代码维护**：异常处理机制可能会增加代码的复杂性，特别是在需要处理多种类型的异常时。显式的错误处理通常更容易维护和修改。

* **6. 嵌入式系统和实时系统**

- **嵌入式系统**：在资源受限的嵌入式系统中，异常处理的开销可能是不可接受的。显式的错误处理通常更适合这种环境。
- **实时系统**：在实时系统中，异常处理的不可预测性可能会影响系统的实时性要求。显式的错误处理可以提供更可预测的行为。

* **总结**

虽然 C++ 提供了强大的异常处理机制，但在某些情况下，开发者可能更喜欢使用显式的错误处理方式。这主要是因为异常处理可能带来的性能开销、代码流控制的复杂性、与 C 代码的兼容性问题、资源管理的需求、调试和维护的困难，以及在嵌入式和实时系统中的应用限制。通过显式的错误处理，开发者可以更精细地控制代码的行为和资源管理，从而提高代码的可预测性和可维护性。

#### 3. 使用异常的理由
包括清晰的错误处理、强制错误处理、资源管理、代码复用、更好的调试支持以及处理不可预见的错误。通过合理使用异常处理机制，可以提高代码的健壮性和可维护性。