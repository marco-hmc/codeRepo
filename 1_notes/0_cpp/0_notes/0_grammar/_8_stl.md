## stl

### 1. concepts
* stl包含什么内容?
STL，全称Standard Template Library（标准模板库），是C++标准库的一部分。它包含了一系列的模板类和函数，主要用于数据处理和算法操作。STL的主要内容包括：

1. **容器（Containers）**：如vector、list、deque、set、map等，用于存储和操作数据。

2. **算法（Algorithms）**：如sort、find、copy、for_each等，提供了一系列对容器进行操作的通用算法。

3. **迭代器（Iterators）**：提供了一种方法，可以按照一定的顺序访问容器中的元素，而无需暴露容器的内部表示。

4. **函数对象（Functors）**：这是一种特殊的对象，可以像函数一样被调用。函数对象通常用于创建可定制的算法。

5. **适配器（Adapters）**：如stack、queue、priority_queue等，它们是在其他容器的基础上，提供了不同的接口。

6. **分配器（Allocators）**：用于控制STL容器的内存分配。

以上就是STL的主要内容。

### 2. 容器

#### 2.1 序列容器

1. **vector**
   * 数据结构：动态数组
   * 复杂度：插入、删除元素（尾部）O(1)，插入、删除元素（非尾部）O(n)，访问元素O(1)
   * 特点：支持快速随机访问，内存连续，尾部插入删除效率高，非尾部插入删除效率低

2. **deque**
   * 数据结构：双端队列
   * 复杂度：插入、删除元素（头尾）O(1)，插入、删除元素（非头尾）O(n)，访问元素O(1)
   * 特点：支持快速随机访问，头尾插入删除效率高，非头尾插入删除效率低

3. **list**
   * 数据结构：双向链表
   * 复杂度：插入、删除元素O(1)，访问元素O(n)
   * 特点：插入删除效率高，不支持随机访问，内存使用相对较高

4. **forward_list**
   * 数据结构：单向链表
   * 复杂度：插入、删除元素O(1)，访问元素O(n)
   * 特点：插入删除效率高，不支持随机访问，只能向前遍历

5. **array**
   * 数据结构：静态数组
   * 复杂度：插入、删除元素N/A（不支持插入删除操作），访问元素O(1)
   * 特点：支持快速随机访问，内存连续，大小固定，不支持插入删除操作

#### 2.2 有序关联容器

1. **set**
   * 数据结构：基于红黑树的集合
   * 复杂度：插入、删除、查找元素O(log n)
   * 特点：元素唯一，自动排序，查找效率高

2. **multiset**
   * 数据结构：基于红黑树的集合
   * 复杂度：插入、删除、查找元素O(log n)
   * 特点：元素可以重复，自动排序，查找效率高

3. **map**
   * 数据结构：基于红黑树的键值对集合
   * 复杂度：插入、删除、查找元素O(log n)
   * 特点：键值对，键唯一，自动排序，通过键快速查找值

4. **multimap**
   * 数据结构：基于红黑树的键值对集合
   * 复杂度：插入、删除、查找元素O(log n)
   * 特点：键值对，键可以重复，自动排序，通过键快速查找值

#### 2.3 无序关联容器

1. **unordered_set**
   * 数据结构：基于哈希表的集合
   * 复杂度：插入、删除、查找元素平均O(1)，最坏O(n)
   * 特点：元素唯一，不自动排序，查找效率高

2. **unordered_multiset**
   * 数据结构：基于哈希表的集合
   * 复杂度：插入、删除、查找元素平均O(1)，最坏O(n)
   * 特点：元素可以重复，不自动排序，查找效率高

3. **unordered_map**
   * 数据结构：基于哈希表的键值对集合
   * 复杂度：插入、删除、查找元素平均O(1)，最坏O(n)
   * 特点：键值对，键唯一，不自动排序，通过键快速查找值

4. **unordered_multimap**
   * 数据结构：基于哈希表的键值对集合
   * 复杂度：插入、删除、查找元素平均O(1)，最坏O(n)
   * 特点：键值对，键可以重复，不自动排序，通过键快速查找值

#### 2.4 容器适配器

1. **stack**
   * 数据结构：基于其他容器（如deque）实现的后进先出（LIFO）数据结构
   * 复杂度：插入、删除元素（顶部）O(1)，访问元素（顶部）O(1)
   * 特点：只能在顶部插入删除元素，后进先出（LIFO）

2. **queue**
   * 数据结构：基于其他容器（如deque）实现的先进先出（FIFO）数据结构
   * 复杂度：插入元素（尾部）O(1)，删除元素（头部）O(1)，访问元素（头部）O(1)
   * 特点：在尾部插入元素，在头部删除元素，先进先出（FIFO）

3. **priority_queue**
   * 数据结构：基于其他容器（如vector和make_heap）实现的优先队列
   * 复杂度：插入元素O(log n)，删除元素（顶部）O(log n)，访问元素（顶部）O(1)
   * 特点：元素按优先级排序，顶部元素优先级最高，只能访问顶部元素

### 3. 算法

* 为什么stl中的内存分配器要设计为一个模板参数而不是一个构造函数参数?
* 
* 请你回答一下STL里vector的resize和reserve的区别
  * resize()：改变当前容器内含有元素的数量size，eg: vector\<int\>v；v.resize(len)；v的size变为len，**如果原来v的size小于len，那么容器新增（len-size）个元素，元素的值为默认为0**。当v.push_back(3);之后，则是3是放在了v的末尾，即下标为len，此时容器是size为len+1；**如果原来v的size大于len，resize会移除那些超出len的元素同时销毁他们**
  * reserve()：改变当前容器的最大容量（capacity），**它不会生成元素**，只是确定这个容器允许放入多少对象，如果reserve(len)的len值大于当前的capacity，那么会重新分配一块能存len个对象的空间，然后把之前v.size()个对象通过copy construtor复制过来，销毁之前的内存。len值小于当前capacity，不做处理
  * **resize既分配了空间，也创建了对象，可以通过下标访问。resize既修改capacity大小，也修改size大小**
  * **reserve只修改capacity大小，不创建对象，push或insert时才创建，不修改size大小**
* 请你来说一下map和set有什么区别，分别又是怎么实现的？

  * map和set都是C++的关联容器，其底层实现都是红黑树（RB-Tree）。由于 map 和set所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 map 和set的操作行为，都只是转调 RB-tree 的操作行为。

  * map和set区别在于：

    * map中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。
    * **set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key**。其原因是因为map和set是**根据关键字排序来保证其有序性**的，**如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置**。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。

    * map支持下标操作，set不支持下标操作。如果find能解决需要，尽可能用find

* functional头文件支持的基于模板的比较函数对象
  * equal_to<Type>、not_equal_to<Type>、greater<Type>、greater_equal<Type>、less<Type>、less_equal<Type>
  * 常用的有greater <Type>()从大到小排序，less <Type>()从小到大排序

* ***vector问题***
    尽量不要在vector中存放bool类型,vector为了做优化,它的内部存放的其实不是bool.

* ***vector删除***
```c++
    std::vector<int> vec(1000000, 42);  // 创建一个包含1000000个元素的vector,并初始化为42
    vec.clear();  // 使用clear方法清空vector,但容量仍然是1000000
    // 在这之后,vec仍然占用着大量内存,即使已经没有实际的元素

    std::vector<int>().swap(vec);  // 使用swap方法将一个新的空vector与vec交换
```

#### (23)实现一个动态数组要怎么实现,说思路(腾讯teg一面)
模拟STL中vector的实现即可,去看一下vector的源码.

#### (6) 实现一个strcpy函数(或者memcpy),如果内存可能重叠呢

#### (48)string的底层实现
string继承自basic_string,其实是对char\*进行了封装,封装的string包含了char\*数组,容量,长度等等属性.

string可以进行动态扩展,在每次扩展的时候另外申请一块原空间大小两倍的空间(2^n),然后将原字符串拷贝过去,并加上新增的内容.


* 隔一个删除一个map中的元素(主要考察迭代器的失效问题)