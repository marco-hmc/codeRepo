## reference 

### 1. concepts

### 2. 右值引用

### 3. 完美转发

### 99. quiz

#### 1. 为什么多线程传引用要用`std::ref`

**33. 对于std::forward的auto&&形参使用decltype**

在C++14中，我们可以在lambda表达式里面使用auto了，那么我们想要把传统的完美转发用lambda表达式写出来应该是什么样子的呢：
    
    class SomeClass{
    public:
        template<typename T>
        auto operator()(T x) const{
            return func(normalize(x));
        }
    }
    
    auto f=[](auto&& x){
        return func(normalize(std::forward<decltype(x)>(x)));
    };


引用绑定到临时对象的规则:
右值引用: 当使用右值引用(&&)绑定到返回的右值(例如函数返回的临时对象)时,编译器会延长右值的生命周期,使得引用继续有效.

cpp
Copy code
const T& constRef = getTemporary();  // const 引用绑定到临时对象
为什么需要引用绑定到临时对象:
避免不必要的拷贝: 当函数返回临时对象时,使用引用绑定可以避免不必要的拷贝构造,提高性能.

允许延迟析构: 通过延长临时对象的生命周期,允许在整个语句块中使用临时对象,而不会在引用失效时导致未定义行为.

* 什么时候需要用move
  * 对于callback函数来说
  * 对于将对象插入到容器来说
  * 交换两个对象
  * 
* 为什么右值可以被常量左值引用 引用?
   ```cpp
   const std::string& lv2 = lv1 + lv1; // 合法, 常量左值引用能够延长临时变量的生命周期
   ```
* 拷贝构造函数的参数可以不加引用吗?为什么



#### 2. 一次浅拷贝和一次移动相比较，性能有很大差距吗？

一次浅拷贝（Shallow Copy）和一次移动（Move）操作在性能上通常存在显著差异，尤其是在涉及到大量数据或资源密集型对象时。这种性能差异主要源于它们处理对象数据和资源的方式。

### 浅拷贝

- 浅拷贝仅复制对象的非静态成员变量的值，对于指针类型的成员变量，浅拷贝只复制指针值（地址），而不复制指针所指向的数据。
- 如果对象包含对动态分配内存的引用，浅拷贝可能导致多个对象指向同一内存地址，从而在析构时可能引发重复释放同一资源的问题（double free）。
- 浅拷贝的性能开销通常较低，因为它不涉及新内存的分配和数据的复制。但在处理复杂对象或资源管理时，可能会引起问题。

### 移动操作

- 移动操作是C++11引入的，它通过转移一个对象的资源（如动态分配的内存）到另一个对象，而不是复制资源。
- 移动操作通常涉及修改原对象的指针或资源句柄，并将其置于一个有效但未定义的状态，这样就避免了不必要的资源复制，从而大大减少了开销。
- 对于包含大量数据或昂贵资源（如大型数组、容器、文件句柄等）的对象，移动操作的性能优势尤为明显。

### 性能差距

- 在处理大型对象或资源密集型对象时，移动操作的性能通常远超过浅拷贝，因为它避免了数据的复制，只是简单地转移了资源的所有权。
- 对于小型或简单的对象，这两者之间的性能差异可能不那么明显，但移动操作仍然提供了更安全和高效的资源管理方式。

总结来说，移动操作相比于浅拷贝，在性能上通常有显著优势，尤其是在涉及大量数据或资源密集型对象时。此外，移动操作还提高了代码的安全性和资源管理的效率。


#### 3. 如果都是值类型的，那浅拷贝和移动有区别吗

没有区别。

只有在引用类型的时候，浅拷贝和移动的性能也差不多，但是资源管理的表现形式不同
