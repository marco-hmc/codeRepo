## c/c++中的函数调用

### 1. concepts

#### 1.1 prerequisites

1. **什么是栈？**

   栈（Stack）是一种后进先出（LIFO，Last In First Out）的数据结构，它允许数据的存入(push)和取出(pop)操作仅在一端进行，这一端被称为栈顶。栈可以用数组或链表实现，广泛应用于程序的执行流程控制，如函数调用的实现。

2. **和内存中的栈有什么区别？**

   当我们提到“栈”时，可能指的是抽象的数据结构概念，也可能指的是程序运行时在内存中用于存储局部变量、函数参数和返回地址等信息的区域。这两者之间的主要区别在于：

   - **抽象的数据结构**：栈是一种抽象的数据结构概念，它定义了数据的存储和访问方式，即后进先出。这个概念可以用多种方式实现，例如，通过数组或链表。
   
   - **内存中的栈**：在程序运行时，内存中的栈（通常称为调用栈或执行栈）是用来存储函数调用过程中的局部变量、函数参数、返回地址等信息的内存区域。这个栈是按照栈的数据结构概念来管理这些信息的，确保函数调用和返回能够正确执行。内存中的栈是操作系统在程序开始执行时自动分配的，其大小通常有限制。

   总的来说，栈作为一种数据结构的概念，可以在不同的场景下以不同的形式实现。而程序运行时内存中的栈是这一概念在程序执行流程控制中的具体应用，是自动管理的，主要用于处理函数调用。


#### 1.2 内存中入栈出栈的示意图

为了方便表示本文后面的所有栈结构图中的每个格子都是8个字节 ，同时我们也假设push和pop指令每次操作8个字节

下图是一个大小为80个字节（图中每个格子是8个字节）的`栈`，地址范围是0~79。`栈指针`指向栈顶的位置：

![alt text](_imgs/_6_howFuncWorks_image.png)

入栈：

![alt text](_imgs/_6_howFuncWorks_image-1.png)

出栈

![alt text](_imgs/_6_howFuncWorks_image-2.png)


### 2. 控制转移

控制转移：当进行函数调用时，程序的执行流程需要从当前位置跳转到被调用函数的起始位置，执行完被调用函数后再返回到原来的位置继续执行。

考虑有如下C语言代码：
```c
void Q() {
    printf("this is Q.");
    return;
}

void P() {
    printf("readying to call Q.");
    Q();
    return;
}
```

我们假设代码的`行号`就是`指令地址`，在最开始时PC为7，也就是函数`P`的起始指令地址。CPU往下执行后发现是一个函数调用，此时把PC修改为被调用函数`Q`的起始指令地址2。直至`Q`执行完毕之后，最后再把PC修改为`P`中调用`Q`时的下一条指令地址9，整个调用过程结束。



现在有一个问题就是对于函数`返回地址`的保存，考虑当有大量函数嵌套调用时，每发生一次函数调用都会产生一个返回地址，并且这些返回地址还要和每次调用进行关联。为了满足这个需求我们需要使用`栈`来存储函数的`返回地址`，当每次发生调用时就将`返回地址`压入到`栈`中，函数执行完之后再把从把它从栈中弹出到`PC`中。

下面是一个C语言嵌套函数调用的例子，我们分别对它的调用和返回过程进行说明：

```c
void Q() {
    printf("this is Q.\n");
    return;
}

void P() {
    printf("readying to call Q.\n");
    Q();
    return;
}

void main() {
    printf("readying to call P.\n");
    P();
    return;
}
```

**调用过程：**

还是假设代码的`行号`为每条指令的地址，最开始PC为13，也就是`main`函数的第一行代码，程序继续执行到14，发现这里调用了函数`P`，因此把PC设为`P`的起始指令地址7。随后将调用`P`处的下一条指令地址15压入栈中。程序继续执行到8，发现这里调用了函数`Q`，同样把PC设为`Q`的起始指令地址2，最后将调用`Q`处的下一条指令地址9压入栈中，此时栈中存储了两个`返回地址`分别是9和15。

栈变化过程：

![](https://image.coder.cat/stack8.png)


**返回过程：**

在函数`Q`执行完之后，函数开始返回，返回时会把栈中之前保存的`返回地址`弹出到PC中，此时栈顶是指令地址9，将它从栈中弹出到PC中，函数成功的返回到`P`中。再待`P`执行完成之后，继续把栈顶的指令地址15弹出到PC中，到最后函数返回到了`main`中，栈也恢复成了发生调用前的样子。

栈变化过程：

![](https://image.coder.cat/stack9.png)


整套过程可以推广至任意层函数调用以及递归调用，栈完美的保存了函数的返回地址。这里为了举例方便把一行C代码当成一条指令，实际上这里的指令是经过编译后的`机器指令`，那么一行C代码可能会对应对条机器指令，每条机器指令在内存中都会有一个地址。


### 3. 数据传递

> 有时候调用者需要向被调用者`传递参数`，同时被调用者也可能需要向调用者`返回数据`。

## 参数传递

默认情况下`X64`（英特尔64位）中前6个参数存放在一组约定的寄存器中，其余参数以`从右到左`的顺序压入`堆栈`，因此调用者可以访问这组寄存器或`堆栈`来获取参数。而在`X86`（英特尔32位）中会直接将所有的参数以`从右到左`的顺序压入堆栈，所以调用者只需要访问`堆栈`就可以获取参数。

另外当被调用函数引用了参数的内存地址，那么这个参数也必须放在栈中，因为寄存器是没有内存地址的。

C语言中参数传递的例子（以`X64`为例）：

```C
void Q(long arg1, long arg2, long arg3, long arg4, long arg5, long arg6, long arg7, long arg8) {
    printf("this is Q.\n");
    return;
}

void main() {
    printf("readying to call Q.\n");
    Q(1, 2, 3, 4 ,5 ,6 ,7 ,8);
    return;
}
```

上面代码中函数`Q`有8个参数，前6个参数通过寄存器传递，多出来的2个参数`arg7`和`arg8`以`从右到左`的顺序压入堆栈，所以这里的压栈顺序是先`arg7`后`arg8`。为了方便绘图所以这里使用了`long`类型，它占8个字节刚好对应图中一个单元格。

压栈过程：

![](https://image.coder.cat/stack10.png)

## 返回值


### 4. 寄存器的保存与恢复

下面代码分别把`ax,bx`这两个寄存器保存在栈中：

```c
push(ax);
push(bx);
```

保存过程：

![](https://image.coder.cat/stack11.png)

把栈中的值逐个恢复到寄存器中：

```c
pop(bx);
pop(ax);
```

恢复过程：

![](https://image.coder.cat/stack12.png)

这里要注意的是出栈和入栈的顺序是相反的，因为此时`栈顶`是之前`bx`的值，所以在恢复时需要先把`栈顶`的值弹出到`bx`，然后再把下一个值弹出至`ax`，这样就把值与寄存器对应起来了。


**并不是所有的寄存器都需要`保存与恢复`，根据约定把寄存器中的一部分划分为`被调用者保存`和`调用者保存`：**


### 5. 局部变量的存储

> 寄存器和内存都可以用来存放`函数执行时`所需的`数据`。寄存器的存取速度比内存快很多，所以通常会优先把数据存入寄存器中。但是由于寄存器数量有限，因此当寄存器不够用时会将数据存放在`栈`内存中。

**我们可以把`栈指针`（sp）向`栈顶移动`来为函数在栈中分配用于存放`局部数据`的内存空间。**

例如有如下C语言代码：

```c
void main() {
    long foo = 100;
    long bar = 200;
}
```

代码中定义了两个`long`类型变量`foo`和`bar`，我们假设它们都放在`栈`中，由于`long`类型占用8个字节，因此我们需要在栈中分配16个字节的空间。

分配过程（一个单元格8个字节）：

![](https://image.coder.cat/stack13.png)



最后再把这两个变量分别存入栈中：

![](https://image.coder.cat/stack14.png)

### 6. 函数栈帧

> 当一个函数在运行时，需要为它在`堆栈`中创建一个`栈帧`（stack frame）用来记录运行时产生的相关信息，因此每个函数在执行前都会创建一个栈帧，在它返回时会销毁该栈帧。

**本节的示意图我们通过颜色区分调用者与被调用者的栈帧，蓝色表示被调用者，绿色表示调用者。**

## 创建栈帧

通常用一个叫做`栈基址`（bp）的寄存器来保存正在运行函数栈帧的`开始地址`，由于`栈指针`（sp）始终保存的是栈顶的地址，所以`栈指针`保存的也就是正在运行函数栈帧的`结束地址`。

![](https://image.coder.cat/stack3.png)

> 每次发生函数调用时都要修改`栈基址`（bp）使它保存新栈帧的`开始地址`，这将导致它被覆盖。因此我们可以利用之前讲到的`寄存器的保存与恢复`使用栈来对`栈基址`进行保存与恢复。



在一开始`栈基址`和`栈指针`都分别指向调用者栈帧的`开始地址`和`结束地址`，创建时首先将调用者栈帧的`开始地址`也就是此时的`栈基址`压栈保存，由于`栈基址`是`被调用者保存`寄存器，所以它存放在被调用的栈帧中。

栈变化过程：

![](https://image.coder.cat/stack18.png)



随后将`栈基址`（bp）修改成此时`栈指针`（sp）的值，使这它们都指向同一个位置（下面左图），如果被调用函数还需要栈空间，那么它可以继续把`栈指针`（sp）向低地址移动来分配空间（下面右图），最终`栈基址`和`栈指针`又分别指向了`被调用者`栈帧的`开始地址`和`结束地址`。

栈变化过程：

![](https://image.coder.cat/stack19.png)



栈帧中存储了函数参数、返回地址、保存的寄存器、局部变量，因此完整的栈结构可能像下面这样：



![](https://image.coder.cat/stack20.png)

**图中各个部分说明：**

* 函数参数（arguments）

  在`X64`中如果函数参数超过6个，前6个通过寄存器进行传递，其余参数则通过栈来进行参数传递，当少于等于6个或没有参数时，这个时候该栈帧部分可以忽略。

  在需要通过栈来传递参数时，`调用函数`需要先将参数压入自己的栈帧中，然后`被调用函数`从`调用函数`的栈帧中对参数进行访问。所以图中参数部分在调用函数的栈帧中。

* 返回地址（ret addr）

  将函数参数压栈之后，需要把调用位置处的下一条指令地址压栈，以便被调用函数执行完之后可以回到原来的位置继续执行，这个地址就是返回地址。

* 保存的寄存器（saved regs）

  这里存放的是需要`被调用者`来保存的寄存器，例如`旧的栈基址`（old bp）旧保存在其中。

* 局部变量（local vars）

  这个部分是存储在栈中而不是寄存器中的局部变量，如果函数没有局部变量或局部变量都存储在寄存器中，那么该栈帧部分可以忽略。



**如果再次发生函数调用，那就重复整个创建栈帧的过程，因此对于递归函数来说和普通函数也没什么区别。**



## 销毁栈帧

> 在函数返回时会把之前给这个函数创建的栈帧`销毁`，以释放空间。

销毁时先把`栈指针`（sp）移动到此时`栈基址`（bp）的位置，此时`栈指针`和`栈基址`都指向同样的位置。

栈变化过程：

![](https://image.coder.cat/stack5.png)



现在栈顶刚好是我们在创建栈帧时保存的调用者`栈帧`的`栈基址`，现在把它出栈至`栈基址`（bp），得到下图中的栈结构：

![](https://image.coder.cat/stack7.png)

到目前位置`被调用者`的栈帧已经被销毁空间得到释放，但是函数的返回步骤并没有完，`调用者`的栈帧中还保存者`返回地址`，此时需要把`返回地址`出栈至`程序计数器`（PC）以恢复到原来的位置继续执行，返回后的栈帧：

![](https://image.coder.cat/stack6.png)


**C/C++中销毁栈帧并不会清空被销毁栈帧中的数据。**

### 7. C语言函数栈帧实例

> 我们通过把一段具有函数调用的C语言代码编译成汇编，逐步分析函数栈帧生命周期的完整变化过程。



有如下C语言代码：

```c
long callee(long arg1, long arg2, long arg3, long arg4, long arg5, long arg6, long arg7, long arg8) {
    return arg7 + arg8;
}

int main() {
    long a = 7;
    long b = 8;
    callee(1, 2, 3, 4 ,5 ,6, a, b);
    return 0;
}
```

代码中`callee`函数有8个参数分别是`arg1~arg8`，它返回`arg7`和`arg8`相加后的结果。由于我们的代码是运行在`X64`的机器上，所以`arg1~arg6`会通过寄存器来传递，`arg7`和`arg8`通过栈来传递。`main`中定义了两个局部变量`a`和`b`，它对`callee`发起调用，局部变量`a,b`分别对应`callee`函数的`arg7,arg8`。

将上面C语言代码编译成汇编，把由编译器产生的其他与我们分析函数栈帧不相关的指令删除，得到如下指令（根据编译器版本以及操作系统的不同编译出的汇编指令会有所差异，这里使用的编译器和操作系统分别是`gcc9.0`和`ubuntu 20.04 x-64`）：

```ASM
callee:
    pushq	%rbp
    movq	%rsp, %rbp
    movq	%rdi, -8(%rbp)
    movq	%rsi, -16(%rbp)
    movq	%rdx, -24(%rbp)
    movq	%rcx, -32(%rbp)
    movq	%r8, -40(%rbp)
    movq	%r9, -48(%rbp)
    movq	16(%rbp), %rdx
    movq	24(%rbp), %rax
    addq	%rdx, %rax
    popq	%rbp
    ret
main:
    pushq	%rbp
    movq	%rsp, %rbp
    subq	$16, %rsp
    movq	$7, -16(%rbp)
    movq	$8, -8(%rbp)
    pushq	-8(%rbp)
    pushq	-16(%rbp)
    movl	$6, %r9d
    movl	$5, %r8d
    movl	$4, %ecx
    movl	$3, %edx
    movl	$2, %esi
    movl	$1, %edi
    call	callee
    addq	$16, %rsp
    movl	$0, %eax
    leave
    ret
```

指令中的`callee:`和`main:`表示的是为它下面的指令取一个名字，可以理解为函数名。

**在`X64`中`栈指针`和`栈基址`分别叫`rsp,rbp`。**

我们逐步分析这些指令对堆栈的影响，首先是`main`的第前两行指令：

```asm
pushq	%rbp
movq	%rsp, %rbp
```

实际上`main`函数是被系统内一个叫做`_start`的函数所调用，所以第1条指令将`调用者`_start的`栈基址`压栈保存，第2条指令移动`栈基址`使它指向和`栈指针`同样的位置。

栈变化过程（在一开始我们`栈指针`和`栈基址`指向`_start`的栈帧，这里没有画出`_start`的栈帧也就没有标注它们）：

![](https://image.coder.cat/stack22.png)



初始化局部变量并准备`callee`的后两个参数：

```asm
subq	$16, %rsp
movq	$7, -16(%rbp)
movq	$8, -8(%rbp)
pushq	-8(%rbp)
pushq	-16(%rbp)
```

第1条指令中的`subq`是减法指令，这里用于把`栈指针`减去16，使它向低地址移动来给局部变量`a,b`分配16字节的空间（long占8个字节）。

第2~3条指令中的`movq`是数据移动指令，在这里它通过对`栈基址`进行适当偏移来对`a,b`赋值。例如`movq $7, -16(%rbp)`表示把7放到相对于`栈基址`-16的内存中。下图中可以看到这两条指令执行完以后`-16`和`-8`的位置刚好放置了变量`a,b`。

第4~5条指令把栈帧中`a,b`的值复制一份然后把它们压栈，这是为了准备函数`callee`的后2个参数`arg7`与`arg8`。

栈变化过程（图中右侧的数字表示基于`栈基址`的偏移量，每个格子8字节，由于栈空间是向低地址发展的，所以相对于`栈基址`上面内存的偏移量是负的）：

![](https://image.coder.cat/stack23.png)





把`callee`的前6个参数`arg1~arg6`存放在寄存器中：

```asm
movl	$6, %r9d
movl	$5, %r8d
movl	$4, %ecx
movl	$3, %edx
movl	$2, %esi
movl	$1, %edi
```


开始调用`callee`：

```asm
call	callee
```

这条指令对应了两个操作，首先将它下面一条指令的地址也就是`addq $16, %rsp`的地址（返回地址）压入栈中，随后修改`程序计数器`（PC）为`callee`的第一条指令的地址，最后CPU就从`callee`处开始执行。

这条指令执行后的栈：

![](https://image.coder.cat/stack24.png)

现在CPU从`callee`开始执行：

```asm
pushq	%rbp
movq	%rsp, %rbp
```

先压入`main`栈帧的`栈基址`，然后移动`栈基址`使它指向和`栈指针`同样的位置。此时产生了`callee`的栈帧：

第2条指令使`栈基址`发生了改变，相应的右图中基于`栈基址`的偏移量也需要发生变化（由于栈空间是向低地址发展的，所以相对于`栈基址`下面内存的偏移量是正的）：

![](https://image.coder.cat/stack25.png)



复制前6个参数到栈帧中：

```asm
movq	%rdi, -8(%rbp)
movq	%rsi, -16(%rbp)
movq	%rdx, -24(%rbp)
movq	%rcx, -32(%rbp)
movq	%r8, -40(%rbp)
movq	%r9, -48(%rbp)
```

这6个寄存器`rdi,rsi,rdx,rcx,r8,r9`分别存放了`callee`的前6个参数，现在将它们从寄存器中复制到`callee`自己的栈帧中。我对这个操作有点迷，为啥还需要复制呢，直接从寄存器中取出来使用不就行了吗？我想可能是为了腾出寄存器吧。

执行之后的栈结构：

![](https://image.coder.cat/stack26.png)

执行到这里奇怪的事情发生了，`栈指针`并没有继续向低地址移动，让它指向栈顶的位置。其实这里是编译器的优化，`栈指针`的目的是为了确定被调用函数的`栈基址`，由于`callee`没有再继续调用其他任何函数，因此也无需修改`栈指针`。

执行相加：

```asm
movq    16(%rbp), %rdx
movq	24(%rbp), %rax
addq	%rdx, %rax
```

将`arg7`与`arg8`相加，然后把结果放在`rdx`寄存器，`mian`函数可以访问`rdx`寄存器来获取返回值，以此来达到函数返回值传递的目的。



返回到`main`：

```asm
popq	%rbp
ret
```

恢复`栈基址`并跳转到返回地址处开始继续执行。

栈变化过程：

![](https://image.coder.cat/stack27.png)





返回到`_start`：

```asm
addq	$16, %rsp
movl	$0, %eax
leave
ret
```

第1条指令中的`addq`是加法指令，这里用于把`栈指针`加上16，使它向高地址移动以此来释放`arg7,arg8`的内存。通过这一步可以发现，函数执行完后会立马释放参数的栈内存。

第2条指令把`main`的返回值0放入到`eax`寄存器中。

第3条指令`leave`隐含执行了两个操作，它等价与下面两条指令：

```asm
movq	%rbp, %rsp
popq	%rbp
```

先修改`栈指针`使它与`栈基址`指向同样的位置，这一步主要用于释放局部空间，然后恢复`栈基址`。此时`栈指针`和`栈基址`就分别指向了`_start`的栈帧。

到这里我们发现`main`和`callee`的返回过程不一样，这是由于在`callee`一开始没有修改`栈基址`，所以返回的时候也就不需要再对它进行恢复。由此我们可以得出一个结论：如果某个函数调用了其他函数和没有调用其他函数，它们在返回时的过程有略微的不一致。

第4条指令`ret`使CPU返回到`_start`中去执行，最后一切又恢复了平静。

栈变化过程：

![](https://image.coder.cat/stack28.png)



**最后我们发现数据仍然还保存在栈中，因为释放栈空间并不会修改里面的数据，只是对`栈指针`和`栈基址`做了移动。**

### 8. quiz 一个有趣的例子

这是一个C语言的例子：

```c
void init_array() {
    int arr[10];
    for (int i = 0; i < 10; ++i) {
        arr[i] = i;
    }
}

void print_array() {
    int arr[10];
    for (int i = 0; i < 10; ++i) {
       printf("%ld\t", arr[i]);
    }
}

int main() {
    init_array();
    print_array();
}
```

代码中`init_array`和`print_array`各自有一个长度为10的局部数组`arr`。`init_array`把它内部的`arr`初始化成0~9，print_array把它内部的`arr`遍历输出到控制台，然后在`main`函数中对它们进行调用。

`print_array`执行后输出到控制台：

```bash
0	1	2	3	4	5	6	7	8	9
```

结果有点让人疑惑，似乎这两个函数有着某种关系。

现在取消对`init_array`的调用，再看下结果：

```bash
177988	32765	5497827	21857	2157688	32518	9257904	21857	0	0
```

这次输出了随机值，因为C/C++并不会初始化内存中的值，这些值都是上一次使用这些内存的程序留下的。

对比两次结果发现`init_array`确实对`print_array`中的数组`arr`产生了影响。`init_array`和`print_array`中的`arr`看起来都各自独立，为什么会出现这种情况？

来看下这两个函数各自在返回前的栈帧结构：

![](https://image.coder.cat/stack29.png)

可以发现它们的栈帧结构和大小完全一样。`init_array`执行完之后它的栈帧被销毁，但是原来的值还在内存中。当`print_array`执行时继续给它分配了同一块内存且栈帧结构也一样，这样就把`init_array`在内存中遗留的数据拿到了。

我们对代码稍作修改，让这两个函数都把各自`arr`在内存中的地址输出到控制台：

```c
void init_array() {
    int arr[10];
    printf("%p\n", arr);
}

void print_array() {
    int arr[10];
    printf("%p", arr);
}

int main() {
    init_array();
    print_array();
}    
```

控制台结果：

```bash
0x7ffd2aaf3ff0
0x7ffd2aaf3ff0
```

结果再一次印证了这两个`arr`被放到了是同一块栈内存中。所以`print_array`输出了原先在`init_array`中`arr`的值。


### 10 .手动修改栈帧数据

> 我们可以获取某一局部变量在内存中的地址，然后对该地址进行偏移来修改栈中其他位置的数据。只要我们对栈结构足够了解，就可以修改你想修改的数据。



## 修改局部存储

> 由于C/C++不检查数组越界访问，因此我们可以借助这一特点来修改栈帧中的数据。



有如下代码：

```c
int main() {
    long foo = 10;
    long arr[2] = {1, 2};
    arr[-1] = 20;
    printf("foo is %ld", foo);
    return 0;
}
```

代码中数组`arr`和变量`foo`它们在栈中是连续存放的：

![](https://image.coder.cat/stack30.png)

图中还发现变量`foo`放在了更低的地址上，所以在修改` arr[-1]`时也是修改变量`foo`。

代码输出到控制中的结果：

```bash
foo is 20
```



### stack canary

这个例子的栈帧最底部多了一个`canary`（译为金丝雀），它用来防止栈溢出攻击。在进入函数时会先往`返回地址`的上面放置一个任意值，然后在返回时检查这个值是否有被修改，如果被修改就说明栈帧中其他数据也可能被修改过，然后触发相关异常。这个值就叫`canary`。

只有在函数内有指针操作时，编译器才会生成`canary`相关指令。我们这里使用了数组，数组操作在C/C++中其实也是指针操作，所以这里生成了`canary`。



## 修改返回地址

> 同样的方式我们也可以对一个内存地址进行适当偏移来修改函数的返回地址，从而控制函数返回路径。



有如下代码：

```c
void bar() {
    printf("This is bar!\n");
}

void foo() {
    printf("This is foo!\n");
    long arr[2] = {1, 2, 3};
    arr[5] = bar;
}

int main() {
    foo();
    return 0;
}    
```

这个例子中在数组`arr[5]`的位置存放了返回地址，至于为什么是5，我们先来看下在`foo`返回前的栈帧结构（绿色是main的栈帧，蓝色是foo的栈帧）：

![](https://image.coder.cat/stack31.png)

现在我们从`arr[0]`往下数，刚好在`arr[5]`的位置放置了函数返回地址，我们把它修改成函数`bar`的地址（C/C++中函数名表示函数第一条指令的地址）然后执行，于是得到如下控制台结果：

```bash
This is foo!
This is bar!
段错误 (核心已转储)
```

结果如我们所愿这里成功跳转到了`bar`，但也收获了一个`段错误`。为什么会发生这个`段错误`呢？我们继续看下在`bar`运行前后的栈帧变化（绿色是main的栈帧，蓝色是bar的栈帧）：

![](https://image.coder.cat/stack32.png)



上面左图是在`ret`指令执行前的栈帧状态，这个时候`栈指针`和`栈基址`已经恢复到调用`foo`前的状态，右图是在`ret`指令执行后，此时`bar addr`已经被出栈，随后跳转到`bar`去执行，`bar`也创建了自己的栈帧。这个时候我们想像一下，当`bar`返回时会发生什么？显然它会把`_start rbp`做为`返回地址`，`_start rbp`不是一个指令的地址，当CPU把它当成一个指令地址去寻找指令时，就发生了`段错误`。



**这两个例子中我们都修改了栈帧数据，但是并没有异常发生，`canary`好像没有起到作用。之所以没有触发异常是因为我跳过了`canary`没有修改它，`canary`可以防止修改连续的一段空间，如果这段空间刚好有`canary`，就会触发异常。**



**这两个例子也说明了数组越界访问可能导致非常严重的bug**



## main函数执行前完成什么工作？

main函数执行之前主要是初始化系统资源

1. 设置栈指针
2. 初始化static静态和global全局变量，即data段内容
3. 将未初始化部分的赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL，等等，即.bss段的内容
4. 运行全局构造器，估计是C++中构造函数之类
5. 将main函数的参数，argc，argv等传递给main函数，然后才真正运行main函数
