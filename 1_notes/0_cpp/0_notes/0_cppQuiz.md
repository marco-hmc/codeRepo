## cpp quiz

### 1. grammar

#### 1.1 c++中NULL和nullptr的区别

* 在C语言中，NULL通常被定义为：#define NULL ((void *)0)

* 所以NULL实际上是一个空指针，如果在C语言中写入以下代码，编译是没有问题的，因为在**C语言中把空指针赋给int和char指针的时候，发生了隐式类型转换，把void指针转换成了相应类型的指针**

  ```c++
  int  *pi = NULL;
  char *pc = NULL;
  ```

* 以上代码如果使用C++编译器来编译则是会出错的，因为C++是强类型语言，void*是不能隐式转换成其他类型的指针的，所以实际上编译器提供的头文件做了相应的处理
  ```c++
  #ifdef __cplusplus
  #define NULL 0
  #else
  #define NULL ((void *)0)
  #endif
  ```

* 但是NULL为0的时候，会出现类型判断错误
    ```c++
    void foo(int);
    void foo(char*);

    foo(NULL);  // 调用哪个函数？
    ```

#### 1.2 为什么std::thread传递引用的时候要用std::ref


#### 1.3 c/c++是转成汇编语言的. 那汇编语言是如何处理自定义类型的?
汇编语言本身并没有自定义类型的概念,它只知道字节和地址.当你在C++中定义一个类型(例如,一个结构体或类),编译器会根据你的定义来决定如何在内存中布局数据,以及如何生成对应的汇编代码来访问这些数据.

例如,如果你定义了一个包含两个整数的结构体:

```cpp
struct MyStruct {
    int a;
    int b;
};
```

编译器会知道这个结构体需要8个字节的空间(在大多数现代系统上,一个`int`需要4个字节).当你创建一个`MyStruct`对象并访问它的成员时,编译器会生成对应的汇编代码来读取或写入这些地址.

但是,这个过程是由编译器完成的,汇编语言本身并不知道`MyStruct`这个类型,它只知道如何处理字节和地址.这就是为什么在汇编语言中,你需要手动管理所有的内存布局和数据访问.

#### 1.4 通过指针访问和直接访问的区别是什么？
```c++
    struct Point3d{};
    Point3d origin;
    *pt = &origin;
    origin.x=0.0; // (1)
    pt->x=0.0; // (2) 
```
(1) `origin.x=0.0;` 和 (2) `pt->x=0.0;` 这两种方式都是用来设置`Point3d`对象`origin`的`x`成员的值为`0.0`.它们的区别在于使用的方式不同,从编译器的角度来看:

* (1) `origin.x=0.0;` 这种方式是直接通过对象名和成员名来访问和修改成员的值.编译器在编译时期就能确定`origin`的内存地址,然后通过偏移量找到`x`成员的位置,直接在这个位置写入`0.0`.

* (2) `pt->x=0.0;` 这种方式是通过一个指向对象的指针来访问和修改成员的值.`pt`是一个指向`origin`的指针,`pt->x`表示的是`pt`所指向的对象的`x`成员.在编译时期,编译器并不能确定`pt`所指向的内存地址,它需要在运行时期读取`pt`的值(也就是`origin`的地址),然后通过偏移量找到`x`成员的位置,再在这个位置写入`0.0`.

总的来说,这两种方式的效果是相同的,它们都会设置`origin`的`x`成员的值为`0.0`.但是从编译器的角度来看,直接访问成员的方式更简单,效率也稍微高一些,因为它不需要在运行时期读取指针的值.然而,通过指针访问成员的方式更灵活,它可以动态地访问不同的对象,这在处理数组和动态内存分配时非常有用.

在第二种情况中,`pt->x=0.0;`,`pt`是一个指针,它存储的是`origin`对象的内存地址.编译器在编译时期并不能确定`pt`所指向的具体内存地址,因为这个地址是在运行时期由操作系统分配的.因此,当你通过`pt`来访问`x`成员时,编译器需要在运行时期读取`pt`的值(也就是`origin`的地址),然后通过这个地址和`x`成员的偏移量来找到`x`成员的具体位置.

这就是为什么在运行期需要读取指针的值.这种机制使得指针可以动态地指向不同的对象,这在处理动态内存分配/数组和数据结构(如链表和树)时非常有用.

#### 1.5 一般哪些函数可以使用noexcept?
在C++中,`noexcept`关键字用于指定一个函数不会抛出任何异常.这对于提高代码的性能和可靠性非常有用.以下是一些常见的可以使用`noexcept`的函数:
1. 析构函数:析构函数通常不应抛出任何异常,因为如果在析构函数中抛出异常,可能会导致程序的未定义行为.
2. 移动构造函数和移动赋值操作符:这些函数通常应该被标记为`noexcept`,因为它们通常只涉及指针和基本类型的转移,不应抛出异常.此外,标记为`noexcept`的移动操作可以被标准库容器如`std::vector`更有效地使用.
3. 交换函数:交换函数(如`std::swap`)通常应该被标记为`noexcept`,因为它们通常只涉及指针和基本类型的转移,不应抛出异常.
4. 其他不会抛出异常的函数:如果你知道一个函数不会抛出异常,你应该使用`noexcept`关键字.这可以帮助编译器优化代码,并向其他开发者明确表明该函数不会抛出异常.
在你提供的代码中,移动构造函数和移动赋值操作符被标记为`noexcept`,这是因为它们只涉及指针和基本类型的转移,不应抛出异常.

#### 1.6 c++怎么定义隐式转换规则
在C++中,隐式转换(也称为自动类型转换)是由编译器自动进行的.这些转换规则是由C++语言规定的,例如从int到double的转换,或者从派生类到基类的转换.

然而,你也可以为你的自定义类型定义隐式转换规则.这可以通过定义转换函数来实现.转换函数是一种特殊的成员函数,它可以将一个类的对象转换为其他类型的对象.

例如,假设你有一个名为`MyClass`的类,你想让它可以隐式转换为`int`类型.你可以在`MyClass`中定义一个名为`operator int()`的转换函数:

```cpp
class MyClass {
public:
    operator int() const {
        // 在这里返回一个int值
        return 0;
    }
};
```

然后你就可以这样使用它:

```cpp
MyClass obj;
int i = obj;  // 隐式转换
```

需要注意的是,虽然隐式转换看起来很方便,但它也可能导致一些意想不到的问题,因为它可能在你不知情的情况下发生.因此,一般建议尽量避免使用隐式转换,或者至少要确保你清楚地知道它何时会发生以及它的效果是什么.


### 2. 编译器

#### 2.1 引用是怎么实现的?
在 C++ 中,当我们说"引用"时,我们通常不会说它被"拷贝",因为引用本身并不占用任何存储空间,它只是一个别名.当你将一个对象作为引用传递给函数时,实际上并没有发生任何拷贝操作.函数接收的是对原始对象的直接引用,而不是任何形式的拷贝.

然而,从底层实现的角度来看,引用在某种程度上可以被视为一个常量指针.当你创建一个引用并将其初始化为一个对象时,编译器会在底层创建一个指向该对象的常量指针.这个指针在初始化后就不能改变,它将一直指向初始化时的那个对象.因此,当你通过引用访问对象时,实际上是通过这个常量指针访问的.

但是,这并不意味着引用是通过拷贝指针来实现的.引用的实现细节可能因编译器和平台的不同而不同,但是从语言的角度来看,引用并不涉及拷贝操作.

#### 2.2 c++的内存空间模型
* 一个类的成员函数并不是存储在每个类的实例中的.成员函数只有一份代码,它们存储在内存的代码段中,而不是每个对象的内存空间中.
* 每个对象中存储的是数据成员,而成员函数通过隐式参数this来访问这些数据成员.
* 除了数据成员，还有vptr
