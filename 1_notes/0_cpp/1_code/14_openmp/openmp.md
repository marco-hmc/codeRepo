  3. https://github.com/parallel101/course/tree/master
  4. https://github.com/jiayaozhang/OpenVDB_and_TBB

## openmp

### 1. concepts

* **OpenMP 是什么**
    OpenMP（Open Multi-Processing）是一个用于多平台共享内存并行编程的 API，主要用于 C、C++ 和 Fortran 语言。它通过编译器指令、库函数和环境变量来实现并行编程。OpenMP 的核心思想是通过简单的编译器指令（pragma）来标记并行代码块，编译器会自动生成相应的多线程代码。

* **OpenMP 是哪一层次的优化？**
    OpenMP 主要在编译器层面实现多线程，通过编译器指令和库函数，将并行代码转换为多线程代码，最终由操作系统的线程调度器管理线程的执行。编译器会根据 `#pragma omp` 指令生成相应的多线程汇编代码。由于编译器可以进行各种优化，因此在大多数情况下，使用 OpenMP 实现的多线程方法性能会更快一些。

    换句话说，预处理阶段编译器还是会保留 `#pragma omp` 命令。在编译阶段，编译器才会根据 `#pragma omp` 生成相应的多线程汇编代码。

* **OpenMP 会比手动实现的线程池快吗？**
    OpenMP 是否比手动实现的线程池快，取决于具体的应用场景和实现细节。以下是一些考虑因素：
    - 开发效率：OpenMP 提供了高层次的并行编程接口，开发效率通常高于手动实现的线程池。
    - 性能优化：手动实现的线程池可以针对特定应用进行优化，可能在某些场景下性能优于 OpenMP。
    - 负载均衡：OpenMP 内置了负载均衡机制，可以自动将工作分配给不同的线程，而手动实现的线程池需要自行管理负载均衡。
    - 可维护性：OpenMP 代码通常更简洁、易读、易维护，而手动实现的线程池代码可能更复杂。

* **OpenMP 内部有线程池的概念吗？**
    OpenMP 运行时库通常会维护一个线程池，以减少线程创建和销毁的开销。线程池中的线程可以重复使用，以提高性能。OpenMP 线程池的一个强大之处在于更强大的线程调度和负载均衡。

    一般而言，大部分自定义实现的线程池都是静态调度的。而 OpenMP 可以做到动态调度和自适应调度。

    - 静态调度：在静态调度中，迭代空间被均匀地划分给所有线程。每个线程在程序开始时就知道自己要处理的迭代范围。
    - 动态调度：在动态调度中，迭代空间被划分成多个块，线程动态地获取块进行处理。这样可以更好地平衡负载，特别是在迭代时间不均匀的情况下。
    - 自适应调度：OpenMP 还支持自适应调度策略，根据运行时的负载情况动态调整调度策略。

* **怎么启用 OpenMP？**
    - CMake 工程：使用 `find_package(OpenMP REQUIRED)`。
    - VS 工程：项目 -> 属性 -> 配置属性 -> C/C++ 选项 -> 语言 -> OpenMP 支持 -> 设置为“是 (/openmp)”
    如果 VS 工程是由 CMake 工程生成的，则会自动带上 OpenMP。

* **总结**
    常规使用情况下，OpenMP 总能比手动实现的多线程更快，这一方面是因为 OpenMP 是编译器层面的，因此编译器更方便做各种优化。另一方面是大部分手动管理线程的负载均衡做得比较差劲，基本都是开了多个线程均分任务，没有考虑到不同任务的耗时不一样，动态调整的能力。除此之外，OpenMP 通常实现起来，会更简洁。

    但是手动实现的多线程，往往有更丰富的同步原语，如 `std::mutex`、`std::condition_variable` 等等。以及可以处理一些 `std::async` 和 `std::future` 等等异步任务。

    总结，OpenMP 更多用于一些重计算的库上，比如高性能计算，科学计算和工程模拟，深度学习/机器学习，图像处理等场景。在应用层软件中，OpenMP 也会用于多媒体处理（音视频解码）、游戏开发（更多是物理引擎）、图形渲染等等。

    对于其他一般的应用场景上，OpenMP 和多线程的性能差距一般不是瓶颈。而且应用层软件可能需要更灵活的同步原语，需要处理一些异步任务，要有 `future` 或者 `async` 概念。这些都是 OpenMP 做不到的。
