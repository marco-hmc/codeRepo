> todo: 要补充柯里化，偏函数内容、mapReduce内容
> 狭义地函数式编程还是比较强调纯函数，这里对纯函数那种函数式编程讲解不够深入。

## 函数对象和函数式编程

### 1. 什么是函数对象
在 C++ 中，函数对象（也称为仿函数）是一个行为类似函数的对象。任何类如果重载了 `operator()`，那么该类的对象就可以作为函数来使用，这样的对象就被称为函数对象。

函数对象的优点包括：

1. **内联优化**：由于函数对象是类的对象，其操作符重载函数通常会被编译器内联，这可以消除函数调用的开销，提高性能。

2. **状态保持**：函数对象可以有自己的成员变量，这意味着它们可以保持状态。这对于需要在多次调用之间保持状态的操作非常有用。

3. **灵活性**：函数对象可以被参数化。例如，你可以在构造函数中传入参数来改变函数对象的行为。这种灵活性使得函数对象可以很容易地适应不同的需求。

以下是一个简单的函数对象的例子：

```cpp
class Add {
public:
    Add(int x) : x_(x) {}

    int operator()(int y) const {
        return x_ + y;
    }

private:
    int x_;
};

int main() {
    Add add_five(5);
    std::cout << add_five(6);  // 输出：11
    return 0;
}
```

在这个例子中，`Add` 是一个函数对象，它接受一个参数 `x`，然后返回 `x + y`。我们可以像调用函数一样调用 `add_five(6)`，并得到结果 `11`。

#### 1.1 stl中的函数对象有哪些？
STL（Standard Template Library，标准模板库）中包含了一些预定义的函数对象，这些函数对象主要分为两类：算术运算函数对象和关系运算函数对象。

**算术运算函数对象**：

- `std::plus`：加法函数对象
- `std::minus`：减法函数对象
- `std::multiplies`：乘法函数对象
- `std::divides`：除法函数对象
- `std::modulus`：取模函数对象
- `std::negate`：取反函数对象

**关系运算函数对象**：

- `std::equal_to`：等于函数对象
- `std::not_equal_to`：不等于函数对象
- `std::greater`：大于函数对象
- `std::less`：小于函数对象
- `std::greater_equal`：大于等于函数对象
- `std::less_equal`：小于等于函数对象

这些函数对象都是模板，可以用于任何类型，只要该类型支持对应的运算符。例如，`std::less<int>` 是一个可以比较两个整数大小的函数对象。

#### 1.2 stl的函数对象怎么用？
`std::less` 是一个函数对象，它提供了一种方式来比较两个对象。它的行为类似于 `<` 运算符。以下是一个 `std::less` 的使用例子：

```cpp
#include <iostream>
#include <functional>

int main() {
    std::less<int> less;

    std::cout << std::boolalpha;  // 输出 bool 值为 true 或 false 而不是 1 或 0
    std::cout << "less(10, 20): " << less(10, 20) << std::endl;  // 输出：true
    std::cout << "less(20, 10): " << less(20, 10) << std::endl;  // 输出：false
    std::cout << "less(10, 10): " << less(10, 10) << std::endl;  // 输出：false

    return 0;
}
```

在这个例子中，我们创建了一个 `std::less<int>` 的对象 `less`，然后使用它来比较两个整数的大小。`less(10, 20)` 返回 `true`，因为 10 小于 20；`less(20, 10)` 返回 `false`，因为 20 不小于 10；`less(10, 10)` 返回 `false`，因为 10 不小于 10。

### 2. 函数式编程
#### 2.1 什么是函数式编程？
函数式编程最本质的是将函数作为一等公民处理，即函数可以作为变量传递。一个函数的输入和输出也可以是另一个函数。
基于此，函数式编程有两种主要的实践方式：

第一种：强调纯函数和不可变数据
* 特点
  * 以 lambda 演算为理论基础，指导编译器理解函数式编程。
  * 函数不带状态，也不可变。非常利于并行计算，也利于测试。因为只需要关注输入和输出就好了。
  * 可能不容易写好，但是写好之后比较少 bug。
  * 纯函数：不依赖外部状态，也不修改外部状态。对于相同的输入，总是返回相同的输出。
  * 不可变数据：数据一旦创建就不能修改，所有的操作都返回新的数据。
* 好处
  **易于测试和调试**：
   - 纯函数不依赖外部状态，也不修改外部状态，因此测试和调试变得更加简单。你只需要关注输入和输出，而不需要担心外部环境的影响。
  **并行计算友好**：
   - 由于纯函数没有副作用，可以安全地在多个线程中并行执行，而不需要担心数据竞争和同步问题。这使得并行计算变得更加容易和高效。
  **代码可预测性高**：
   - 纯函数对于相同的输入总是返回相同的输出，这使得代码行为更加可预测，减少了意外情况的发生。


第二种：高阶函数和条件式编程
* 特点
  * 高阶函数：可以接受一个或多个函数作为参数，或返回一个函数。
  * 条件式编程：例如用于回调函数/异步函数，将一个函数传入到某个时机去执行。
  * 条件查询：方便传入一个函数进行过滤操作。
  * 例如，`map`、`filter` 和 `reduce` 等高阶函数在处理数据时非常有用。
* 好处
  **代码简洁和可读性高**：
   - 高阶函数和条件式编程使得代码更加简洁和易读。通过将函数作为参数传递，可以减少重复代码，提高代码的可读性。
  **提高代码复用性**：
   - 高阶函数允许你编写通用的函数逻辑，并通过传递不同的函数来实现不同的功能。这提高了代码的复用性，减少了重复代码。
  **灵活性和扩展性**：
   - 条件式编程使得代码更加灵活，可以根据不同的条件执行不同的操作。通过传递不同的回调函数，可以轻松扩展代码的功能。
  **简化异步编程**：
   - 条件式编程特别适用于异步编程，通过传递回调函数，可以简化异步操作的实现，使代码更加直观和易于理解。
  **方便数据处理**：
   - 高阶函数如 `map`、`filter` 和 `reduce` 在处理数据时非常有用。它们提供了简洁的语法来进行数据转换、过滤和聚合操作，提高了代码的效率和可读性。


### 97. 例子

```c++
// 简单的体现不可变特点的函数式编程
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> data{1, 2, 3, 4, 5};

    // lambda函数是纯函数，没有状态。方便搭配std::execution::par完成并行。
    std::transform(std::execution::par, data.begin(), data.end(), data.begin(),
                   [](int x) { return x * 2; });

    for (const auto &val : data) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

```c++
```

```c++
#include <iostream>
#include <vector>
#include <algorithm>

void applyFunction(const std::vector<int>& data, const std::function<void(int)>& func) {
    for (const auto& val : data) {
        func(val);
    }
}

int main() {
    std::vector<int> data{1, 2, 3, 4, 5};
    applyFunction(data, [](int x) {
        std::cout << x * 2 << " ";
    });
    std::cout << std::endl;

    return 0;
}
/*
`applyFunction` 实际上等同于 `std::for_each`。`std::for_each` 的参数之一就是一个函数。

相较于传统的 `for` 循环写法，使用 `std::for_each` 可以让代码更加简洁和易读。你不需要阅读整个循环体就能理解代码的意图。

### `for` 循环的灵活性

`for` 循环具有很高的自由度，可以使用 `continue` 和 `break` 控制循环流程，也可以对数据进行变形操作，或者从数据中判断是否存在特定元素。

### 函数式编程的限制

函数式编程在某些方面限制了这种灵活性：
- **没有 `continue` 和 `break`**：函数式编程中没有直接对应的 `continue` 和 `break` 语句。
- **统一的操作方式**：如果需要对数据进行变形操作，使用 `std::transform`；如果需要判断数据中是否存在特定元素，使用 `std::any_of` 或 `std::all_of`。

### 优点

尽管函数式编程限制了一些灵活性，但它也带来了许多优点：
- **提高可读性**：通过使用标准库提供的高阶函数（如 `std::transform` 和 `std::any_of`），代码的意图更加明确，提升了可读性。

*/
```

### 98. 总结
* 并行
函数式编程强调不可变性，因此不应将 `std::for_each` 视为一个传统的循环体。传统的循环体是一个迭代器接一个迭代器地顺序运行，而函数式编程则可以看作是对所有迭代器同时执行一个操作。这个操作可以是串行的，也可以是并行的，这取决于具体的执行策略。

在 C++17 中，引入了 `std::execution::par`，使得这些操作可以方便地并行执行。编译器可以根据执行策略优化代码，从而提高性能。

如果操作中存在线程安全问题，可以在操作中使用加锁等方式来确保线程安全。例如，可以使用 `std::mutex` 来保护共享数据。

* 可读
相较于传统的 `for` 循环实现，函数式编程明确了操作的目的，提升了代码的可读性。

在 `for` 循环中，操作可能会包含 `break` 语句、对集合进行变形操作，或者在集合中查找符合条件的元素。而函数式编程则通过使用特定的高阶函数明确了操作的意图。例如：

- **变形操作**：使用 `std::transform`。
- **查找操作**：使用 `std::any_of`、`std::all_of` 或 `std::find_if`。

此外，对于复杂的操作，通常会对 lambda 表达式进行命名，通过函数命名来解释操作的目的。这使得代码更加自解释，减少了对注释的依赖。

在传统的 `for` 循环中，开发者往往需要依赖注释来解释操作的目的。然而，注释通常容易被忽略或遗忘，导致代码难以阅读和理解。


### 99. quiz

#### 1. 函数对象和lambda有什么本质不同吗？两者都可以保存状态变量
函数对象和 lambda 表达式在 C++ 中都可以用来封装行为，并且都可以保存状态。但是，它们在使用方式和适用场景上有一些不同：

1. **定义方式**：函数对象是通过定义一个类并重载 `operator()` 来创建的，而 lambda 表达式是通过一个简洁的语法直接在代码中创建的。

2. **状态保存**：函数对象可以通过成员变量来保存状态，而 lambda 表达式则通过捕获列表来保存状态。函数对象的状态保存更为直观和灵活，而 lambda 表达式的状态保存更为简洁和方便。

3. **复用性**：函数对象可以在定义后在多处复用，而 lambda 表达式通常在定义后立即使用，并不易于复用。

4. **复杂性**：对于复杂的行为，使用函数对象可能更为合适，因为你可以利用类的所有特性（如私有成员、成员函数等）来组织你的代码。而对于简单的行为，使用 lambda 表达式可能更为合适，因为它的语法更为简洁。

总的来说，函数对象和 lambda 表达式在某些方面是相似的，但是它们在使用方式和适用场景上有一些不同。你应该根据你的具体需求来选择使用哪一种。

#### 2. 函数对象、lambda、普通函数，性能上有什么不同吗？编译器行为有什么区别？
在大多数情况下，函数对象、lambda 表达式和普通函数的性能是相似的。这是因为现代编译器通常会对这些构造进行优化，例如内联函数调用，以减少函数调用的开销。

以下是这三种构造在编译器行为上的一些区别：

1. **函数对象**：函数对象是类的对象，其操作符重载函数通常会被编译器内联，这可以消除函数调用的开销，提高性能。此外，函数对象可以有自己的成员变量，这意味着它们可以保持状态。

2. **lambda 表达式**：lambda 表达式在编译时会被转换为函数对象，因此它们的性能特性和函数对象相似。lambda 表达式的一个优点是它们可以捕获周围的环境，这使得它们在编写闭包时非常有用。

3. **普通函数**：普通函数在编译时会被转换为机器代码，它们不能保持状态（除非使用静态变量），也不能捕获周围的环境。但是，普通函数可以被声明为内联函数，提示编译器进行内联优化。

总的来说，函数对象、lambda 表达式和普通函数在性能上的差异通常可以忽略不计。你应该根据你的具体需求和编程风格来选择使用哪一种。在考虑性能时，你应该首先关注算法的复杂性，然后再考虑这些低级的优化。


