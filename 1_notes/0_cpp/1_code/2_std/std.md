* 容器的迭代器有哪些?
在C++标准库中,每种容器都有与之关联的迭代器.以下是一些常见的容器和它们的迭代器:

1. `std::vector`/`std::string`/`std::deque`:这些容器提供了随机访问迭代器,这意味着你可以在常数时间内前进或后退任意步数.你可以使用`+`/`-`操作符,也可以使用`<`/`>`等比较操作符.

2. `std::list`/`std::set`/`std::multiset`/`std::unordered_set`/`std::unordered_multiset`:这些容器提供了双向迭代器,这意味着你可以在常数时间内前进或后退一步.

3. `std::forward_list`:这个容器提供了前向迭代器,这意味着你只能在常数时间内前进一步.

4. `std::map`/`std::multimap`/`std::unordered_map`/`std::unordered_multimap`:这些容器也提供了双向迭代器.

5. `std::array`:这个容器提供了随机访问迭代器.

每种迭代器都提供了一组操作,包括解引用(`*`)/前进(`++`)和(对于双向和随机访问迭代器)后退(`--`).随机访问迭代器还提供了额外的操作,如跳过多个元素和比较两个迭代器的相对位置.

注意,不同类型的迭代器提供的功能是不同的,例如,你不能对一个只提供前向迭代器的容器使用`--`操作.



* 随机访问迭代器的原理是什么?

* 容器的线程安全是怎么保证的?如何判断一个容器是否是线程安全的?
容器的线程安全性是指在多线程环境中使用容器时,是否能够保证操作的原子性和正确性.不同的容器在多线程环境中有不同的线程安全性保障.

判断一个容器是否是线程安全的方式:

阅读文档: 查阅官方文档或标准,通常会明确容器的线程安全性.

查看实现: 不同的标准库实现可能对线程安全性有不同的实现.如果你知道你在使用哪个标准库的实现,可以查看该实现的文档或源代码.

使用锁: 如果容器并非线程安全的,你可以通过在操作容器时手动加锁来确保线程安全.但这样可能会影响性能,并且需要开发者对线程安全性有较深的了解.

第三方库: 有一些第三方库提供了线程安全的容器实现,这些库通常有更丰富的线程安全选项.

容器的线程安全性分类:

线程不安全容器: 大多数容器在多线程环境下不是线程安全的,例如 std::vector/std::deque/std::list.

部分线程安全容器: 有些容器提供了基本的线程安全保障,例如 std::queue 提供了一些原子操作,但在复杂操作时可能需要额外的手动同步.

全局线程安全容器: 有些容器是全局线程安全的,例如 std::shared_timed_mutex,但这种线程安全性可能会伴随一些性能开销.

并发容器: 一些库(如C++17中引入的)提供了专门的并发容器,例如 std::shared_mutex/std::shared_lock.

在使用容器时,了解容器的线程安全性是非常重要的,以确保在多线程环境下正确且高效地使用容器.