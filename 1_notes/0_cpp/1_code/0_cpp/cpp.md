## cpp

variant怎么用?
#### (26) C++虚函数相关(虚函数表,虚函数指针),虚函数的实现原理(热门,重要)
C++的虚函数是实现多态的机制.它是通过虚函数表实现的,虚函数表是每个类中存放虚函数地址的指针数组,类的实例在调用函数时会在虚函数表中寻找函数地址进行调用,如果子类覆盖了父类的函数,则子类的虚函数表会指向子类实现的函数地址,否则指向父类的函数地址.一个类的所有实例都共享同一张虚函数表.

详见:[C++虚函数表剖析](https://blog.csdn.net/lihao21/article/details/50688337)

* 如果多重继承和多继承的话,子类的虚函数表长什么样子?
多重继承的情况下越是祖先的父类的虚函数更靠前,多继承的情况下越是靠近子类名称的类的虚函数在虚函数表中更靠前.详见:https://blog.csdn.net/qq_36359022/article/details/81870219

#### (27) 实现编译器处理虚函数表应该如何处理
编译器处理虚函数的方法是:
如果类中有虚函数,就将虚函数的地址记录在类的虚函数表中.派生类在继承基类的时候,如果有重写基类的虚函数,就将虚函数表中相应的函数指针设置为派生类的函数地址,否则指向基类的函数地址.
为每个类的实例添加一个虚表指针(vptr),虚表指针指向类的虚函数表.实例在调用虚函数的时候,通过这个虚函数表指针找到类中的虚函数表,找到相应的函数进行调用.
详见:[虚函数的作用及其底层实现机制](https://blog.csdn.net/iFuMI/article/details/51088091)


### 1. grammar
#### 1.1 虚函数
* 什么是虚函数表?虚函数表是怎么找到具体哪个函数的?
* override关键词有什么用呢?是仅仅提供编译器检查功能吗?
* 在多继承(即同时有多个直接父类),和存在继承深度(即有间接父类,或者说祖父类)时,虚函数表是怎么工作的?
* 虚函数的性能代价


#### 1.2 构造/移动
* move()和右值有什么用?
* forward<>()完美转发有什么用?

#### 1.3 智能指针
  * 为什么弃用auto_ptr?
    * 所有权转移问题:auto_ptr在所有权转移时存在问题.当将一个auto_ptr赋值给另一个auto_ptr时,所有权会从一个指针转移到另一个指针,导致原始指针变为null.这种行为可能会导致潜在的内存泄漏或未定义的行为.
    * 不适用于容器:auto_ptr不能安全地用于STL容器,如vector或list.这是因为auto_ptr在复制或移动时会导致所有权转移,而STL容器需要能够复制或移动其元素.
    * 缺乏通用性:auto_ptr只能用于管理单个对象,而不能用于管理数组或自定义删除器.

  * weak_ptr有什么用?
  
  * 智能指针的引用计数为什么要是指针?

#### 1.4 oterhs
* union
  构造函数的主要目的是在创建对象时对其进行初始化.如果你使用联合体,不同的成员共享同一块内存,那么在构造函数中很难保证所有成员都得到了正确的初始化.

### 2. compile
#### 2.1 RVO
* 什么是RVO?
* 为什么要手动禁止拷贝和移动语义?
  * 资源管理
  * 更多是处于让编译器检测的目的
#### 2.3 ADL
* 什么是ADL?
* 

### 3. programming paradigm
#### 3.1 RAII
* 什么是RAII?有什么用?
* 怎么实现?
#### 3.2 PIMPL
* 什么是PIMPL?有什么用?
* PIMPL怎么用的?
#### 3.3 CRTP
* 什么是CRTP?有什么用?
* 怎么实现?
#### 3.4 COW
* 什么是COW(copy on swap)?有什么用?
* 在什么场景下使用?
* 怎么实现?

#### 3.5 CAS
* 什么是CAS(copy and swap)?有什么用?
  在C++编程中,"copy-and-swap"(CAS)是一种常用的技术,用于实现赋值操作符(operator=).CAS的基本思想是先创建一个副本,然后交换副本和原对象.
* 在什么场景下使用?
  实现赋值操作符:CAS是实现赋值操作符(operator=)的一种常见方法.它可以简化代码,并提供强异常安全性.

  提供强异常安全性:如果你的代码需要在异常发生时保持一致性(即,不会因为异常而处于无效状态),那么CAS可能是一个好的选择.在CAS中,如果复制操作抛出异常,原对象不会被修改.

  避免自我赋值问题:在传统的赋值操作符实现中,你需要检查自我赋值(即,a = a).但是在CAS中,由于赋值操作符接受的是一个副本,所以不需要检查自我赋值.

  然而,CAS并不适用于所有情况.CAS的一个主要缺点是它需要进行复制操作,这可能会导致性能问题.如果你的对象很大,或者复制操作很昂贵,那么你可能需要使用其他方法来实现赋值操作符.

* 什么时候需要用move
  * 对于callback函数来说
  * 对于将对象插入到容器来说
  * 交换两个对象