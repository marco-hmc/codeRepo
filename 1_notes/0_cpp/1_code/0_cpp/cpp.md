## cpp
#### (26) C++虚函数相关(虚函数表,虚函数指针),虚函数的实现原理(热门,重要)
C++的虚函数是实现多态的机制.它是通过虚函数表实现的,虚函数表是每个类中存放虚函数地址的指针数组,类的实例在调用函数时会在虚函数表中寻找函数地址进行调用,如果子类覆盖了父类的函数,则子类的虚函数表会指向子类实现的函数地址,否则指向父类的函数地址.一个类的所有实例都共享同一张虚函数表.

详见:[C++虚函数表剖析](https://blog.csdn.net/lihao21/article/details/50688337)

* 如果多重继承和多继承的话,子类的虚函数表长什么样子?
多重继承的情况下越是祖先的父类的虚函数更靠前,多继承的情况下越是靠近子类名称的类的虚函数在虚函数表中更靠前.详见:https://blog.csdn.net/qq_36359022/article/details/81870219

#### (27) 实现编译器处理虚函数表应该如何处理
编译器处理虚函数的方法是:
如果类中有虚函数,就将虚函数的地址记录在类的虚函数表中.派生类在继承基类的时候,如果有重写基类的虚函数,就将虚函数表中相应的函数指针设置为派生类的函数地址,否则指向基类的函数地址.
为每个类的实例添加一个虚表指针(vptr),虚表指针指向类的虚函数表.实例在调用虚函数的时候,通过这个虚函数表指针找到类中的虚函数表,找到相应的函数进行调用.
详见:[虚函数的作用及其底层实现机制](https://blog.csdn.net/iFuMI/article/details/51088091)

#### (37) 结构体内存对齐方式和为什么要进行内存对齐?
因为结构体的成员可以有不同的数据类型,所占的大小也不一样.同时,由于CPU读取数据是按块读取的,内存对齐可以使得CPU一次就可以将所需的数据读进来.

对齐规则:
* 第一个成员在与结构体变量偏移量为0的地址
* 其他成员变量要对齐到某个数字(对齐数)的整数倍的地址处.
* 对齐数=编译器默认的一个对齐数 与 该成员大小的较小值.
* linux 中默认为4
* vs 中的默认值为8
结构体总大小为最大对齐数的整数倍(每个成员变量除了第一个成员都有一个对齐数)


### 1. grammar
#### 1.1 虚函数
* 什么是虚函数表?虚函数表是怎么找到具体哪个函数的?
* override关键词有什么用呢?是仅仅提供编译器检查功能吗?
* 在多继承(即同时有多个直接父类),和存在继承深度(即有间接父类,或者说祖父类)时,虚函数表是怎么工作的?
* 虚函数的性能代价


#### 1.2 构造/移动
* move()和右值有什么用?
* forward<>()完美转发有什么用?

#### 1.3 智能指针
  * 为什么弃用auto_ptr?
    * 所有权转移问题:auto_ptr在所有权转移时存在问题.当将一个auto_ptr赋值给另一个auto_ptr时,所有权会从一个指针转移到另一个指针,导致原始指针变为null.这种行为可能会导致潜在的内存泄漏或未定义的行为.
    * 不适用于容器:auto_ptr不能安全地用于STL容器,如vector或list.这是因为auto_ptr在复制或移动时会导致所有权转移,而STL容器需要能够复制或移动其元素.
    * 缺乏通用性:auto_ptr只能用于管理单个对象,而不能用于管理数组或自定义删除器.

  * weak_ptr有什么用?
  
  * 智能指针的引用计数为什么要是指针?


#### 1.4 oterhs
* union
  构造函数的主要目的是在创建对象时对其进行初始化.如果你使用联合体,不同的成员共享同一块内存,那么在构造函数中很难保证所有成员都得到了正确的初始化.

### 2. compile
#### 2.1 RVO
* 什么是RVO?
#### 2.2 delete/default
* delete/default有什么用?
* 为什么要手动禁止拷贝和移动语义?
  * 资源管理
  * 更多是处于让编译器检测的目的
#### 2.3 ADL
* 什么是ADL?
* 

### 3. programming paradigm
#### 3.1 RAII
* 什么是RAII?有什么用?
* 怎么实现?
#### 3.2 PIMPL
* 什么是PIMPL?有什么用?
* PIMPL怎么用的?
#### 3.3 CRTP
* 什么是CRTP?有什么用?
* 怎么实现?
#### 3.4 COW
* 什么是COW(copy on swap)?有什么用?
* 在什么场景下使用?
* 怎么实现?
#### 3.5 CAS
* 什么是CAS(copy and swap)?有什么用?
* 在什么场景下使用?
* 怎么实现?
> 简单来说,就是将自身对象的数据和临时对象的数据进行了一个交换,这个时候就不需要手动管理自身对象原有数据的生命周期.原有数据被交换到临时对象上去了,而临时对象被调用析构的时候就会自动释放相关资源.
> 除了copy and swap这个概念外,还有compare and swap的概念的缩写也是cas

