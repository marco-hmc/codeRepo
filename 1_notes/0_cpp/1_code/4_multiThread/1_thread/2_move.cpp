#include <iostream>
#include <thread>

void task1() { std::cout << "Executing Task 1" << std::endl; }

void task2() { std::cout << "Executing Task 2" << std::endl; }

int main() {
  std::thread t1(task1);

  // 在运行时决定执行哪个任务
  if (false) {
    std::thread t2 = std::move(t1); // 将线程控制权从 t1 转移到 t2
                                    // std::thread t2 = t1; // 编译错误
    t2.join();
  } else {
    t1 = std::thread(task2); // 重新赋值,接管新线程的控制权
    t1.join();
  }

  return 0;
}

/*
  1. 线程为什么是不可以移动的？

    实际上，线程是可以移动的。在C++中，`std::thread`对象是可以移动的，但是不可以拷贝。这是因为线程的执行是唯一的，不能被复制。如果允许拷贝，那么就会有两个`std::thread`对象试图管理同一个线程，这会导致问题。

  2. 线程移动的意义是什么？

    线程的移动意味着线程的所有权可以从一个`std::thread`对象转移到另一个。这在很多情况下都是有用的。例如，如果你想在一个函数中创建一个线程，然后返回它，你就需要移动线程，因为你不能复制它。又或者，你可能想在一个数据结构中存储线程，这也需要移动线程。

  3. 线程运行时，可以移动吗？

    是的，线程在运行时可以移动。线程的移动并不会影响线程的执行。当你移动一个线程时，只是改变了哪个`std::thread`对象代表这个线程，线程本身的状态（例如，是否正在运行）并不会改变。

  4. 移动一个运行中的线程会发生什么？

    当你移动一个运行中的线程时，原来的`std::thread`对象不再代表任何线程，而新的对象接管了原来的线程。线程本身的执行不会受到影响，它会继续运行，直到它的任务完成。
*/