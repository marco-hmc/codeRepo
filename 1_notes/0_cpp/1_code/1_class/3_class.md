## c++对象

### 1. 类的实现
一个类
```c++
class Example {
public:
    int value;
};

// 由编译器默认提供的实现
Example::Example() : value(0) {}
Example::~Example() {}

// 拷贝构造
Example::Example(const Example& other) : value(other.value) {}

// 拷贝赋值
Example& Example::operator=(const Example& other) {
    if (this != &other) {
        value = other.value;
    }
    return *this;
}

// 移动构造
Example::Example(Example&& other) noexcept : value(other.value) {
    other.value = 0;
}

// 移动赋值
Example& Example::operator=(Example&& other) noexcept {
    if (this != &other) {
        value = other.value;
        other.value = 0;
    }
    return *this;
}
```

#### 1.1 quiz
* 为什么拷贝构造的入参是`const T&`类型的？

* 为什么拷贝赋值、移动复制要判断this指针不相同？

* 为什么移动的构造赋值用noexcept，但是拷贝的没有？

### 2. 编译器对类的处理-类的内存模型
![alt text](_imgs/3_class_image.png)
* 类成员变量区
  * x
  * vptr（指向虚函数区）
* 虚函数区
  * type_info类型信息
  * 虚函数
---
不在类
* 类的静态成员变量区
  * __point_count
* 类的静态函数区
  * PointCount()

#### 2.99 quiz  
* 一个class object的内存大小由什么组成？
    * 非static的成员变量大小
    * alignment补齐的空间大小
    * 支持virtual带来的负担

### 3. 编译器对类的处理-类的继承模型

### 4. 编译器对类的处理-类的虚继承模型

### 5. 深入类的成员变量

### 6. 深入类的函数


#### 1.8 return this和return *this的区别是什么
`return this` 和 `return *this` 的主要区别在于它们返回的类型:

- `return this` 返回的是一个指向当前对象的指针.这意味着,如果你有一个对象 `obj`,并且你有一个函数 `func` 返回 `this`,那么 `obj.func()` 将返回一个指向 `obj` 的指针.

- `return *this` 返回的是当前对象的一个引用.这意味着,如果你有一个对象 `obj`,并且你有一个函数 `func` 返回 `*this`,那么 `obj.func()` 将返回一个引用到 `obj`.

在某些情况下,你可能希望返回一个指向当前对象的指针,例如,如果你正在实现一个链式调用.在其他情况下,你可能希望返回一个引用,例如,如果你正在实现一个赋值运算符,通常你会希望返回一个引用,以便支持连续赋值(例如 `a = b = c`).


**10. 令operator= 返回一个reference to *this （Have assignment operators return a reference to *this)**

主要是为了支持连读和连写，例如：
    
    class Widget{
    public:
        Widget& operator=(int rhs){return *this;}
    }
    a = b = c;

**11. 在operator= 中处理“自我赋值” （Handle assignment to self in operator=)**

主要是要处理 a[i] = a[j] 或者 *px = *py这样的自我赋值。有可能会出现一场安全性问题，或者在使用之前就销毁了原来的对象



#### 1.10 设计class犹如设计type

如何设计class:
+ 新的class对象应该被如何创建和构造
+ 对象的初始化和赋值应该有什么样的差别(不同的函数调用,构造函数和赋值操作符)
+ 新的class如果被pass by value(以值传递),意味着什么(copy构造函数)
+ 什么是新type的"合法值"(成员变量通常只有某些数值是有效的,这些值决定了class必须维护的约束条件)
+ 新的class需要配合某个继承图系么(会受到继承类的约束)
+ 新的class需要什么样的转换(和其他类型的类型变换)
+ 什么样的操作符和函数对于此type而言是合理的(决定声明哪些函数,哪些是成员函数)
+ 什么样的函数必须为private的 
+ 新的class是否还有相似的其他class,如果是的话就应该定义一个class template
+ 你真的需要一个新type么?如果只是定义新的derived class或者为原来的class添加功能,说不定定义non-member函数或者templates更好


## 类的quiz

### 99. quiz
#### 1. 编译器会为C++的类自动生成什么函数？
编译器会为C++的类自动生成以下六种特殊的成员函数：

1. 默认构造函数（如果没有定义任何构造函数）
2. 析构函数（如果没有定义）
3. 拷贝构造函数（如果没有定义并且某些条件满足）
4. 拷贝赋值运算符（如果没有定义并且某些条件满足）
5. 移动构造函数（如果没有定义并且某些条件满足，C++11及以后）
6. 移动赋值运算符（如果没有定义并且某些条件满足，C++11及以后）

这些函数被称为特殊成员函数。它们是编译器为了支持一些基本操作（如初始化、拷贝、移动、销毁对象）而自动为类生成的。但是，如果你为类定义了自己的版本，编译器就不会再生成这些函数。

#### 2. 什么条件下不会自动生成？

* 拷贝构造函数和拷贝赋值运算符
  * 如果你没有显式定义它们，且类中的所有成员都可以被拷贝，编译器就会为你生成这两个函数。但是，如果类中有不能被拷贝的成员（例如，`std::unique_ptr`或者定义了删除的拷贝构造函数的类型的成员），编译器就不会生成这两个函数。

* 移动构造函数和移动赋值运算符
    从C++11开始，如果你没有显式定义它们，且类中的所有成员都可以被移动，编译器就会为你生成这两个函数。但是，如果类中有不能被移动的成员（例如，定义了删除的移动构造函数的类型的成员），或者你已经定义了拷贝构造函数、拷贝赋值运算符或析构函数，编译器就不会生成这两个函数。

这些规则的目的是为了保证对象的正确拷贝和移动，避免因为编程错误导致的问题，例如内存泄漏或者浅拷贝。

#### 3. 这六种特殊成员函数的函数签名是什么？
这六种特殊成员函数的函数签名如下：

1. 默认构造函数：`T()`
2. 析构函数：`~T()`
3. 拷贝构造函数：`T(const T& other)`
4. 拷贝赋值运算符：`T& operator=(const T& other)`
5. 移动构造函数：`T(T&& other)`
6. 移动赋值运算符：`T& operator=(T&& other)`

其中，`T`是类的名称，`other`是另一个同类型的对象。在拷贝构造函数和拷贝赋值运算符中，`other`是一个对常量的引用，表示这个函数不会修改`other`。在移动构造函数和移动赋值运算符中，`other`是一个右值引用，表示这个函数可能会修改`other`，通常是通过“窃取”其资源。

#### 4. 为什么这六种特殊的成员函数是这样子设定的？

1. 默认构造函数：`T()`。这是最基本的构造函数，如果用户没有定义任何构造函数，编译器会提供一个。它不接受任何参数，用于创建类的一个新实例。

2. 析构函数：`~T()`。这个函数在对象被销毁时调用，用于清理对象可能拥有的资源。如果用户没有定义，编译器会提供一个默认的析构函数。

3. 拷贝构造函数：`T(const T& other)`。这个函数用于创建一个新对象，该对象是一个已存在对象的副本。`const T&`表示这个函数接收一个对已存在对象的引用，且不会修改这个对象。

4. 拷贝赋值运算符：`T& operator=(const T& other)`。这个函数用于将一个已存在对象的状态赋值给另一个对象。`const T&`表示这个函数接收一个对已存在对象的引用，且不会修改这个对象。

5. 移动构造函数：`T(T&& other)`。这个函数用于创建一个新对象，该对象“窃取”了一个已存在对象的资源。`T&&`表示这个函数接收一个对已存在对象的右值引用，这个对象可能会被修改。

6. 移动赋值运算符：`T& operator=(T&& other)`。这个函数用于将一个已存在对象的资源“窃取”给另一个对象。`T&&`表示这个函数接收一个对已存在对象的右值引用，这个对象可能会被修改。

这些函数的设定方式主要是为了支持对象的创建、拷贝、移动和销毁，同时尽可能地避免不必要的对象复制和资源浪费。

简单来说，以拷贝构造函数为例，即使不使用`const T& other`作为形参，而是使用`T& other`也是可以声明拷贝构造函数的。但一般来说，我们需要`override`编译器默认生成的拷贝构造函数，而且`const T& other`会比`T& other`好，因为使用`const T& other`作为参数，可以从任何对象（包括const对象和临时对象）中拷贝。
> 临时对象（也称为右值）是不能绑定到非const的左值引用上的，但可以绑定到const的左值引用上。这是C++语言规则的一部分，主要是为了保护临时对象不被意外修改。

除此，如果不是`&`引用类型的话，也会有问题。

1. **性能**:当参数是值时,会创建该对象的一个新的副本,这涉及到对象的复制操作,可能会消耗大量的时间和内存.特别是当对象较大时,复制的代价会非常高.而当参数是常量引用时,只需要传递引用,不需要复制对象,因此性能更高.

2. **避免无限递归**:如果拷贝构造函数的参数是值,那么在调用拷贝构造函数时,需要先创建一个新的对象,这又需要调用拷贝构造函数,从而形成无限递归,导致程序崩溃.而当参数是常量引用时,不会触发拷贝构造函数,因此可以避免无限递归.

所以,拷贝构造函数的参数通常是常量引用,而不是值.

#### 5. 为什么移动构造函数一般情况下会比拷贝构造函数快？

#### 6. 移动的时候如果不将原来的置空会怎样？
在编程中，"移动"通常指的是移动语义，这是C++11引入的一个新特性。移动语义允许资源（如动态分配的内存）从一个对象转移到另一个对象，这样可以避免不必要的临时对象的复制。

如果在移动操作后不将原对象置空，可能会导致一些问题。例如，如果原对象是一个拥有动态分配内存的对象，那么当原对象和新对象都试图释放同一块内存时，就会发生双重删除，这会导致程序崩溃。

因此，通常在执行移动操作后，我们会将原对象置空或设置为一个安全的状态，以防止这种问题的发生。

#### 7. 一个类B,它有一个A*类型的成员变量.并写出它的拷贝构造函数.

```cpp
class A {
    // A的定义
};

class B {
public:
    B() : ptr(new A()) {}  // 默认构造函数
    B(const B& other) : ptr(new A(*(other.ptr))) {}  // 拷贝构造函数
    ~B() { delete ptr; }  // 析构函数

private:
    A* ptr;  // A*类型的成员变量
};
```

#### 8. 对上面的类B定义一个右值构造函数

```cpp
class B {
public:
    // 其他成员...

    // 右值构造函数
    B(B&& other) noexcept {
        // 窃取other的资源，然后将other置于有效但未定义的状态
    }
};
```

#### 9. 定义一个static成员变量。该怎么写？

在C++中，你可以在类内部声明一个static成员变量，然后在类外部定义和初始化它。以下是一个例子：

```cpp
class B {
public:
    // 静态成员变量的声明
    static int s_value;
};

// 静态成员变量的定义和初始化
int B::s_value = 0;
```

在这个例子中，`s_value`是类B的一个静态成员变量。所有的B对象都共享同一个`s_value`变量。

好的，以下是对这两个问题的逐点解释：

#### 10. 为什么要声明 `virtual`?

1. **实现多态**
   - `virtual` 关键字用于声明虚函数，允许派生类重写基类中的函数，从而实现多态。
   - 通过基类指针或引用调用虚函数时，会根据实际对象的类型调用相应的派生类函数，而不是基类函数。

2. **确保正确的析构**
   - 当基类的析构函数被声明为虚函数时，通过基类指针删除派生类对象时，会正确调用派生类的析构函数，避免资源泄漏。
   - 示例：
     ```cpp
     class Base {
     public:
         virtual ~Base() {}
     };

     class Derived : public Base {
     public:
         ~Derived() {}
     };

     Base* obj = new Derived();
     delete obj; // 正确调用 Derived 和 Base 的析构函数
     ```

3. **动态绑定**
   - `virtual` 关键字使得函数调用在运行时进行动态绑定，而不是在编译时进行静态绑定。
   - 这允许程序在运行时决定调用哪个函数，实现更灵活的设计。

4. **接口设计**
   - 在设计接口或抽象基类时，通常将函数声明为虚函数，以便派生类提供具体实现。
   - 示例：
     ```cpp
     class Shape {
     public:
         virtual void draw() = 0; // 纯虚函数，必须在派生类中实现
     };

     class Circle : public Shape {
     public:
         void draw() override {
             // Circle 的具体实现
         }
     };
     ```

#### 11. 如果父类声明了虚析构，那么拷贝，移动也需要是虚的吗？
不需要。

#### 12. 为什么要声明 `override`?

1. **明确意图**
   - `override` 关键字明确表示派生类中的函数是重写基类中的虚函数。
   - 这有助于代码的可读性和可维护性，使得代码意图更加清晰。
   - `override` 关键字本身不会改变程序的运行时行为，它的主要作用是提升代码的可读性和可维护性，并且提供编译器检查功能。
    以下是详细解释：

2. **编译器检查**
   - 使用 `override` 关键字可以让编译器检查函数签名是否正确匹配基类中的虚函数。
   - 如果函数签名不匹配，编译器会报错，避免潜在的错误。
   - 示例：
     ```cpp
     class Base {
     public:
         virtual void func(int) {}
     };

     class Derived : public Base {
     public:
         void func(int) override { // 正确匹配基类函数
             // Derived 的具体实现
         }
     };
     ```

3. **防止意外重载**
   - 如果派生类中的函数签名与基类中的虚函数不匹配，编译器会将其视为新的函数，而不是重写基类函数。
   - 使用 `override` 可以防止这种意外重载的情况。
   - 示例：
     ```cpp
     class Base {
     public:
         virtual void func(int) {}
     };

     class Derived : public Base {
     public:
         void func(double) override { // 编译错误，签名不匹配
             // Derived 的具体实现
         }
     };
     ```

4. **提高代码质量**
   - 使用 `override` 关键字可以提高代码质量，减少错误，提高代码的健壮性和可维护性。

