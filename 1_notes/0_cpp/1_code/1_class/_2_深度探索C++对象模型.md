## 深度探索C++对象模型

### 1. 关于对象
* c++对象的封装成本是什么
  * 所有的非静态数据成员,非虚的都存储在对象本身中.
  * 放在class里只有因为virtual带来的额外开销
    * virtual function
    * virtual base class
* c++对象模型
  为了实现多态,即对virtual特性的支持,c++的对象有额外以下内容
  * 成员变量
  * vptr -> vtbl
  ---
  而静态成员变量则是在
* C++对象模型的组成:
  * 所有的非静态数据成员存储在对象本身中.
  * 所有的静态数据成员/成员函数(包括静态与非静态)都置于对象之外.
  * 另用一张虚函数表(virtual table) 存储所有指向虚函数的指针,并在表头附加上一个该类的type_info对象,在对象中则保存一个指向虚函数表的指针.
    ![Alt text](_imgs/image.png)


#### c++继承和虚函数 
#### 虚函数的作用 
虚函数如何实现的,画出内存图

* c++继承和虚函数 

##### 深入了解虚拟继承对象模型
为了解决多份拷贝的问题,引入了虚继承,看如下一个🌰
```cpp
class MyClassA:virtual public MyClass
class MyClassB:virtual public MyClass
class MyClassC:public MyClassA,public MyClassB
```
那么除了秉承这个观点还有什么呢?没错,还有一个虚基类表vbtable.虚继承的引入把对象的模型变得十分复杂,除了每个基类(MA和MB)和公共基类(M)的虚函数表指针需要记录📝外,每个虚拟继承了MyClass的父类还需要记录一个虚基类表vbtable的指针vbptr.<br>
![MyClassC的对象模型](./img/Myclass.jpg)<br>
虚基类表每一项记录📝了被继承的虚基类子对象相对于虚基类表指针的偏移量.参考[虚函数与虚继承寻踪](http://www.cnblogs.com/fanzhidongyzby/archive/2013/01/14/2859064.html)<br>

#### 虚继承 虚基类
令所有继承File的都变成虚继承
```cpp
class File{};
class InputFile:virtual public File{};
class OutputFile:virtual public File{};
class IOFile:public InputFile,public OutputFile{};
```
虚继承是一种机制,类通过虚继承指出它希望共享其虚基类的状态.在虚继承下,对给定虚基类,无论该类在派生层次中作为虚基类出现多少次,都只继承一个共享的基类子对象.<br>
这就很好解决了不用复制太多的成员变量.毕竟virtual始终秉承着一个观点,一个接口,你可以多种方法,始终一个接口.后面的实现都会覆盖本来的方法.<br>

#### 多重继承(虚继承)与访问控制 明智而审慎地使用多重继承
多重继承上面其实也有体现,例如Circle继承了Shape,Shape2.多重继承衍生出类层次<br>
* 共享接口: 通过使用类使得重复代码较少,且代码规格同一.通常称为 **运行时多态**或者接口继承
* 共享实现: 代码量较少且实现代码的规格同一,通常称为实现继承.<br>
一个类可以综合应用接口与实现继承.<br>


### 99. quiz
#### 1. 一个c++函数同时继承自多个父类，有多少个vptr
在C++中，如果一个类从多个父类继承，且这些父类都有虚函数，那么派生类的对象将会有多个虚函数表指针（vptr）。每个父类都会有一个自己的虚函数表（vtable），因此派生类的对象需要有多个vptr来分别指向这些vtable。

具体来说，如果一个类从n个父类继承，且这些父类都有虚函数，那么派生类的对象将会有n个vptr。这是因为每个父类的vtable都可能不同，所以需要有独立的vptr来指向它们。

需要注意的是，这只适用于普通的多重继承。如果使用的是虚继承（virtual inheritance），情况就会有所不同。在虚继承中，所有的虚基类（virtual base class）都只有一个共享的vtable，因此派生类的对象只需要一个vptr来指向这个共享的vtable。

#### 2. 一个c++函数同时虚继承多个父类，有多少个vptr

在C++中，如果一个类使用虚继承（virtual inheritance）从多个父类继承，那么这个类的对象将会有一个或多个虚函数表指针（vptr），具体数量取决于继承的父类和虚继承的使用方式。

在虚继承中，所有的虚基类（virtual base class）都只有一个共享的虚函数表（vtable）。因此，如果所有的父类都是虚基类，那么派生类的对象只需要一个vptr来指向这个共享的vtable。

然而，如果有的父类是虚基类，有的父类不是，那么派生类的对象将会有多个vptr。每个非虚基类都会有自己的vtable，因此需要有独立的vptr来指向它们。

总的来说，一个类使用虚继承从多个父类继承时，它的对象的vptr的数量取决于虚基类和非虚基类的数量。

#### 3. 如果有多个vptr的时候，怎么知道运行哪一个？根据vptr找到vtable，逐个遍历吗？

在C++中，当一个对象有多个vptr时，每个vptr都对应一个父类，并指向该父类的虚函数表（vtable）。当调用一个虚函数时，编译器会根据该函数的声明类型（也就是调用该函数的对象的静态类型）来决定使用哪个vptr。

具体来说，如果你有一个指向派生类对象的父类指针，并且你通过这个指针调用一个虚函数，那么编译器会使用与这个父类类型对应的vptr，从而调用正确的函数实现。

例如，假设你有一个类`D`，它从两个父类`B1`和`B2`继承，且`B1`和`B2`都有一个虚函数`f()`。如果你有一个`B1`类型的指针`p`，并且`p`指向一个`D`类型的对象，那么当你调用`p->f()`时，编译器会使用与`B1`类型对应的vptr，从而调用`D`类中对`B1`的`f()`函数的重写（如果有的话）。

所以，你不需要逐个遍历所有的vptr。编译器会根据虚函数的声明类型来决定使用哪个vptr。

#### 4. 虚继承的时候，如何使得基类的数据成员也只有一份？
在C++中，虚继承（virtual inheritance）可以确保从多个路径继承来的同一个基类的数据成员在内存中只有一份副本。

当一个类被声明为其他类的虚基类（virtual base class）时，无论这个类在继承体系中被继承了多少次，它的数据成员在派生类对象中都只有一份副本。这是通过在派生类中只包含一个指向虚基类的指针来实现的，这个指针被称为虚基类指针（Virtual Base Pointer，VBP）。所有的派生类对象都共享同一个虚基类子对象。

例如，假设你有一个类`B`，它被声明为类`D1`和`D2`的虚基类，然后你有一个类`D`，它从`D1`和`D2`继承。在这种情况下，`D`的对象中只会有一个`B`的子对象，而不是两个。

这是虚继承的一个重要特性，它解决了多重继承中的菱形继承问题。在菱形继承中，如果不使用虚继承，那么最终的派生类将会包含多个基类的子对象的副本，这可能会导致混淆和不一致的问题。通过使用虚继承，我们可以确保基类的数据成员在内存中只有一份副本，从而避免这些问题。

#### 5. 对于非多态类型和多态类型，如何获取类型信息（type_info）？

- 对于**非多态类型**（即没有虚函数的类），类型信息（type_info）通常可以通过编译时的类型信息直接获取，不需要通过虚拟表（vtable）来访问。

- 对于**多态类型**（即包含至少一个虚函数的类），每个对象会有一个虚拟表（vtable），其中包含了指向该类型type_info对象的指针。这样，可以通过对象的虚拟表在运行时动态地访问到其类型信息。