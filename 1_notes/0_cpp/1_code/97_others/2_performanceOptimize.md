## 性能优化

### 1. concepts
#### 1.1 这些是一些常见操作的成本的数量级的概念:
这些操作的精确耗时取决于许多因素,包括硬件/操作系统/网络条件等.以下是一些大致的估计:

1. **一次内存访问**:大约在100纳秒级别.这是从CPU访问主内存的时间,缓存访问会更快.
2. **一次函数调用**:大约在几十到几百纳秒.这取决于函数的复杂性和编译器优化.
3. **一次字符串比较**:取决于字符串的长度和比较算法,可能在几微秒到几十微秒.这假设字符串已经在CPU缓存中.
4. **一次系统调用**:大约在1-10微秒.这是进入内核并返回用户空间的时间,不包括系统调用本身的执行时间.
5. **线程创建和销毁**:几十微秒到几毫秒之间
   - 线程创建：
     - 创建一个线程涉及分配资源、初始化线程上下文、设置线程栈等操作。
     - 线程创建的开销通常在几十微秒到几毫秒之间，具体取决于操作系统和硬件。
   - 线程销毁：
     - 销毁一个线程涉及清理资源、释放内存、更新调度器等操作。
     - 线程销毁的开销通常也在几十微秒到几毫秒之间。
6. **一次磁盘访问**:
   - 对于固态硬盘(SSD),大约在0.1毫秒(100微秒).
   - 对于机械硬盘(HDD),大约在5-10毫秒.
7. **一个通过网络的消息的成本**:取决于网络的延迟和带宽,可能在几毫秒到几百毫秒.例如,一个典型的局域网延迟可能在0.1-1毫秒,而跨大洲的延迟可能在100-200毫秒.

### 1.2 代码优化主要思路
* 内存管理优化
  * 对象池，避免重复构造
  * 避免在循环中创建和销毁对象
* 正确使用算法
  * 优化算法实现,避免不必要的递归;
  * 避免不必要的计算和wait;
  * 避免不必要的参数copy
* 硬件友好代码
  * 现在cpu很多时候都可以对指令并行化,利用SIMD特性
  * 提升缓存利用率，例如aos和soa方式
  * 多线程
    * 线程池
* 编译器优化

### 3. 编译器优化
#### 3.1 pgo
PGO,全称为 Profile-Guided Optimization(基于分析的优化),是一种编译器优化技术,它通过收集程序运行时的性能信息来指导编译器优化.

PGO 的工作流程通常包括以下几个步骤:
1. **编译**:首先,你需要使用特殊的编译器选项来编译你的程序,这会使得程序在运行时收集性能信息.
2. **运行**:然后,你需要运行你的程序,并让它处理一些典型的工作负载.这会生成一个性能分析文件,其中包含了程序运行时的性能信息.
3. **优化编译**:最后,你需要再次使用特殊的编译器选项来编译你的程序,这次编译器会使用性能分析文件中的信息来指导优化.

通过这种方式,编译器可以了解到程序的实际运行情况,例如哪些代码经常被执行,哪些代码很少被执行,哪些条件分支的预测结果通常是什么等等.然后,编译器可以使用这些信息来进行更有效的优化,例如更精确地进行内联,更智能地安排代码布局,更准确地预测条件分支等等.

PGO 可以显著提高程序的运行速度,特别是对于那些性能敏感的应用程序.然而,PGO 也有一些缺点,例如它会增加编译时间和编译复杂性,因此并不是所有的项目都适合使用 PGO.
