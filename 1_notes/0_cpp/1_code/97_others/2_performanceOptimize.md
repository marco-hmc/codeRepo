## 性能优化

### 1. concepts
#### 1.1 这些是一些常见操作的成本的数量级的概念:
这些操作的精确耗时取决于许多因素,包括硬件/操作系统/网络条件等.以下是一些大致的估计:

1. **一次内存访问**:大约在100纳秒级别.这是从CPU访问主内存的时间,缓存访问会更快.
2. **一次函数调用**:大约在几十到几百纳秒.这取决于函数的复杂性和编译器优化.
3. **一次字符串比较**:取决于字符串的长度和比较算法,可能在几微秒到几十微秒.这假设字符串已经在CPU缓存中.
4. **一次系统调用**:大约在1-10微秒.这是进入内核并返回用户空间的时间,不包括系统调用本身的执行时间.
5. **线程创建和销毁**:几十微秒到几毫秒之间
   - 线程创建：
     - 创建一个线程涉及分配资源、初始化线程上下文、设置线程栈等操作。
     - 线程创建的开销通常在几十微秒到几毫秒之间，具体取决于操作系统和硬件。
   - 线程销毁：
     - 销毁一个线程涉及清理资源、释放内存、更新调度器等操作。
     - 线程销毁的开销通常也在几十微秒到几毫秒之间。
6. **一次磁盘访问**:
   - 对于固态硬盘(SSD),大约在0.1毫秒(100微秒).
   - 对于机械硬盘(HDD),大约在5-10毫秒.
7. **一个通过网络的消息的成本**:取决于网络的延迟和带宽,可能在几毫秒到几百毫秒.例如,一个典型的局域网延迟可能在0.1-1毫秒,而跨大洲的延迟可能在100-200毫秒.

#### 1.2 优化原则
1. **二八原则**：
   - 80% 的性能问题通常来自 20% 的代码。
2. **先正确运行，再优化**：
   - 确保程序正确运行，然后再进行性能优化。
3. **不要太提前优化**：
   - 避免过早优化，先确保代码的正确性和可维护性。
4. **优化需要数据支持**：
   - 进行性能优化时需要有数据支持，编译器的优化能力很强，看上去有效的优化不一定实际有效。

#### 1.3 代码优化主要思路
* **性能优化原则**
  1. **二八原则**：
    - 80% 的性能问题通常来自 20% 的代码。
  2. **先正确运行，再优化**：
    - 确保程序正确运行，然后再进行性能优化。
  3. **不要太提前优化**：
    - 避免过早优化，先确保代码的正确性和可维护性。
  4. **优化需要数据支持**：
    - 进行性能优化时需要有数据支持，编译器的优化能力很强，看上去有效的优化不一定实际有效。

* **CPU 密集任务**
  1. **多线程**：
    - 使用多线程并行化计算任务，充分利用多核处理器的计算能力。
    - 使用 `wait` 机制协调线程间的同步。
  2. **优化算法实现**：
    - 避免不必要的递归，使用迭代替代递归。
    - 避免不必要的参数复制，使用引用传递参数。
    - 避免不必要的计算，减少重复计算。
    - 正确使用高效的算法和数据结构。

* **I/O 密集任务**
  1. **内存 I/O 密集**：
    - 使用对象池，避免重复构造和销毁对象。
    - 优化内存访问模式，使用顺序访问提高缓存命中率。
  2. **硬盘 I/O 密集**：
    - 使用异步 I/O 操作，允许程序在等待 I/O 操作完成时继续执行其他任务。
    - 使用缓存减少磁盘 I/O 操作，提高效率。
    - 使用高效的文件系统和磁盘调度算法。
  3. **网络 I/O 密集**：
    - 使用异步网络 I/O 操作，提高并发性和效率。
    - 使用高效的网络协议，减少网络延迟。
    - 使用压缩减少传输的数据量，提高传输效率。

#### 1.4 代码实现常见原则
* **硬件友好代码**
  1. **利用 SIMD 特性**：
    - 现在的 CPU 很多时候都可以对指令并行化，利用 SIMD（Single Instruction, Multiple Data）特性进行向量化计算，提高并行计算性能。
  2. **提升缓存利用率**：
    - 使用结构化数组（SoA）和数组结构（AoS）方式优化数据布局，提高缓存命中率。
    - 避免缓存未命中，优化内存访问模式，使用顺序访问提高缓存命中率。

#### 1.5 性能优化常见手段
* 对象池
* 线程池
* 内存池
* 缓存


* **3. 编译器优化**
#### 3.1 pgo
PGO,全称为 Profile-Guided Optimization(基于分析的优化),是一种编译器优化技术,它通过收集程序运行时的性能信息来指导编译器优化.

PGO 的工作流程通常包括以下几个步骤:
1. **编译**:首先,你需要使用特殊的编译器选项来编译你的程序,这会使得程序在运行时收集性能信息.
2. **运行**:然后,你需要运行你的程序,并让它处理一些典型的工作负载.这会生成一个性能分析文件,其中包含了程序运行时的性能信息.
3. **优化编译**:最后,你需要再次使用特殊的编译器选项来编译你的程序,这次编译器会使用性能分析文件中的信息来指导优化.

通过这种方式,编译器可以了解到程序的实际运行情况,例如哪些代码经常被执行,哪些代码很少被执行,哪些条件分支的预测结果通常是什么等等.然后,编译器可以使用这些信息来进行更有效的优化,例如更精确地进行内联,更智能地安排代码布局,更准确地预测条件分支等等.

PGO 可以显著提高程序的运行速度,特别是对于那些性能敏感的应用程序.然而,PGO 也有一些缺点,例如它会增加编译时间和编译复杂性,因此并不是所有的项目都适合使用 PGO.


### 缓存
* 减少内存访问延迟：cpu缓存
* 减少磁盘IO读写延迟：文件缓存
* 减少数据库查询延迟：数据库缓存
* 减少网络IO读写延迟：web缓存/ 代理服务器缓存/ CDN缓存
* 减少cpu计算延迟：cacheData

### 如何解决缓存空间受限问题
缓存为了快速访问一般都是通过哈希表的方式存储。
但当需要限制缓存空间大小的时候，即数据会不断增加，但缓存空间有限，就需要考虑那些缓存的数据需要被淘汰。
常见的淘汰方法有这些。
* LRU（Least Recently Used）：移除最近最少使用的数据。
* LFU（Least Frequently Used）：移除使用频率最低的数据。
* FIFO（First In First Out）：移除最早进入缓存的数据。