## linux下用户态和系统态的基础认识

[toc]

> Marco
>
> 用户态和系统态的分层设计重要初衷之一是限制不同成不同程序之间的访问能力，是linux编程下重要偏为重要的概念，在IO编程中广泛设计。希望本文能够让阅读者对用户态和系统态有个基本的认识，增进linux编程技能。
>
> 阅读估计耗时：1h



### 1. What

- ***什么是用户态和系统态？***

  ​	由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络, CPU划分出两个权限等级 – 用户态和内核态。

  ​	一句话，线程在CPU的运行状态分为两种，用户态和系统态。其中系统态较用户态享有更高级的指令权限。

- ***什么是指令权限？***

  ​	每一个汇编语句对应一条`CPU指令`，而非常多的`cpu指令`组成`CPU指令集`。`CPU指令集`是CPU实现软件指挥硬件执行的媒介，比如说读取某个寄存器值，写到某个寄存器上等。也就是说硬件的一切操作都是由CPU指挥的，而硬件的操作是非常繁杂和重要的，非常有可能你执行的某一个非法操作，导致操作系统内核、其他正在运行的程序崩溃。

  ​	如果不对指令进行权限设置的话，当你生成了一个野指针时，该野指针就有可能飘到其他程序内存，甚至硬盘的某个文件上。而因为存在权限指令，这个野指针的取值范围就有限了。

  ​	Intel把`CPU指令集`分为4个级别：

  - `ring 0`：权限最高，可以使用使用指令。==又被叫做内核态，完全在操作系统中运行。==
  - `ring 1`：
  - `ring 2`：
  - `ring 3`：不能操作硬件资源，如IO读写、网卡访问、申请内存。==又被叫做用户态，在应用程序中运行。==

  ​	 linux仅有`ring 0`和`ring 3`这两种权限。

- ***用户态和系统态是什么？***

  ​	在明白`CPU指令集权限`后，现在理解用户态和系统态就很简单了。每个进程中都会有两个栈，分别是用户栈和内核栈，分别对应用户态与内核态的使用。

  ​	如果进程需要执行硬件操作，如读写`IO`等，就必然需要切换到内核态，使用完了，再切换回用户态。



### 2. How

- ***用户态和内核态的切换是如何切换的？***

  - 保留用户态现场（上下文、寄存器、用户栈等）
  - 复制用户态参数，用户栈切到内核栈，进入内核态
  - 额外的检查（因为内核代码对用户不信任）
  - 执行内核态代码
  - 复制内核态代码执行结果，回到用户态
  - 恢复用户态现场（上下文、寄存器、用户栈等）

- ***用户态和内核态是如何分开的？***

  ​	用户态和内核态的分割不仅仅是概念上的区分，是存在实际区别的。每个进程都创建都会分配虚拟空间地址，以`linux32`位操作系统为例，其寻址范围是4G，而操作系统会把虚拟控制地址分为两部分，一部分是内核空间，一部分是用户空间。如下图所示：

  ![img](https://s2.loli.net/2022/02/16/FPTwMRZJhEOGHI4.png)

  - 用户态：只能操作 `0-3G` 范围的低位虚拟空间地址
  - 内核态：`0-4G` 范围的虚拟空间地址都可以操作，尤其是对 `3-4G` 范围的高位虚拟空间地址必须由内核态去操作
  - 补充：`3G-4G` 部分大家是共享的（指所有进程的内核态逻辑地址是共享同一块内存地址），是内核态的地址空间，这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据

- ***用户态切换到内核态的方式是？***![img](https://s2.loli.net/2022/02/16/3XZMWyeQdnS7PKV.png)

  ​	如图不能知道，一个处于用户态的应用程序如果想要操作CPU、IO等内核功能，必须通过系统调用的方式。你可以直接使用系统调用方法、也可以通过shell、函数库等对系统接口进行封装过后的方法来切换到内核态。

- ***什么情况下会导致用户态切换到内核态？***

  - 主动切换：即用户态进程主动通过系统调用的方式切换到内核态，如`fork()`和`read()/write()`操作等。
  - 被动切换：
    - 异常：当 C P U 在执行用户态的进程时，发生了一些没有预知的异常，这时当前运行进程会切换到处理此异常的内核相关进程中，也就是切换到了内核态，如缺页异常
    - 中断：当 C P U 在执行用户态的进程时，外围设备完成用户请求的操作后，会向 C P U 发出相应的中断信号，这时 C P U 会暂停执行下一条即将要执行的指令，转到与中断信号对应的处理程序去执行，也就是切换到了内核态。如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后边的操作等。



​	

​	