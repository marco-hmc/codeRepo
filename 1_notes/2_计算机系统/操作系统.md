## 计算机系统中的开发需知

### 1. 基本概念
#### 1.1 用户态和内核态

* 用户态和内核态的区别
  * 用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同
  * 用户态拥有最低的特权级，内核态拥有较高的特权级
  * **运行在用户态的程序不能直接访问操作系统内核数据结构和程序**
  * 操作系统的**数据都是存放于系统空间的**，**用户进程的数据是存放于用户空间的**。 分开来存放，就让系统的数据和用户的数据**互不干扰**，**保证系统的稳定性**
  * 分开存放，管理上很方便，而更重要的是，**将用户的数据和系统的数据隔离开**，就可以**对两部分的数据的访问进行控制**。这样就可以确保用户程序不能随便操作系统的数据，这样**防止用户程序误操作或者是恶意破坏系统**
  
* [用户态和内核态可以通过指针传递数据吗？](http://blog.chinaunix.net/uid-26611973-id-3190018.html)
  * **用户态不能访问内核态的指针**
    - 为了实现内存的保护，**防止越界访问而造成受保护内存的被非法修改**，甚至造成系统的崩溃，这种直接传递数据指针来传递数据的方式是被禁止的。
  * 内核态可以访问用户态的指针(**有前提**)
    - **必须保证用户态虚拟空间的指针**（虚拟空间的地址），**已经分配物理地址**，**否则指针传入内核态中将不会引发缺页异常而报错**
  * **内核中访问用户进程的地址的时候用copy_from_user，而不是用memcpy直接拷贝**(或者说使用用户态指针)
    - copy_from_user主要是这个函数提供了两个功能
      - 对用户进程传过来的地址范围进行合法性检查
      - 当用户传来的地址没有分配物理地址时，定义了缺页处理后的异常发生地址，保证程序顺利执行
      - **对于用户进程访问虚拟地址，如果还未分配物理地址，就会触发内核缺页异常，接着内核会负责分配物理地址，并修改映射页表**。这个过程对于用户进程是完全透明的。**但是在内核空间发生缺页时，必须显式处理，否则会导致内核出现错误**
    - 直接使用memcpy时为什么没有出现异常
      - **只有用户传来的地址空间没有分配对应的物理地址时才会进行修复，如果用户进程之前已经使用过这段空间，代表已经分配了物理地址，自然不会发生缺页异常**
  
* **两种状态转换**
  - **系统调用**
    - 用户进程**主动要求切换**到内核态的一种方式，用户进程通过系统调用申请操作系统提供的服务程序完成工作
  - **异常**
    - 当CPU在执行运行在用户态的程序时，发现了**某些事件不可知的异常**，这是会**触发由当前运行进程切换到处理此异常的内核相关程序**中，也就到了内核态，比如缺页异常
  - **外围设备中断**
    - 当外围设备完成用户请求的操作之后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条将要执行的指令，转而去执行中断信号的处理程序
    - 比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等
  
* 当发生用户态到内核态的切换时，会发生如下过程（本质上是从“用户程序”切换到“内核程序”）

  - trap指令设置处理器至内核态
  - 保存当前寄存器（栈指针、程序计数器、通用寄存器）
  - 将栈指针设置指向内核栈地址(用户栈切换为内核栈)
  - 将程序计数器设置为一个事先约定的地址上，该地址上存放的是**系统调用处理程序的起始(入口)地址**

  而之后从内核态返回用户态时，又会进行类似的工作

*  如何避免频繁切换

  用户态和内核态之间的切换有一定的开销，如果频繁发生切换势必会带来很大的开销，所以要想尽一切办法来减少切换。这也是面试常考的问题。

  * 减少线程切换：因为线程的切换会导致用户态和内核态之间的切换，所以减少线程切换也会减少用户态和内核态之间的切换

  - 无锁并发编程。多线程竞争锁时，加锁、释放锁会导致比较多的上下文切换
  - CAS算法。使用CAS避免加锁，避免阻塞线程
  - 使用最少的线程。避免创建不需要的线程
  - 协程。在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换
  - 使用用户进程缓冲区：buffer，减少系统调用的调用次数

* 用户进程缓冲区和内核缓冲区

  * 用户进程缓冲区
    * 你看一些程序在读取文件时，会先申请一块内存数组，称为buffer，然后每次调用read，读取设定字节长度的数据，写入buffer。之后的程序都是从buffer中获取数据，当buffer使用完后，在进行下一次调用，填充buffer。所以说：用户缓冲区的目的就是是为了减少系统调用次数，从而降低操作系统在用户态与核心态切换所耗费的时间。除了在进程中设计缓冲区，内核也有自己的缓冲区。

  * 内核缓冲区
    * 当一个用户进程要从磁盘读取数据时，内核一般不直接读磁盘，而是将内核缓冲区中的数据复制到进程缓冲区中。但若是内核缓冲区中没有数据，内核会把对数据块的请求，加入到请求队列，然后把进程挂起，为其它进程提供服务。等到数据已经读取到内核缓冲区时，把内核缓冲区中的数据读取到用户进程中，才会通知进程，当然不同的IO模型，在调度和使用内核缓冲区的方式上有所不同

* 程序计数器PC和指令指针寄存器IP
  * 程序计数器PC
    - 用指令事先编好的程序连续存放在内存程序区中，靠地址+1的方法连续取指执行”。在八位机8080CPU中是采用先取指后执行的串行操作的原理，而其中执行地址+1指令寻址的部件就是程序计数器PC。那么在程序的执行过程中，PC始终是指向下一条要执行的指令
    - 结论：PC中的地址就是需要转移、循环、调用子程序和中断子程序等操作时的断点
  * 指令指针寄存器IP
    - 在向上兼容的十六位机8086CPU中首先分为两个功能部件，即总线接口部件BIU和执行部件EU，BIU负责取指令，EU负责译码执行。并且当BIU执行指令排队栈中的六个字节装满后，（8088CPU是4个字节），EU开始从指令排队栈的出栈口，取指令进行译码执行，同时BIU并行操作向入栈口补充一条取指令命令
    - 指令指针IP则是指向下个条要取指的指令，而不是EU要执行的指令。而断点则应该是要执行的指令内存地址，而不是IP内的下一条要取指的指令地址
  * **PC是模型机中的概念，IP是实际使用的，调试时我们发现，IP实现的就是PC的功能**

#### 1.1 系统调用

* 什么是系统调用

  OS 提供给用户编程时的一些公共子程序，一般为函数或方法

* 为什么要使用系统调用？

  OS **为了安全的管理计算机软硬件资源，不允许程序员直接操作系统资源**，比如（进程、内存、I/O、文件），但是用户可以通过系统调用向 OS 请求相关资源的服务，比如：I/O 的请求和释放、设备启动、文件的创建、读写、删除、进程的创建、撤销、阻塞、唤醒进程间的消息传递、内存的配备和回收等

* 程序员如何使用系统调用，OS 如何响应？

  程序员在代码中首先传递系统调用参数，然后由陷入（trap）指令负责将用户态转换为核心态，从用户栈切换到内核栈，并将返回地址压栈备用，然后 CPU 执行相应的内核服务程序，最后返回用户态

* `int 0x80`指令会让cpu陷入中断，执行对应的0x80中断处理函数。不过在这之前，cpu还需要进行**栈切换**

  因为在linux中，**用户态和内核态使用的是不同的栈**（可以看看这篇[文章](https://blog.csdn.net/yangkuanqaz85988/article/details/52403726)），两者负责各自的函数调用，互不干扰。在执行`int $0x80`时，程序需要由用户态切换到内核态，所以程序当前栈也要**从用户栈切换到内核栈**。与之对应，当中断程序执行结束返回时，当前栈要**从内核栈切换回用户栈**

  这里说的当前栈指的就是ESP寄存器的值所指向的栈。ESP的值位于用户栈的范围，那程序的当前栈就是用户栈，反之亦然。此外寄存器SS的值指向当前栈所在的页。因此，将用户栈切换到内核栈的过程是：

  1. 将当前ESP、SS等寄存器的值存到内核栈上
  2. 将ESP、SS等值设置为内核栈的相应值

  反之，从内核栈切换回用户栈的过程：恢复ESP、SS等寄存器的值，也就是用保存在内核栈的原ESP、SS等值设置回对应寄存器

* 为什么需要单独的进程内核栈？

  所有进程运行的时候，都可能通过系统调用陷入内核态继续执行。假设第一个进程 A 陷入内核态执行的时候，需要等待读取网卡的数据，主动调用 schedule() 让出 CPU；此时调度器唤醒了另一个进程 B，碰巧进程 B 也需要系统调用进入内核态。那问题就来了，如果内核栈只有一个，那进程 B 进入内核态的时候产生的压栈操作，必然会破坏掉进程 A 已有的内核栈数据；一但进程 A 的内核栈数据被破坏，很可能导致进程 A 的内核态无法正确返回到对应的用户态了

#### 1.1 中断

* 操作系统一般是通过中断来从用户态切换到内核态

* 中断一般有两个属性，一个是**中断号**，一个是**中断处理程序**。不同的中断有不同的中断号，每个中断号都对应了一个中断处理程序。在内核中有一个叫**中断向量表**的数组来映射这个关系。当中断到来时，cpu会暂停正在执行的代码，根据中断号去中断向量表找出对应的中断处理程序并调用。中断处理程序执行完成后，会继续执行之前的代码
* 中断分为硬件中断和软件中断，我们这里说的是软件中断，软件中断通常是一条指令，使用这条指令用户可以手动触发某个中断。例如在i386下，对应的指令是int，在int指令后指定对应的中断号，如int 0x80代表你调用第0x80号的中断处理程序
* 中断号是有限的，所有不会用一个中断来对应一个系统调用（系统调用有很多）。**Linux下用int 0x80触发所有的系统调用**，那如何区分不同的调用呢？**对于每个系统调用都有一个系统调用号，在触发中断之前，会将系统调用号放入到一个固定的寄存器，0x80对应的中断处理程序会读取该寄存器的值，然后决定执行哪个系统调用的代码**


- ***什么是计算机系统?***

  ​	操作系统(Operating System, OS)是指控制和管理整个计算机系统的硬件和软件资源,并合理地组织调度计算机的工作和资源的分配,以提供给用户和其他软件方便的接口和环境的程序集合.计算机操作系统是随着计算机研究和应用的发展逐步形成并发展起来的,它是计算机系统中最基本的系统软件.

- ***计算机系统主要研究什么?***

  ​	计算机系统是硬件以及应用软件之间的一个桥梁,相关的内存/文件/输入输出等硬件都由计算机系统负责,除此之外,为了提高CPU的利用率,计算机系统也研究多进程和多线程等提高CPU/内存等资源利用的方法.

  ​	具体来说,操作系统主要研究以下几个方面:
  * **线程/进程管理**
  * **内存管理/磁盘管理**
  * **网络**
  * **I/O设备管理(外设管理)**
  * 文件系统
  * 错误检测以及处理
  * 命令解释系统(Command Interprter System)

- ***计算机系统的发展史***
* 裸机时代
    主要是人工操作,程序员将对应用程序和数据的已穿孔的纸带(或卡片)装入输入机,然后启动输入机把程序和数据输入计算机内存,接着通过控制台开关启动程序针对数据运行;计算完毕,打印机输出计算结果;用户取走结果并卸下纸带(或卡片)后,才让下一个用户上机.
  * 单道批处理系统
    特点是一次只能运行一个进程,只有运行完毕后才能将下一个进程加载到内存里面,所以进程的数据都是直接放在物理内存上的,因此CPU是直接操作内存的物理地址,这个时候不存在虚拟逻辑地址,因为一次只能运行一个程序.
  * 多道批处理系统
    到后来发展出了多道程序系统,它要求在计算机中存在着多个进程,处理器需要在多个进程间进行切换,当一道程序因I/O请求而暂停运行时,CPU便立即转去运行另一道程序.
    问题来了,这么多进程,内存不够用怎么办,各个进程同时运行时内存地址互相覆盖怎么办?
    这时候就出现问题了,链接器在链接一个可执行文件的时候,总是默认程序的起始地址为0x0,但物理内存上只有一个0x0的地址呀?也许你会说:"没关系,我们可以在程序装入内存的时候再次动态改变它的地址."好吧我忍了.但如果我的物理内存大小只有1G,而现在某一个程序需要超过1G的空间怎么办呢?你还能用刚才那句话解释吗?
    操作系统的发展,包括后面的分时系统,其实都是在解决协调各个环节速度不匹配的矛盾.

### 2. CPU/内核篇

- ***应用软件层是可以对硬件进行任何操作吗?***

  ​	虽然前面说了,计算机系统是硬件以及应用软件之间的一个桥梁.但是应用软件并不是享有对硬件所有资源使用权限的,否则软件程序因可能因为误操作/或者恶意软件给系统带来破坏.为此区分了用户态和内核态.

- ***什么是用户态和内核态,区别是什么?***

  - 用户态和内核态是操作系统的两种运行级别,两者最大的区别就是特权级不同
  - 用户态拥有最低的特权级,内核态拥有较高的特权级
  - **运行在用户态的程序不能直接访问操作系统内核数据结构和程序**
  - 操作系统的**数据都是存放于系统空间的**,**用户进程的数据是存放于用户空间的**. 分开来存放,就让系统的数据和用户的数据**互不干扰**,**保证系统的稳定性**
  - 分开存放,管理上很方便,而更重要的是,**将用户的数据和系统的数据隔离开**,就可以**对两部分的数据的访问进行控制**.这样就可以确保用户程序不能随便操作系统的数据,这样**防止用户程序误操作或者是恶意破坏系统**

- ***那应用软件可以进入内核态吗?***

  ​	应用软件在两种情况下可以进入内核态.

  - 系统调用:应用软件只可以通过系统封装好的API,即以系统调用的方式进入内核态.以此限制应用软件对内核态恶意的操作.
  - 异常:当CPU在执行运行在用户态的程序时,发现了某些事件不可知的异常,这是会触发由当前运行进程切换到处理此异常的内核相关程序中,也就到了内核态,比如缺页异常.

- ***用户态切换到内核态的时候发生了什么?***

  - trap指令设置处理器至内核态
  - 保存当前寄存器(栈指针/程序计数器/通用寄存器)
  - 将栈指针设置指向内核栈地址(用户栈切换为内核栈)
  - 将程序计数器设置为一个事先约定的地址上,该地址上存放的是**系统调用处理程序的起始(入口)地址**

  > 每次用户态和内核态的切换是有一定开销的

- ***如何避免用户态和内核态频繁切换带来的开销?***

  - 减少线程切换:因为线程的切换会导致用户态和内核态之间的切换,所以减少线程切换也会减少用户态和内核态之间的切换

  - 无锁并发编程.多线程竞争锁时,加锁/释放锁会导致比较多的上下文切换
  - CAS算法.使用CAS避免加锁,避免阻塞线程
  - 使用最少的线程.避免创建不需要的线程
  - 协程.在单线程里实现多任务的调度,并在单线程里维持多个任务间的切换
  - 使用用户进程缓冲区:buffer,减少系统调用的调用次数


### 4. 内存管理

1. [blog: 20张图片解开内存管理的迷雾](https://mp.weixin.qq.com/s?__biz=MzIwNTc4NTEwOQ==&mid=2247491042&idx=1&sn=6a27149508df23d5414d279feac1c304&chksm=972acc98a05d458e5a147f1fd8306ca4f384903ec5b18560b67b15849f43942e60563f0ce5bf&mpshare=1&scene=24&srcid=0321sCT49uCvhw9cMJGzFOic&sharer_sharetime=1616262001659&sharer_shareid=0722ed5128948b6436f8552f291f9b0b#rd)
2. [blog: 1.3w字,操作系统高频面试题分享](https://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247490061&idx=2&sn=12149cbf01c461cb6e7193c87f86947b&chksm=fddeccc9caa945dfd40e5b721d3de6c072e6c63090d517c2abd7cdbad03913ffe1894ecf515e&scene=126&sessionid=1598581626&key=327ff69e53d289e265ba4be42c78ab289d247b013a397b5e56a76f8e15d507e2b246f5f8e182aea30e297541e608b44b6afc4aef2a158685ddc7b89ac3819a93af1a874e7eb8032ca33fcbfdc490c6d80ff937238fae8bf025d4df48edd109b337fce874a51bcfd3c4d6c73519144f1d2bb2d2642e053526abb49c65f1ad7a7a&ascene=1&uin=MTY3MDE4MjUzNw%3D%3D&devicetype=Windows+10+x64&version=62090529&lang=zh_CN&exportkey=Ae7A2lvgN6N2S9zIIGtxrwk%3D&pass_ticket=IxOgoA0uCVNmIWk3JlME4s%2BV8YtCCJRms%2FWOtZaGjo%2F4rRk9WXulOQCMRIzciJYH)






## 虚拟内存
* [详见1](http://mp.weixin.qq.com/s?__biz=MzIwNTc4NTEwOQ==&mid=2247491042&idx=1&sn=6a27149508df23d5414d279feac1c304&chksm=972acc98a05d458e5a147f1fd8306ca4f384903ec5b18560b67b15849f43942e60563f0ce5bf&mpshare=1&scene=24&srcid=0321sCT49uCvhw9cMJGzFOic&sharer_sharetime=1616262001659&sharer_shareid=0722ed5128948b6436f8552f291f9b0b#rd)

* 虚拟内存概念
  * 虚拟内存技术是操作系统的一种扩容技术，它使得不同进程在运行过程中，它所看到的是**自己独自占有了当前系统的4G内存**。所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。 
  * 事实上，在每个进程创建加载时，内核只是为进程“创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，**实际上并不立即就把虚拟内存对应位置的程序数据和代码**（比如.text .data段）**拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好**（叫做存储器映射），**等到运行到对应的程序时，才会通过缺页异常，来拷贝数据**
  * 还有进程运行过程中，要动态分配内存，比如**malloc时，也只是分配了虚拟内存**，即为这块虚拟内存对应的页表项做相应设置，**当进程真正访问到此数据时，才引发缺页异常**
  * 请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换
* **虚拟内存的好处**
  * 扩大地址空间
  * **内存保护**：每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。虚存还对特定的内存地址提供写保护，可以防止代码或数据被恶意篡改
  * 公平内存分配。采用了虚存之后，每个进程都相当于有同样大小的虚存空间
  * 当进程通信时，可采用虚存共享的方式实现
  * **方便内存映射：当不同的进程使用同样的代码时，比如动态库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存。还有COW**
  * 虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。在内存中可以保留多个进程，系统并发度提高
  * **惰性分配**：在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，首次使用这块内存时才分配物理内存，可以利用碎片
* **虚拟内存的代价**
  * **虚存的管理需要建立很多数据结构(如页表等)，这些数据结构要占用额外的内存**
  * **虚拟地址到物理地址的转换，增加了指令的执行时间**
  * **页面的换入换出需要磁盘I/O，这是很耗时的**
  * 如果一页中只有一部分数据，会浪费内存
* 颠簸(thrashing)
  * 分页(Page)写入磁盘的过程被称作Page-Out，分页(Page)从磁盘重新回到内存的过程被称作Page-In。当内核需要一个分页时，但发现此分页不在物理内存中(因为已经被Page-Out了)，此时就发生了分页错误（Page Fault）
  * 当系统内核发现**可运行内存变少**时，就会通过Page-Out来释放一部分物理内存。经管Page-Out不是经常发生，但是如果**Page-out频繁不断的发生**，直到当内核管理分页的时间超过运行程式的时间时，**系统效能会急剧下降**。这时的**系统已经运行非常慢或进入暂停状态**，这种状态亦被称作thrashing(颠簸)
  * 解决策略
    * 如果是因为页面置换策略失误，可以修改置换算法来解决这个问题
    * 如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量
    * 否则，还剩下两个办法：1. 终止该进程；2. 增加物理内存容量
* TLB
  * TLB( Translation Look- aside buffer)**专门用于缓存内存中的页表项**，一般**在MMU单元内部**，页表一般存储在物理内存中。**当处理器要访问一个虚拟地址时，首先会在TLB中查询**。如果TLB表项中没有相应的表项，称为TLB Miss，那么就需要访问页表来计算出相应的物理地址。如果TLB表项中有相应的表项，那么直接从TLB表项中获取物理地址，称为TLB命中

## 缺页中断

* 在请求分页系统中，可以**通过查询页表中的状态位来确定所要访问的页面是否存在于内存中**。每当所要访问的页面不在内存时(缓存不命中)，会产生一次缺页中断，此时**操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存**
* 缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤
  * 保护CPU现场
  * 分析中断原因
  * 转入缺页中断处理程序进行处理
  * 恢复CPU现场，继续执行
* 但是缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，**与一般的中断存在区别**
  * **在指令执行期间产生和处理缺页中断信号**
  * **一条指令在执行期间，可能产生多次缺页中断**
  * **缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令**

* 缺页中断就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问
  当进程执行过程中发生缺页中断时，需要进行页面换入，步骤如下：
  1. 首先**硬件会陷入内核，在堆栈中保存程序计数器。大多数机器将当前指令的各种状态信息保存在CPU中特殊的寄存器中**
  2. 启动一个汇编代码例程保存通用寄存器及其它易失性信息，以免被操作系统破坏。这个例程将操作系统作为一个函数来调用。（在页面换入换出的过程中可能会发生上下文换行，**导致破坏当前程序计数器及通用寄存器中本进程的信息**）
  3. 当操作系统发现是一个页面中断时，查找出来发生页面中断的虚拟页面（进程地址空间中的页面）。这个虚拟页面的信息通常会保存在一个硬件寄存器中，如果没有的话，操作系统必须检索程序计数器，取出这条指令，用软件分析该指令，通过分析找出发生页面中断的虚拟页面
  4. **检查虚拟地址的有效性及安全保护位。如果发生保护错误，则杀死该进程**
  5. 操作系统查找一个**空闲的页框**(物理内存中的页面)，如果**没有空闲页框则需要通过页面置换算法找到一个需要换出的页框**
  6. **如果找的页框中的内容被修改了，则需要将修改的内容保存到磁盘上**，此时会引起一个写磁盘调用，发生上下文切换（在等待磁盘写的过程中让其它进程运行）（注：此时需要将页框置为忙状态，以防页框被其它进程抢占掉）
  7. 页框干净后，操作系统根据虚拟地址对应磁盘上的位置，将保持在磁盘上的页面内容复制到“干净”的页框中，此时会引起一个读磁盘调用，发生上下文切换
  8. 当磁盘中的页面内容全部装入页框后，向操作系统发送一个中断。操作系统更新内存中的页表项，将虚拟页面映射的页框号更新为写入的页框，并将页框标记为正常状态
  9. 恢复缺页中断发生前的状态，将程序指令器重新指向引起缺页中断的指令
  10. 调度引起页面中断的进程，操作系统返回汇编代码例程
  11. 汇编代码例程恢复现场，**将之前保存在通用寄存器中的信息恢复**

* 缺页中断的过程涉及了**用户态和内核态之间的切换**，**虚拟地址和物理之间的转换**（这个转换过程需要使用MMU和TLB）

## 页面置换算法

* 为提高内存利用率，解决内存供不应求的问题，更加合理的使用内存，人们创造了**分页式内存抽象**。同时有一个**虚拟内存**的概念，是指将内存中暂时不需要的部分写入硬盘，看上去硬盘扩展了内存的容量，所以叫做“虚拟”内存。使用虚拟内存，应用程序可以使用比实际物理内存更大的内存空间。可以认为这个更大的内存空间就在硬盘上，只有将某一部分需要被用到时，才被写入真实内存；当它暂时不再被用到时，又被写回硬盘。分页式内存管理将物理内存分为等大的小块，每块大小通常为1K、2K、4K等，称为**页帧；**逻辑内存（使用虚拟内存技术扩大的内存，可认为其位于硬盘上）也被分为等大的小块，称为**页**；且**页和页帧**的大小一定是一样的，它是写入真实内存和写回硬盘最小单位
* 重要概念：
  * 使用位：每个页帧都有一个使用位，记录此页帧是否被使用
  * 修改位（脏位）：每个页帧都有一个脏位，记录此页帧是否被更改。调出真实内存时，被更改过的页帧要写回硬盘，未被更改过的页帧直接扔掉即可，因为硬盘上此页帧的副本仍然有效
  * 逻辑地址：使用虚拟内存技术扩大后的内存的地址
  * 物理地址：真实内存的地址
* 当然，进程载入到真实内存才可以运行，而进程代码使用的是逻辑地址，所以牵扯到一个**地址转换**的问题，将逻辑地址转换为物理地址。逻辑地址可分为两段，前半段代表页号，后半段代表页内偏移，物理地址也可分为两段，前半段代表页帧号，后半段代表页内偏移。地址转换的方法即，将逻辑地址的页号对应为物理地址的页帧号（对应关系记录在一张表中，比如页号为5，对应到真实内存中页帧号为3），页内偏移不同变化（页和页帧的大小是一样的）

假设某一时刻内存页帧已经被写满了，但这时又需要将一个页写到物理内存中，就需要将原本在物理内存中的某一页换出来。如果置换不当，就会导致刚刚被换出到硬盘的页又要被写回内存，减慢系统运行的速度。页面置换算法就是考虑将哪一页换出来以获得优良性能的方法。

### Optimal算法（最优算法）

　　首先介绍最优算法，它需要知道以后要被用到的页，然后将不会被用到的页换出内存；如果所有页都会被用到，就把需要使用时间离现在最长的页换出，以尽量使不好的情况晚发生。这种方法能使系统获得最佳性能，但是，它是不可能实现的......因为当前无法获知以后哪些页要被用到。不过最优算法还是能够作为其他算法优秀程度的衡量

### FIFO（First-In First-Out，先进先出）算法

　　FIFO算法的思想很简单，就是置换出当前已经待在内存里时间最长的那个页。FIFO算法的运行速度很快，不需要考虑其他的因素，需要的开销很少。但是正是由于没有考虑页面的重要性的问题，FIFO算法很容易将重要的页换出内存

### Second Chance（二次机会）算法

　　为了避免FIFO算法将重要的页换出内存，Second Chance算法提供了一些改进。Second Chance算法在**将页面换出内存前检查其使用位（使用位前文有介绍），如果其使用位为1，证明此页最近有被使用，猜测它还可能被使用，于是不把它置换出内存，但是把其使用位置为0，随后检查下一个页面，直到发现某页的使用位为0，将此页置换出内存**

### Clock算法（时钟轮转法）

　　为了节约Second Chance算法一个接着一个检查使用位的开销，时钟轮转法又提出了改进。**时钟轮转法将所有的页组成一个圆**，圆心的指针指向下一个要被置换的页面，**置换前同样检查使用位，如果使用位为1，同样将其使用位置为0，随后将顺指针旋转，检查下一个页面，直到发现某页的使用位为0，将此页置换出内存**。很容易理解此算法为什么叫“时钟”轮转法

### LRU（Least Recent Used, 最近最少使用）算法

　　为获得对最优算法的模拟，提出了LRU算法。由于当前时间之后需要用到哪些页无法提前获知，于是记录当前时间之前页面的使用情况，认为之前使用过的页面以后还会被用到。在置换时，将最近使用最少的页面换出内存。此种方法的开销比较大

### NRU（Not Recent Used， 最近未使用）算法

　　前面提到修改位和使用位，NRU算法利用这两个标志位将所有页帧分为4组：

　　	第0组：修改位和使用位都为0；

　　	第1组：修改位为0，使用位为1；

　　	第2组：修改位为1，使用位为0；

　　	第3组：修改位和使用位都为1。

　　NRU算法从组数最小的一组中随机选择一个页面将其移出内存。可能有人会发现第2组这种情况根本不会出现，如果一个页帧被修改，其修改位会被置1，同时它也被使用了，其使用位也会被置1；即不会出现被修改但是没有被使用的情况。真实情况是，页帧的使用位会被定时清零，这样第3组经过一次清零就会变成第2组。这也符合“最近”未使用，即很久以前被使用的页帧被清零了，不在统计范围内，只要“最近”没有被使用，就很有可能被移出。

　　NRU算法不是最好的，但是它使用起来开销很小，用较小的代价就得到了不错的效果，不失为一种不错的算法

说说内存碎片的原因，怎么解决
硬件虚拟化是什么东西


- ***linux下线程和进程为什么有人说是一样的？***

  ​	linux的进程本身就很轻量了，线程是当做进程实现的，只是线程创建的时候考虑到共享内存之类的数据问题。但是线程的上下文切换还是要比进程小。



怎么理解操作系统？
你的理解基本是正确的，但可以稍微补充和澄清一些细节，以更全面地理解操作系统的概念和功能。以下是对你提供的内容的详细解释和补充：

### 操作系统的定义

操作系统（OS）是管理计算机硬件和软件资源的系统软件，为计算机程序提供一个运行环境。操作系统的主要功能包括：

1. **进程管理**：

   - 创建、调度和终止进程。
   - 提供进程间通信和同步机制。

2. **内存管理**：

   - 分配和释放内存。
   - 管理虚拟内存和物理内存。

3. **文件系统管理**：

   - 提供文件和目录的创建、删除、读写等操作。
   - 管理文件系统的结构和存储。

4. **设备管理**：

   - 管理输入输出设备，如键盘、鼠标、显示器、磁盘等。
   - 提供设备驱动程序，处理设备的中断和请求。

5. **用户接口**：
   - 提供命令行界面（CLI）或图形用户界面（GUI），供用户与系统交互。

### 操作系统对硬件的控制

操作系统能够对计算机设备的所有硬件进行控制，这种控制能力来源于指令集架构（ISA）。指令集是处理器支持的指令的集合，操作系统通过这些指令与硬件进行交互。

#### 指令执行过程

1. **获取指令**：

   - 指令可以通过输入输出（IO）设备获取，或者在程序运行时将指令加载到内存中，从内存读取指令。

2. **指令译码**：

   - CPU 从内存中读取指令，并对指令进行译码，确定需要执行的操作。

3. **执行操作**：

   - CPU 根据译码结果，调用相关硬件资源（如寄存器、算术逻辑单元等）执行操作。

4. **写回结果**：
   - 执行操作的结果写回到目标地址（寄存器或内存）。

### 操作系统的运行环境

操作系统为程序提供了一个完善的运行环境，控制流程如下：

1. **指令存储**：

   - 操作系统将指令存储在内存的特定区域，称为代码段（Code Segment）。程序运行时，指令加载到代码段中，实现了可编程性。

2. **事件中断**：

   - 当发生事件中断时，操作系统将中断信号插入到指令流中，实现交互操作。中断处理程序会处理中断事件，并恢复正常执行。

3. **内存管理**：
   - 操作系统负责内存的分配和释放，标记内存的使用状态。当程序需要申请内存时，操作系统会处理内存请求，并分配适当的内存区域。

### 操作系统的状态机模型

操作系统可以被看作是一个基于硬件的复杂状态机。状态机的状态存在于计算机设备的各个寄存器和内存中，CPU 会读取这些状态并执行相应的操作。

#### 状态机的状态

1. **寄存器状态**：

   - 寄存器保存当前指令的执行状态、程序计数器、堆栈指针等信息。

2. **内存状态**：

   - 内存保存程序的代码段、数据段、堆栈段等信息。

3. **设备状态**：
   - 输入输出设备的状态，如键盘缓冲区、显示器状态等。

### 总结

你的理解是正确的，操作系统确实为计算机设备提供了一个运行环境，并对硬件进行控制。操作系统通过指令集与硬件交互，管理进程、内存、文件系统和设备。操作系统可以被看作是一个基于硬件的复杂状态机，状态机的状态存在于寄存器和内存中，CPU 通过读取这些状态执行相应的操作。通过这些机制，操作系统能够高效地管理和调度计算机资源，确保系统的稳定和安全。

如果是从计算机的角度出发. 我感觉可以这么理解.
计算机=程序+硬件
现代计算机=程序+硬件+操作系统

狭义的程序=命令段+数据段.


*  深入理解计算机系统 第3版（CSAPP）
   *  先看**深入理解计算机系统**，操作系统方面的神书，内容非常经典，而且比较通俗易懂，适合入门，软件的话建议先学习第二部分和第三部分，再根据个人情况学习第一部分。
*  《程序员自我修养》 
   *  如果想对**编译链接**的原理进行深入学习，可以参考**程序员的自我修养**，这本书非常详细的讲解了程序编译过程中的具体细节。
*  操作系统 精髓与设计原理 第8版
   *  然后再学习**操作系统 精髓与设计原理**，这本书比现代操作系统更通俗易懂，可以结合CSAPP一起看，两本书的知识点相互有所弥补。
*  ==协程==(GO web2.0时代重要的东西.处理高并发)

