## 高速缓存管理

- 缓存

  ​	从寄存器、`L1/L2`高速缓存、内存、闪存，到磁盘/光盘/磁带/存储网络，计算机的各级存储器硬件组成了一个金字塔结构。越是底层存储容量越大。然而访问速度也越慢，具体表现为更小的带宽和更大的延迟。因而这很自然的便成为一个金字塔形的逐层缓存结构。由此产生了三类基本的缓存管理和优化问题：

  - 缓存三类管理问题
    - 预读
      - 即将读取前后一片数据都提前读取到缓存中，因为磁盘IO读写最大的问题在于硬盘的寻址过程，所以这里额外读取数据的代价很小。除此之外，这些前后数据很有可能是下一次的读写数据。
      - [linux内核文件预读机制详解](https://blog.csdn.net/kunyus/article/details/104620057)
    - 替换
      - 从缓存中丢弃无用数据;
    - 写回
      - 把脏数据从缓存中保存到慢速存储
  - 缓存命中率
    - [缓存命中率介绍](https://blog.csdn.net/qq_22585453/article/details/110080900)

对于所有缓存模式来说，可以抽象为是一种映射。
比如说查询一个变量的值，其虚拟地址为0x12345678。
首先是通过缓存映射计算，如果映射值有效，则返回缓存值；否则继续查找；

如果缓存命中，实际上在缓存中，都需要解决映射问题。
即内存和缓存如何关联上，

```
├── 基本概念
│   ├── 高速缓存的定义
│   ├── 高速缓存的重要性
├── 缓存层次结构
│   ├── L1 缓存
│   ├── L2 缓存
│   └── L3 缓存
│   └── 缓存行构成
├── 缓存映射方式
│   ├── 直接映射
│   ├── 全相联映射
│   └── 组相联映射
├── 缓存替换策略
│   ├── 最近最少使用（LRU）
│   ├── 先进先出（FIFO）
│   ├── 随机替换（Random Replacement）
│   └── 其他替换策略
├── 缓存写策略
│   ├── 写直达（Write-Through）
│   ├── 写回（Write-Back）
│   └── 写合并（Write-Combining）
├── 缓存一致性
│   ├── 缓存一致性问题
│   ├── 缓存一致性协议
│   │   ├── MESI 协议
│   │   ├── MOESI 协议
│   │   ├── MSI 协议
        └── 其他一致性协议
```

### 1. 基本概念
* **高速缓存的定义**
    高速缓存（Cache）是计算机系统中介于处理器和主存之间的一种小容量、高速存储器，用于存储处理器近期可能访问的数据或指令，从而减少主存访问的延迟。

* **高速缓存的重要性**
    - 提高数据访问速度，减少处理器等待时间。
    - 改善系统性能，尤其是在多任务处理和大数据量操作中。
    - 平衡处理器与主存之间的速度差异。

### 2. 缓存层次结构
* **L1 缓存**
    - **位置**：最靠近处理器核心的缓存。
    - **特点**：访问速度最快，但容量较小（通常为几十KB）。
    - **用途**：分为指令缓存和数据缓存，用于加速处理器对指令和数据的访问。

* **L2 缓存**
    - **位置**：位于 L1 缓存与 L3 缓存或主存之间。
    - **特点**：容量较大（通常为几百KB到几MB），速度稍慢于 L1 缓存。
    - **用途**：存储处理器近期使用的数据和指令。

* **L3 缓存**
    - **位置**：通常为多核心共享缓存。
    - **特点**：容量最大（通常为几十MB），但速度较慢。
    - **用途**：作为 L1 和 L2 缓存的后备存储。

* **缓存行构成**

    ```
    +----------------+----------------+----------------+----------------+
    |      标记      |      数据      |    有效位      |     脏位       |
    +----------------+----------------+----------------+----------------+
    | Tag (Address)  | Data (Value)   | Valid Bit      | Dirty Bit      |
    +----------------+----------------+----------------+----------------+
    ```

    1. **标记（Tag）**：用于标识缓存行中存储的数据块在主存中的位置。
    2. **数据（Data）**：实际存储的数据值。
    3. **有效位（Valid Bit）**：指示缓存行中的数据是否有效。
    4. **脏位（Dirty Bit）**（仅在写回策略中使用）：指示缓存行中的数据是否已被修改但尚未写回主存。

    简单来说，标记用于判断缓存是否命中；有效位和脏位都是用于保证缓存和内存的一致性。

### 3. 缓存映射方式

大部分数据的存储都可以看成是一种键值方式，键的意义在于标识数据的唯一性，是 A 数据还是 B 数据。比如说文件数据，其键就是路径；对于报文数据，其键就是报文首部。键的存在使得数据可以区分。键的形式可以作为数据存在，如报文首部，也可以不作为数据存在，如内存地址。

对于数据快速查询有要求的场景，通常会要求一组映射关系，使得可以通过键快速找到值；如果没有的话，则需要全遍历比较键是否一致。

缓存的实现方式是为了解决数据的快速查询问题。因此，缓存需要有键值对，也需要有映射关系。缓存行结构中的标记（Tag）就是充当键的作用，还需要一种映射方式来实现快速查询。

* **直接映射**

  直接映射是一种简单的缓存映射方式。具体思路如下：

  - 缓存空间为 `[0, a]`，内存大小为 `[0, n*a]`。
  - 如果虚拟内存地址为 `[0, n]`，则在缓存空间 `0` 查找，然后比较标记是否一致。
  - 如果虚拟内存地址为 `[n, 2n]`，则在缓存空间 `1` 查找，然后比较标记是否一致。

  这种映射方式可行，但过于简单。一个主要问题是，内存块在缓存中的映射位置是固定的，这导致连续固定间隔的数据每次都要替换缓存；而且没有基于时空局部性这个先验条件做任何优化，即相邻的数据往往更容易被访问。

* **优化思路**
优化思路包括以下两点：

   1. **减少冲突**：避免内存块在缓存中的映射位置固定，减少缓存替换的频率。
   2. **利用时空局部性**：相邻的数据往往更容易被访问，优化缓存映射方式以提高命中率。

在不改变硬件的前提下，直接映射的优化手段有限。可以考虑分级映射（类似于分级页表）或映射到某一个块上再局部全遍历。

* **其他缓存映射方式**

优化手段的组合和偏重产生了其他的缓存映射方式，如全相联映射和组相联映射，这些都是硬件实现的能力。

   - **全相联映射**：每个内存块可以映射到缓存中的任何位置，需要逐个遍历缓存中的所有块，检查标记是否一致。
   - **组相联映射**：将缓存分成若干组，每个内存块可以映射到某一组内的任意位置，结合了直接映射和全相联映射的优点。

### 4. 缓存替换策略
对于高速缓存的替换策略和其他的缓存替换策略并无不同，也是如下方法：
   * 最近最少使用
   * 先进先出
   * 随即替换
   * 最不常使用
   * 最近未使用
只是要注意的是缓存的替换策略是硬件实现的。

### 5. 缓存写策略

缓存写策略通常是由硬件预先定义和实现的，具体的策略在设计时已经确定。然而，在某些高级系统中，硬件可能允许操作系统或用户根据特定条件动态选择或配置写策略。

* **写直达（Write-Through）**
    - **描述**：每次写操作同时更新缓存和主存。
    - **优点**：主存中的数据始终是最新的。
    - **缺点**：写操作开销大。

* **写回（Write-Back）**
    - **描述**：仅在缓存行被替换时才将数据写回主存。
    - **优点**：减少写操作次数，提高性能。
    - **缺点**：主存数据可能过时。

* **写合并（Write-Combining）**
    - **描述**：将多次写操作合并成一次，从而减少写操作。
    - **优点**：减少总线带宽使用，提升写性能。

### 6. 缓存一致性

* **缓存一致性问题**
    - 当多个处理器核心共享内存时，不同缓存中可能存储相同内存位置的副本，可能导致数据不一致。

* **缓存一致性协议**
    * **MESI 协议**
    - **状态**：Modified、Exclusive、Shared、Invalid。
    - **特点**：保证缓存数据的一致性，支持高效的读写操作。

* **MOESI 协议**
    - **状态**：在 MESI 基础上增加 Owned 状态，支持更高效的共享访问。

* **MSI 协议**
    - **状态**：Modified、Shared、Invalid。
    - **特点**：最基础的一致性协议，开销小。

* **其他一致性协议**
    - **伪共享解决方案**：通过减少缓存行冲突来优化性能。

### 7. 其他
* **缓存行和数据对齐的关系**
    * **缓存行**
        缓存行（Cache Line）是缓存中数据存储的基本单位。缓存行的大小通常为 32 字节、64 字节或 128 字节。缓存行的大小决定了每次从主存加载到缓存中的数据块的大小。

    * **数据对齐**
        数据对齐（Data Alignment）是指数据在内存中的存储地址满足特定的对齐要求。对齐要求通常是数据类型大小的倍数。例如，4 字节的整数通常要求 4 字节对齐，即其地址必须是 4 的倍数。

    * **缓存行和数据对齐的关系**
        1. **提高缓存命中率**：数据对齐可以提高缓存命中率。当数据对齐时，数据在内存中的存储地址满足缓存行的对齐要求，从而减少缓存未命中的概率。
        2. **减少缓存抖动**：数据对齐可以减少缓存抖动。当数据对齐时，数据在内存中的存储地址满足缓存行的对齐要求，从而减少缓存行的替换次数。
        3. **提高数据访问速度**：数据对齐可以提高数据访问速度。当数据对齐时，数据在内存中的存储地址满足缓存行的对齐要求，从而减少内存访问延迟。

* 预取指令
    预取指令（Prefetch Instruction）是一种用于提前将数据加载到缓存中的指令。预取指令可以显著减少缓存未命中的概率，提高数据访问速度。

* 预取指令的类型
    1. **数据预取**：用于提前将数据加载到缓存中。
    2. **指令预取**：用于提前将指令加载到缓存中。
