---
title: "多线程中各种的锁机制"
layout: post
author: "Marco"
header-style: text
hidden: true
tags:
  - c++
  - 锁
  - 多线程
---

## C++中的线程同步

### 1. 基本概念

- ***什么是线程同步？***

  ​	==同步就是协同步调，按预定的先后次序进行运行。==如：你说完，我再说。这里的同步千万不要理解成那个同时进行，应是指协同、协助、互相配合。线程同步是指多线程通过特定的设置（如互斥量，事件对象，临界区）来控制线程之间的执行顺序（即所谓的同步）也可以说是在线程之间通过同步建立起执行顺序的关系，如果没有同步，那线程之间是各自运行各自的！

  ​	线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步（下文统称为同步）。

- ***线程冲突例子***

  ​	一般来说多线程任务都需要考虑到线程同步，如果不考虑，甚至乎两个线程的cout都会出错。因为`cout`也是一种需要竞争的资源。会出现多线程同时竞争cout，两个线程的内容可能会被同时输出。

- ***线程同步的四种方式***

  - 临界区
    - 临界区（Critical Section） 保证在某一时刻只有一个线程能访问数据的简便办法。在任意时刻只允许一个线程对共享资源进行访问。如果有多个线程试图同时访问临界区，那么在有一个线 程进入后其他所有试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开。临界区在被释放后，其他线程可以继续抢占，并以此达到用原子方式操 作共享资源的目的。
  - 互斥锁
    - 互斥对象和临界区很像，采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程同时访问。当前拥有互斥对象的线程处理完任务后必须将线程交出，以便其他线程访问该资源。
  - 信号量
    - 信号量用来干嘛的呢？搜寻答案的话，很多人都会告诉你主要用于线程同步的，意思就是线程通信的。简单来说，比如我运行了2个线程A和B，但是我希望B线程在A线程之前执行，那么我们就可以用信号量来处理。
    - 一般是将当前可用资源计数设置为最 大资源计数，每增加一个线程对共享资源的访问，当前可用资源计数就会减1 ，只要当前可用资源计数是大于0 的，就可以发出信号量信号。但是当前可用计数减小 到0 时则说明当前占用资源的线程数已经达到了所允许的最大数目，不能在允许其他线程的进入，此时的信号量信号将无法发出。
  - 事件
    - 通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作

### 2. 实战篇

​	c++的标准库中是没有实现临界区、信号量的。临界区相关概念，在windows下的c++开发有，而信号量则存在`POSIX`规范的实现。

#### 2.1 互斥锁

- ***c++中有哪些和锁相关的api？***

  ​	`mutex`和`lock_guard`是最基本的。`mutex`就是互斥锁，通过`lock()`上锁，通过`unlock()`解锁。但是有可能在`lock()`和`unlock()`的运行过程之中，抛出异常，导致没办法正常解锁，从而产生了死锁。

  ​	而`lock_guard`就是为了解决这个的，这是一个基于RAII思想的一个管理锁的的一个类，能够在对象超出生存周期，即析构的时候保证能够解锁。

  ```c++
  // 1. without lock_guard
  std:: mutex g_mutex;
  ...
      g_mutex.lock();
  	foo();
  	g_mutex.unlock();
  ...
  // 2. with lock_guard
  std:: mutex g_mutex;
  ...
      std::lock_guard<std::mutex>> m(g_mutex);
  	foo();
  ```

  ​	而`lock_guard`是一个相对死板的操作，不支持频繁上锁解锁的操作，也就是说`lock_guard`始终拥有`mutex`。而如果你的操作中涉及到加锁对象的解锁和加锁操作的话，或者是使用了条件变量的情况下，使用`unique_lock`才能满足你的要求。

  > [参考](https://www.cnblogs.com/fnlingnzb-learner/p/9542183.html)

#### 2.2 条件变量(条件锁)

- ***条件变量如何使用？***

  ```cpp
  #include <deque>
  #include <functional>
  #include <iostream>
  #include <fstream>
  #include <thread>
  #include <string>
  #include <mutex>
  #include <condition_variable>
  
  std::deque<int> q;
  std::mutex mu;
  std::condition_variable cond;
  
  //数据的生产者
  void function_1() {
  	int count = 10;
  	while (count > 0) {
  		std::unique_lock<std::mutex> locker(mu);
  		q.push_front(count);
  		locker.unlock();
  		//cond.notify_one();
  		cond.notify_all();
  		std::this_thread::sleep_for(std::chrono::seconds(1));
  		count--;
  	}
  }
  //数据的消费者
  void function_2() {
  	int data = 0;
  	while (data!=1) {
  		std::unique_lock<std::mutex> locker(mu);
  		//函数2可能会被伪激活，因此，传入lambda表达式作为第二个参数进行控制
  		cond.wait(locker, []() {return !q.empty(); });
  			data = q.back();
  			q.pop_back();
  			locker.unlock();
  			std::cout << "t2 got a value from t1: " << data << std::endl;
  	}
  }
  
  int main() {
  	std::thread t1(function_1);
  	std::thread t2(function_2);
  	t1.join();
  	t2.join();
  
  }
  ```

#### 2.3 自旋锁

- ***什么是自旋锁***

  ​	自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。

#### 2.4 递归锁

- ***什么是递归锁***

  ​	std::recursive_mutex 与 std::mutex 一样，也是一种可以被上锁的对象，但是和 std::mutex 不同的是，std::recursive_mutex 允许同一个线程对互斥量多次上锁（即递归上锁），来获得对互斥量对象的多层所有权，std::recursive_mutex 释放互斥量时需要调用与该锁层次深度相同次数的 unlock()，可理解为 lock() 次数和 unlock() 次数相同，除此之外，std::recursive_mutex 的特性和 std::mutex 大致相同。

  ​	例如函数a需要获取锁mutex，函数b也需要获取锁mutex，同时函数a中还会调用函数b。如果使用std::mutex必然会造成死锁。但是使用std::recursive_mutex就可以解决这个问题。

#### 2.5 乐观和悲观锁

- ***悲观锁***

  ​	总是假设最坏的情况，每次拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想要拿到它的数据就会被一直阻塞直到它拿到锁，传统的关系型数据库里面就用到了很多这种锁机制，比如行锁、表锁、读锁、写锁等，都是在操作之前先上锁。

- ***乐观锁***

  ​	顾名思义，很乐观，每次拿数据的时候都认为别人不会修改，**所以不会上锁**，但是在更新的时候会去判断一下别人有没有修改这个数据，可以使用版本号等机制。cas就是乐观锁的一种经典实现方式。

  - **CAS**是乐观锁的一种实现，CAS全称是比较和替换，CAS的操作主要由以下几个步骤组成：
    1. 先查询原始值
    2. 操作时比较原始值是否修改
    3. 如果修改，则操作失败，禁止更新操作，如果没有发生修改，则更新为新值
  - CAS也是一种自旋锁，**当线程较少时，实现自旋效率最好，因为修改次数少，判断次数少，当线程竞争强烈（多）时，应该采用加锁的方法。**

#### 2.6 读写锁

- ***什么是读写锁？***

  ​	c++标准库并不支持读写锁，所以我们需要自己去实现。而读写锁则是，上读锁的时候可以读不给写，上写锁的时候不可以写也不可以读。

- ***c++读写锁的实现***

  ​	[参考链接](https://zhuanlan.zhihu.com/p/374042984)



#### 2.7 信号量

- ***信号量的实现***

  ​	[参考链接](https://segmentfault.com/a/1190000006818772)	
  

#### 2.8 临界区

- ***c++中的临界区***

  ​	c++的标准库是没有临界区概念的，而一些跨平台且涉及临界区的c++程序中，在windows则是用windows支持的Critical_Section，而linux则是通过pthread_mutex_t接口来模拟临界区。

- ***临界区的linux实现***

  ​	[参考链接](https://blog.csdn.net/lqy971966/article/details/104533687)



-----------------------------------------------------

---
title: "死锁(转载)"
layout: post
author: "Marco"
header-style: text
hidden: true
tags:
  - 计算机系统
  - 多线程
---

<!-- GFM-TOC -->

- [必要条件](#必要条件)
- [处理方法](#处理方法)
- [鸵鸟策略](#鸵鸟策略)
- [死锁检测与死锁恢复](#死锁检测与死锁恢复)
  - [1. 每种类型一个资源的死锁检测](#1-每种类型一个资源的死锁检测)
  - [2. 每种类型多个资源的死锁检测](#2-每种类型多个资源的死锁检测)
  - [3. 死锁恢复](#3-死锁恢复)
- [死锁预防](#死锁预防)
  - [1. 破坏互斥条件](#1-破坏互斥条件)
  - [2. 破坏占有和等待条件](#2-破坏占有和等待条件)
  - [3. 破坏不可抢占条件](#3-破坏不可抢占条件)
  - [4. 破坏环路等待](#4-破坏环路等待)
- [死锁避免](#死锁避免)
  - [1. 安全状态](#1-安全状态)
  - [2. 单个资源的银行家算法](#2-单个资源的银行家算法)
  - [3. 多个资源的银行家算法](#3-多个资源的银行家算法)
<!-- GFM-TOC -->

> [转载自](https://github.com/CyC2018/CS-Notes)

# 必要条件

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c037c901-7eae-4e31-a1e4-9d41329e5c3e.png"/> </div><br>

- 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。
- 占有和等待：已经得到了某个资源的进程可以再请求新的资源。
- 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
- 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

# 处理方法

主要有以下四种方法：

- 鸵鸟策略
- 死锁检测与死锁恢复
- 死锁预防
- 死锁避免

# 鸵鸟策略

把头埋在沙子里，假装根本没发生问题。

因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。

当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。

大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。

# 死锁检测与死锁恢复

不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。

## 1. 每种类型一个资源的死锁检测

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b1fa0453-a4b0-4eae-a352-48acca8fff74.png"/> </div><br>

上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。

图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。

每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。

## 2. 每种类型多个资源的死锁检测

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e1eda3d5-5ec8-4708-8e25-1a04c5e11f48.png"/> </div><br>

上图中，有三个进程四个资源，每个数据代表的含义如下：

- E 向量：资源总量
- A 向量：资源剩余量
- C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量
- R 矩阵：每个进程请求的资源数量

进程 P<sub>1</sub> 和 P<sub>2</sub> 所请求的资源都得不到满足，只有进程 P<sub>3</sub> 可以，让 P<sub>3</sub> 执行，之后释放 P<sub>3</sub> 拥有的资源，此时 A = (2 2 2 0)。P<sub>2</sub> 可以执行，执行后释放 P<sub>2</sub> 拥有的资源，A = (4 2 2 1) 。P<sub>1</sub> 也可以执行。所有进程都可以顺利执行，没有死锁。

算法总结如下：

每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。

1. 寻找一个没有标记的进程 P<sub>i</sub>，它所请求的资源小于等于 A。
2. 如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。
3. 如果没有这样一个进程，算法终止。

## 3. 死锁恢复

- 利用抢占恢复
- 利用回滚恢复
- 通过杀死进程恢复

# 死锁预防

在程序运行之前预防发生死锁。

## 1. 破坏互斥条件

例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。

## 2. 破坏占有和等待条件

一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。

## 3. 破坏不可抢占条件

## 4. 破坏环路等待

给资源统一编号，进程只能按编号顺序来请求资源。

# 死锁避免

在程序运行时避免发生死锁。

## 1. 安全状态

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ed523051-608f-4c3f-b343-383e2d194470.png"/> </div><br>

图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。

定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。

安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。

## 2. 单个资源的银行家算法

一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png"/> </div><br>

上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。

## 3. 多个资源的银行家算法

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/62e0dd4f-44c3-43ee-bb6e-fedb9e068519.png"/> </div><br>

上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。

检查一个状态是否安全的算法如下：

- 查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。
- 假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。
- 重复以上两步，直到所有进程都标记为终止，则状态时安全的。

如果一个状态不是安全的，需要拒绝进入这个状态。







