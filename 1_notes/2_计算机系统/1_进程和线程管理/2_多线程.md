## C++中的线程同步

### 1. 基本概念

- ***什么是线程同步？***

  ​	==同步就是协同步调，按预定的先后次序进行运行。==如：你说完，我再说。这里的同步千万不要理解成那个同时进行，应是指协同、协助、互相配合。线程同步是指多线程通过特定的设置（如互斥量，事件对象，临界区）来控制线程之间的执行顺序（即所谓的同步）也可以说是在线程之间通过同步建立起执行顺序的关系，如果没有同步，那线程之间是各自运行各自的！

  ​	线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步（下文统称为同步）。

- ***线程同步的四种方式***

  - 临界区
    - 临界区（Critical Section） 保证在某一时刻只有一个线程能访问数据的简便办法。在任意时刻只允许一个线程对共享资源进行访问。如果有多个线程试图同时访问临界区，那么在有一个线 程进入后其他所有试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开。临界区在被释放后，其他线程可以继续抢占，并以此达到用原子方式操 作共享资源的目的。
  - 互斥锁
    - 互斥对象和临界区很像，采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程同时访问。当前拥有互斥对象的线程处理完任务后必须将线程交出，以便其他线程访问该资源。
  - 信号量
    - 信号量用来干嘛的呢？搜寻答案的话，很多人都会告诉你主要用于线程同步的，意思就是线程通信的。简单来说，比如我运行了2个线程A和B，但是我希望B线程在A线程之前执行，那么我们就可以用信号量来处理。
    - 一般是将当前可用资源计数设置为最 大资源计数，每增加一个线程对共享资源的访问，当前可用资源计数就会减1 ，只要当前可用资源计数是大于0 的，就可以发出信号量信号。但是当前可用计数减小 到0 时则说明当前占用资源的线程数已经达到了所允许的最大数目，不能在允许其他线程的进入，此时的信号量信号将无法发出。
  - 事件
    - 通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作

### 2. 实践

​	c++的标准库中是没有实现临界区、信号量的。临界区相关概念，在windows下的c++开发有，而信号量则存在`POSIX`规范的实现。

#### 2.3 自旋锁

- ***什么是自旋锁***

  ​	自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。

#### 2.4 递归锁

- ***什么是递归锁***

  ​	std::recursive_mutex 与 std::mutex 一样，也是一种可以被上锁的对象，但是和 std::mutex 不同的是，std::recursive_mutex 允许同一个线程对互斥量多次上锁（即递归上锁），来获得对互斥量对象的多层所有权，std::recursive_mutex 释放互斥量时需要调用与该锁层次深度相同次数的 unlock()，可理解为 lock() 次数和 unlock() 次数相同，除此之外，std::recursive_mutex 的特性和 std::mutex 大致相同。

  ​	例如函数a需要获取锁mutex，函数b也需要获取锁mutex，同时函数a中还会调用函数b。如果使用std::mutex必然会造成死锁。但是使用std::recursive_mutex就可以解决这个问题。

#### 2.5 乐观和悲观锁

- ***悲观锁***

  ​	总是假设最坏的情况，每次拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想要拿到它的数据就会被一直阻塞直到它拿到锁，传统的关系型数据库里面就用到了很多这种锁机制，比如行锁、表锁、读锁、写锁等，都是在操作之前先上锁。

- ***乐观锁***

  ​	顾名思义，很乐观，每次拿数据的时候都认为别人不会修改，**所以不会上锁**，但是在更新的时候会去判断一下别人有没有修改这个数据，可以使用版本号等机制。cas就是乐观锁的一种经典实现方式。

  - **CAS**是乐观锁的一种实现，CAS全称是比较和替换，CAS的操作主要由以下几个步骤组成：
    1. 先查询原始值
    2. 操作时比较原始值是否修改
    3. 如果修改，则操作失败，禁止更新操作，如果没有发生修改，则更新为新值
  - CAS也是一种自旋锁，**当线程较少时，实现自旋效率最好，因为修改次数少，判断次数少，当线程竞争强烈（多）时，应该采用加锁的方法。**

#### 2.6 读写锁

- ***什么是读写锁？***

  ​	c++标准库并不支持读写锁，所以我们需要自己去实现。而读写锁则是，上读锁的时候可以读不给写，上写锁的时候不可以写也不可以读。

- ***c++读写锁的实现***

  ​	[参考链接](https://zhuanlan.zhihu.com/p/374042984)


#### 2.7 信号量

- ***信号量的实现***

  ​	[参考链接](https://segmentfault.com/a/1190000006818772)	
  

#### 2.8 临界区

- ***c++中的临界区***

  ​	c++的标准库是没有临界区概念的，而一些跨平台且涉及临界区的c++程序中，在windows则是用windows支持的Critical_Section，而linux则是通过pthread_mutex_t接口来模拟临界区。

- ***临界区的linux实现***

  ​	[参考链接](https://blog.csdn.net/lqy971966/article/details/104533687)



-----------------------------------------------------
<!-- GFM-TOC -->

- [必要条件](#必要条件)
- [处理方法](#处理方法)
<!-- GFM-TOC -->

> [转载自](https://github.com/CyC2018/CS-Notes)

# 必要条件

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c037c901-7eae-4e31-a1e4-9d41329e5c3e.png"/> </div><br>

- 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。
- 占有和等待：已经得到了某个资源的进程可以再请求新的资源。
- 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
- 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

# 处理方法

主要有以下四种方法：

- 鸵鸟策略
  把头埋在沙子里,假装根本没发生问题.
  因为解决死锁问题的代价很高,因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能.
  当发生死锁时不会对用户造成多大影响,或发生死锁的概率很低,可以采用鸵鸟策略.
  大多数操作系统,包括 Unix,Linux 和 Windows,处理死锁问题的办法仅仅是忽略它.

- 死锁检测与死锁恢复
  ???

- 死锁预防
  1. 破坏互斥条件
    例如假脱机打印机技术允许若干个进程同时输出,唯一真正请求物理打印机的进程是打印机守护进程.

  1. 破坏占有和等待条件
    一种实现方式是规定所有进程在开始执行前请求所需要的全部资源.

  3. 破坏不可抢占条件

  4. 破坏环路等待
    给资源统一编号,进程只能按编号顺序来请求资源.

- 死锁避免
  - 单个资源的银行家算法
  - 多个资源的银行家算法