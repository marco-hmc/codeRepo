#### (4) 进程之间的通信方法有哪几种 (重点)
进程之间的通信方式主要有六种,包括**管道,信号量,消息队列,信号,共享内存,套接字**.

* 管道:管道是半双工的,双方需要通信的时候,需要建立两个管道.管道的实质是一个内核缓冲区,进程以先进先出的方式从缓冲区存取数据:管道一端的进程顺序地将进程数据写入缓冲区,另一端的进程则顺序地读取数据,该缓冲区可以看做一个循环队列,读和写的位置都是自动增加的,一个数据只能被读一次,读出以后再缓冲区都不复存在了.当缓冲区读空或者写满时,有一定的规则控制相应的读进程或写进程是否进入等待队列,当空的缓冲区有新数据写入或慢的缓冲区有数据读出时,就唤醒等待队列中的进程继续读写.管道是最容易实现的
![fig/管道通信.png](fig/管道通信.png)

  匿名管道pipe和命名管道除了建立,打开,删除的方式不同外,其余都是一样的.匿名管道只允许有亲缘关系的进程之间通信,也就是父子进程之间的通信,命名管道允许具有非亲缘关系的进程间通信.

  管道的底层实现 https://segmentfault.com/a/1190000009528245

* 信号量:信号量是一个计数器,可以用来控制多个进程对共享资源的访问.信号量只有等待和发送两种操作.等待(P(sv))就是将其值减一或者挂起进程,发送(V(sv))就是将其值加一或者将进程恢复运行.

* 信号:信号是Linux系统中用于进程之间通信或操作的一种机制,信号可以在任何时候发送给某一进程,而无须知道该进程的状态.如果该进程并未处于执行状态,则该信号就由内核保存起来,知道该进程恢复执行并传递给他为止.如果一个信号被进程设置为阻塞,则该信号的传递被延迟,直到其阻塞被取消时才被传递给进程. 信号是开销最小的

* 共享内存:共享内存允许两个或多个进程共享一个给定的存储区,这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中,就像由malloc()分配的内存一样使用.一个进程写入共享内存的信息,可以被其他使用这个共享内存的进程,通过一个简单的内存读取读出,从而实现了进程间的通信.共享内存的效率最高,缺点是没有提供同步机制,需要使用锁等其他机制进行同步.

* 消息队列:消息队列就是一个消息的链表,是一系列保存在内核中消息的列表.用户进程可以向消息队列添加消息,也可以向消息队列读取消息.
消息队列与管道通信相比,其优势是对每个消息指定特定的消息类型,接收的时候不需要按照队列次序,而是可以根据自定义条件接收特定类型的消息.
可以把消息看做一个记录,具有特定的格式以及特定的优先级.对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息,对消息队列有读权限的进程可以从消息队列中读取消息.

* 套接字:套接口也是一种进程间通信机制,与其他通信机制不同的是,它可用于不同设备及其间的进程通信.


#### (5) 进程调度方法详细介绍
https://blog.csdn.net/u011080472/article/details/51217754

https://blog.csdn.net/leex_brave/article/details/51638300

* 先来先服务 (FCFS first come first serve):按照作业到达任务队列的顺序调度  FCFS是非抢占式的,易于实现,效率不高,性能不好,有利于长作业(CPU繁忙性)而不利于短作业(I/O繁忙性).
* 短作业优先 (SHF short job first):每次从队列里选择预计时间最短的作业运行.SJF是非抢占式的,优先照顾短作业,具有很好的性能,降低平均等待时间,提高吞吐量.但是不利于长作业,长作业可能一直处于等待状态,出现饥饿现象;完全未考虑作业的优先紧迫程度,不能用于实时系统.
* 最短剩余时间优先 该算法首先按照作业的服务时间挑选最短的作业运行,在该作业运行期间,一旦有新作业到达系统,并且该新作业的服务时间比当前运行作业的剩余服务时间短,则发生抢占;否则,当前作业继续运行.该算法确保一旦新的短作业或短进程进入系统,能够很快得到处理.
* 高响应比优先调度算法(Highest Reponse Ratio First, HRRF)是非抢占式的,主要用于作业调度.基本思想:每次进行作业调度时,先计算后备作业队列中每个作业的响应比,挑选最高的作业投入系统运行.响应比 = (等待时间 + 服务时间) / 服务时间 = 等待时间 / 服务时间 + 1.因为每次都需要计算响应比,所以比较耗费系统资源.
* 时间片轮转 用于分时系统的进程调度.基本思想:系统将CPU处理时间划分为若干个时间片(q),进程按照到达先后顺序排列.每次调度选择队首的进程,执行完1个时间片q后,计时器发出时钟中断请求,该进程移至队尾.以后每次调度都是如此.该算法能在给定的时间内响应所有用户的而请求,达到分时系统的目的.
* 多级反馈队列(Multilevel Feedback Queue) 


#### (6) 进程的执行过程是什么样的,执行一个进程需要做哪些工作?
进程的执行需要经过三大步骤:编译,链接和装入.
* 编译:将源代码编译成若干模块
* 链接:将编译后的模块和所需要的库函数进行链接.链接包括三种形式:静态链接,装入时动态链接(将编译后的模块在链接时一边链接一边装入),运行时动态链接(在执行时才把需要的模块进行链接)
* 装入:将模块装入内存运行

https://blog.csdn.net/qq_38623623/article/details/78306498

将进程装入内存时,通常使用分页技术,将内存分成固定大小的页,进程分为固定大小的块,加载时将进程的块装入页中,并使用页表记录.减少外部碎片.

通常操作系统还会使用虚拟内存的技术将磁盘作为内存的扩充.


#### (8) 死锁产生的必要条件(怎么检测死锁,解决死锁问题)
(1) 互斥:一个资源每次只能被一个进程使用.<br>
(2) 占有并请求:一个进程因请求资源而阻塞时,对已获得的资源保持不放.<br>
(3) 不可剥夺:进程已获得的资源,在末使用完之前,不能强行剥夺.<br>
(4) 循环等待:若干进程之间形成一种头尾相接的循环等待资源关系.<br>

产生死锁的原因主要是:<br>
(1) 因为系统资源不足.<br>
(2) 进程运行推进的顺序不合适.<br>
(3) 资源分配不当等.<br>
#### (8) 死锁的恢复
1. 重新启动:是最简单/最常用的死锁消除方法,但代价很大,因为在此之前所有进程已经完成的计算工作都将付之东流,不仅包括死锁的全部进程,也包括未参与死锁的全部进程.
2. 终止进程(process termination):终止参与死锁的进程并回收它们所占资源.
    (1) 一次性全部终止;(2) 逐步终止(优先级,代价函数)
3. 剥夺资源(resource preemption):剥夺死锁进程所占有的全部或者部分资源.
    (1) 逐步剥夺:一次剥夺死锁进程所占有的一个或一组资源,如果死锁尚未解除再继续剥夺,直至死锁解除为止.
    (2) 一次剥夺:一次性地剥夺死锁进程所占有的全部资源.
4. 进程回退(rollback):让参与死锁的进程回退到以前没有发生死锁的某个点处,并由此点开始继续执行,希望进程交叉执行时不再发生死锁.但是系统开销很大:
    (1) 要实现"回退",必须"记住"以前某一点处的现场,而现场随着进程推进而动态变化,需要花费大量时间和空间.
    (2) 一个回退的进程应当"挽回"它在回退点之间所造成的影响,如修改某一文件,给其它进程发送消息等,这些在实现时是难以做到的
    
#### (8)什么是饥饿
饥饿是由于资源分配策略不公引起的,当进程或线程无法访问它所需要的资源而不能继续执行时,就会发生饥饿现象.


#### (10)线程之间的通信方式有哪些? 进程之间的同步方式又哪些?
线程之间通信:
* 使用全局变量
* 使用信号机制
* 使用事件

进程之间同步:
https://www.cnblogs.com/sonic4x/archive/2011/07/05/2098036.html

* 信号量
* 管程

#### (13) 什么时候用多进程,什么时候用多线程
https://blog.csdn.net/yu876876/article/details/82810178

* 频繁修改:需要频繁创建和销毁的优先使用**多线程**
* 计算量:需要大量计算的优先使用**多线程**  因为需要消耗大量CPU资源且切换频繁,所以多线程好一点
* 相关性:任务间相关性比较强的用**多线程**,相关性比较弱的用多进程.因为线程之间的数据共享和同步比较简单.
* 多分布:可能要扩展到多机分布的用**多进程**,多核分布的用**多线程**.

#### (15) 孤儿进程和僵尸进程分别是什么,怎么形成的?
https://www.cnblogs.com/Anker/p/3271773.html

* 孤儿进程是父进程退出后它的子进程还在执行,这时候这些子进程就成为孤儿进程.孤儿进程会被init进程收养并完成状态收集.
* 僵尸进程是指子进程完成并退出后父进程没有使用wait()或者waitpid()对它们进行状态收集,这些子进程的进程描述符仍然会留在系统中.这些子进程就成为僵尸进程.
#### (16) 说一下PCB/说一下进程地址空间/
https://blog.csdn.net/qq_38499859/article/details/80057427

PCB就是进程控制块,是操作系统中的一种数据结构,用于表示进程状态,操作系统通过PCB对进程进行管理.

PCB中包含有:进程标识符,处理器状态,进程调度信息,进程控制信息

![](https://img-blog.csdn.net/20140904215636015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhbmd6aGVianV0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

进程地址空间内有:
* 代码段text:存放程序的二进制代码
* 初始化的数据Data:已经初始化的变量和数据
* 未初始化的数据BSS:还没有初始化的数据
* 栈
* 堆
* 
线程的栈空间是自己独有的


#### (18) 多线程是如何同步的(尤其是如果项目中用到了多线程,很大可能会结合讨论)
https://blog.csdn.net/s_lisheng/article/details/74278765

* 临界区
* 信号量
* 事件
* 互斥量
#### (19) 同一个进程内的线程会共享什么资源?
* 该进程的地址空间
* 全局变量
* 堆空间
* 
**多线程和多进程切换的损耗是什么?**

上下文切换(Context Switching):
* 多线程: 线程切换时,只需切换线程的上下文信息,包括寄存器/栈指针等.这个过程相对较轻量,因为线程共享同一进程的地址空间.
* 多进程: 进程切换时,需要切换整个进程的上下文,包括虚拟内存映射/文件描述符/寄存器等.这是一个相对重量级的操作.

内存切换(Memory Switching):
* 多线程: 线程在同一进程中共享内存空间,因此不涉及实际的内存切换.线程切换时,只需切换栈和寄存器等上下文信息.
* 多进程: 不同进程有独立的内存空间,进程切换时需要切换实际的内存映射,这可能涉及到页表的切换和TLB(Translation Lookaside Buffer)的重填.

性能损耗:
  * 多线程: 由于线程共享同一进程的地址空间,线程切换通常比进程切换更快速,因为上下文切换的开销较小.
  * 多进程: 进程切换的代价相对较高,因为需要切换独立的地址空间.
总体而言,多线程的上下文切换通常比多进程的上下文切换更为轻量级,因为线程之间共享进程的资源.在选择多线程还是多进程时,需要根据具体的应用场景/需求和性能考虑来做出决策.

#### (24)协程了解吗(高频)
协程和微线程是一个东西.

协程就是子程序在执行时中断并转去执行别的子程序,在适当的时候又返回来执行.
这种子程序间的跳转不是函数调用,也不是多线程执行,所以省去了线程切换的开销,效率很高,并且不需要多线程间的锁机制,不会发生变量写冲突.
#### (25)那协程的底层是怎么实现的,怎么使用协程?
协程进行中断跳转时将函数的上下文存放在其他位置中,而不是存放在函数堆栈里,当处理完其他事情跳转回来的时候,取回上下文继续执行原来的函数.
#### (23)进程的状态以及转换图
* 三态模型
  三态模型包括三种状态:
  1. 执行:进程分到CPU时间片,可以执行
  2. 就绪:进程已经就绪,只要分配到CPU时间片,随时可以执行
  3. 阻塞:有IO事件或者等待其他资源
  ![](fig/三态模型.png)
* 五态模型
  1. 新建态:进程刚刚创建.
  2. 就绪态:
  3. 运行态:
  4. 等待态:出现等待事件
  5. 终止态:进程结束
   ![](fig/五态模型.png)
  
* 七态模型
  1. 新建态
  2. 就绪挂起态
  3. 就绪态
  4. 运行态
  5. 等待态
  6. 挂起等待态
  7. 终止态
![](fig/七态模型.png)