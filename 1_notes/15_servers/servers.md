#### (1) Linux的I/O模型介绍以及同步异步阻塞非阻塞的区别(超级重要)
https://blog.csdn.net/sqsltr/article/details/92762279

https://www.cnblogs.com/euphie/p/6376508.html


(IO过程包括两个阶段:(1)内核从IO设备读写数据和(2)进程从内核复制数据)

* 阻塞:调用IO操作的时候,如果缓冲区空或者满了,调用的进程或者线程就会处于阻塞状态直到IO可用并完成数据拷贝.
* 非阻塞:调用IO操作的时候,内核会马上返回结果,如果IO不可用,会返回错误,这种方式下进程需要不断轮询直到IO可用为止,但是当进程从内核拷贝数据时是阻塞的.
* IO多路复用就是同时监听多个描述符,一旦某个描述符IO就绪(读就绪或者写就绪),就能够通知进程进行相应的IO操作,否则就将进程阻塞在select或者epoll语句上.


* 同步IO:同步IO模型包括阻塞IO,非阻塞IO和IO多路复用.特点就是当进程从内核复制数据的时候都是阻塞的.
* 异步IO:在检测IO是否可用和进程拷贝数据的两个阶段都是不阻塞的,进程可以做其他事情,当IO完成后内核会给进程发送一个信号.


#### (3) EPOLL的介绍和了解
https://zhuanlan.zhihu.com/p/56486633 

https://www.jianshu.com/p/397449cadc9a

https://blog.csdn.net/davidsguo008/article/details/73556811


Epoll是Linux进行IO多路复用的一种方式,用于在一个线程里监听多个IO源,在IO源可用的时候返回并进行操作.它的特点是基于事件驱动,性能很高.

epoll将文件描述符拷贝到内核空间后使用红黑树进行维护,同时向内核注册每个文件描述符的回调函数,当某个文件描述符可读可写的时候,将这个文件描述符加入到就绪链表里,并唤起进程,返回就绪链表到用户空间,由用户程序进行处理.

Epoll有三个系统调用:epoll_create(),epoll_ctl()和epoll_wait().

* eoll_create()函数在内核中初始化一个eventpoll对象,同时初始化红黑树和就绪链表.

* epoll_ctl()用来对监听的文件描述符进行管理.将文件描述符插入红黑树,或者从红黑树中删除,这个过程的时间复杂度是log(N).同时向内核注册文件描述符的回调函数.

* epoll_wait()会将进程放到eventpoll的等待队列中,将进程阻塞,当某个文件描述符IO可用时,内核通过回调函数将该文件描述符放到就绪链表里,epoll_wait()会将就绪链表里的文件描述符返回到用户空间.
#### (4) IO复用的三种方法(select,poll,epoll)深入理解,包括三者区别,内部原理实现?
(1)select的方法介绍:select把所有监听的文件描述符拷贝到内核中,挂起进程.当某个文件描述符可读或可写的时候,中断程序唤起进程,select将监听的文件描述符再次拷贝到用户空间,然select后遍历这些文件描述符找到IO可用的文件.下次监控的时候需要再次拷贝这些文件描述符到内核空间.select支持监听的描述符最大数量是1024.
![select](fig/select.png)
(2)poll使用链表保存文件描述符,其他的跟select没有什么不同.

(3)epoll将文件描述符拷贝到内核空间后使用红黑树进行维护,同时向内核注册每个文件描述符的回调函数,当某个文件描述符可读可写的时候,将这个文件描述符加入到就绪链表里,并唤起进程,返回就绪链表到用户空间.
![epoll](fig/epoll.png)
详见 https://www.cnblogs.com/Anker/p/3265058.html
#### (5) Epoll的ET模式和LT模式(ET的非阻塞)
* ET是边缘触发模式,在这种模式下,只有当描述符从未就绪变成就绪时,内核才会通过epoll进行通知.然后直到下一次变成就绪之前,不会再次重复通知.也就是说,如果一次就绪通知之后不对这个描述符进行IO操作导致它变成未就绪,内核也不会再次发送就绪通知.优点就是只通知一次,减少内核资源浪费,效率高.缺点就是不能保证数据的完整,有些数据来不及读可能就会无法取出.
* LT是水平触发模式,在这个模式下,如果文件描述符IO就绪,内核就会进行通知,如果不对它进行IO操作,只要还有未操作的数据,内核都会一直进行通知.优点就是可以确保数据可以完整输出.缺点就是由于内核会一直通知,会不停从内核空间切换到用户空间,资源浪费严重.
#### (6) 查询进程占用CPU的命令(注意要了解到used,buf,代表意义)
详见:https://blog.csdn.net/qq_36357820/article/details/76606113
1. top命令查看linux负载:
2. uptime查看linux负载
3. w查看linux负载:
4. vmstat查看linux负载


#### poll和epoll的区别
epoll是poll的升级版.其实poll和epoll都是用于同时监视多个文件描述符的.poll需要自己管理一组文件描述符的集合,而epoll就使得内核为我们管理这个结构体的数组,通过epoll_create.epoll不是一个函数,他是一组函数的实现.<br>
* poll布置完监视任务就需要取得监视的结果,而epoll就是用epoll_wait函数进行阻塞监视并返回监视结果.
epoll更成熟.<br>
* nginx和apache对比

* 同步/异步/阻塞/非阻塞的理解
* * 同步互斥
* 1/linux IO模型(5种) 记不太清,说了几种,应该没说完.(应该是:同步阻塞/同步非阻塞/多路复用/信号驱动/异步IO)应该还要说细节

* 什么是缓冲区溢出

23/epoll和select的区别?
答:select能支持的文件描述符数是有限的,最大1024个,并且每次调用前都需要将其监听的读集/写集/错误集从用户态向内核态拷贝,返回后又拷贝回去,而且,select返回的时候是将所有的文件描述符返回,也就意味着一旦有个事件触发,只能通过遍历的方式才能找到具体是哪一个事件,效率比较低/开销也比较大,但是也有好处,就是他的超时的单位是微秒级别;
epoll能支持的文件描述符数很大,可以上万,他的高效由3个部分组成:红黑树/双向链表/回调函数,每次将监听事件拷贝到内核后就存放在红黑树种,以EventPoll的结构体存在,如果有相应的事件发生,对应的回调函数就会触发,进而就会将该事件拷贝至双向链表中返回,而且,epoll每次返回的都是有事件发生的事件,不是所有时间,所以比较高效,总的来说epoll适用于连接数较多,活跃数较少的场景/而select适用于连接数不多,但大多都活跃的场景.

24/同一个IP同一个端口可以同时建立tcp和udp的连接吗
答可以,同一个端口虽然udp和tcp的端口数字是一样的,但实质他们是不同的端口,所以是没有影响的,从底层实质分析,对于每一个连接内核维护了一个五元组,包含了源ip,目的ip/源端口目的端口/以及传输协议,在这里尽管前4项都一样,但是传输协议是不一样的,所以内核会认为是2个不同的连接,在ip层就会进行开始分流,tcp的走tcp,udp走udp.
