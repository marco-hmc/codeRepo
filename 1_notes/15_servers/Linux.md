## 基础知识

#### 文件管理

* Linux目录结构

  <img src="imgs/os/dir.png" alt="dir" style="zoom:80%;" />

* 文件储存原理

  * 文件储存在硬盘上，硬盘的**最小存储单位叫做"扇区"**（Sector）。**每个扇区储存512字节**（相当于0.5KB）。
  * 操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个"块"（block）。这种由多个扇区组成的"块"，是**文件存取的最小单位**。**"块"的大小，最常见的是4KB**，即**连续八个 sector组成一个 block**。
  * 文件数据都储存在"块"中，那么很显然，我们还必须**找到一个地方储存文件的元信息**，比如**文件的创建者、文件的创建日期、文件的大小**等等。**这种储存文件元信息的区域就叫做inode，中文译名为"索引节点"**。

* inode概念

  * 每一个文件都有对应的inode，里面包含了与该文件有关的一些信息

* inode内容

  * 文件的字节数
  * 文件拥有者的User ID
  * 文件的Group ID
  * 文件的读、写、执行权限
  * 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间
  * 链接数，即有多少文件名指向这个inode
  * 文件数据block的位置

* 可以用`stat`命令，查看某个文件的inode信息：`stat filename`

* inode的大小

  * inode也会消耗硬盘空间，所以硬盘格式化的时候，**操作系统自动将硬盘分成两个区域**。一个是**数据区**，存放文件数据；另一个是**inode区**（inode table），存放**inode所包含的信息**
  * 每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是**每1KB或每2KB就设置一个inode**。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。
  * 查看每个硬盘分区的inode总数和已经使用的数量，可以使用`df`命令：`df -i`
  * 查看每个inode节点的大小，可以用：`sudo dumpe2fs -h /dev/hda | grep "Inode size"`
  * 由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件

* **inode号码**

  * 每个inode都有一个号码，操作系统用inode号码来识别不同的文件
  * 这里值得重复一遍，Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号
  * 表面上，用户通过文件名，打开文件。实际上，系统内部这个过程**分成三步**：首先，**系统找到这个文件名对应的inode号码**；其次，**通过inode号码，获取inode信息**；最后，**根据inode信息，找到文件数据所在的block，读出数据**
  * 查看文件名对应的inode号码：`ls -i filename`

* **目录文件**

  * Unix/Linux系统中，目录（directory）也是一种文件。**打开目录，实际上就是打开目录文件**
  * 目录文件的结构非常简单，就是一系列目录项（dirent）的列表。**每个目录项，由两部分组成：所包含文件的文件名，以及该文件名对应的inode号码**
  * 列出整个目录文件，即文件名和inode号码：`ls -i dir`
  * 要查看文件的详细信息，就必须根据inode号码，访问inode节点，读取信息。`ls -l`命令列出文件的详细信息
  * 目录权限
    * 理解了上面这些知识，就能理解目录的权限。目录文件的读权限（r）和写权限（w），都是针对目录文件本身，即**不同用户能以什么权限访问操作对该目录文件**。
    * 例如这里不同用户对tmp目录文件（d可以查出tmp是目录文件，d表示directory，即目录）分别为rwxr-xr-x，第一组的三个字符，即rwx，表示文件拥有者用户的对该文件的读写权限，第二组的三个字符，即r-x，表示文件拥有者用户所在的用户组里的其他用户对该文件的读写权限，第三组的三个字符，即r-x，表示文件拥有者用户所在的用户组以外的用户对该文件的读写权限。一个某个用户下运行的进程访问操作该目录文件只能以该用户所具有的对该目录文件的权限进行操作
    * 由于目录文件内**只有文件名和inode号码**，所以**如果只有读权限，只能获取文件名**，无法获取其他信息，因为其他信息都储存在inode节点中，而读取inode节点内的信息需要目录文件的执行权限（x）

* 硬链接

  * 一般情况下，文件名和inode号码是"一一对应"关系，每个inode号码对应一个文件名
  * **但是，Unix/Linux系统允许，多个文件名指向同一个inode号码。这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为"硬链接"（hard link）。**
  * ln命令可以创建硬链接：`ln sourcefile destfile`
  * 运行上面这条命令以后，源文件与目标文件的inode号码相同，都指向同一个inode。**inode信息中有一项叫做"链接数"，记录指向该inode的文件名总数，**这时就会增加1。
  * **反过来，删除一个文件名，就会使得inode节点中的"链接数"减1。当这个值减到0，表明没有文件名指向这个inode，系统就会回收这个inode号码，以及其所对应block区域。**
  * 这里顺便说一下目录文件的"链接数"。创建目录时，默认会生成两个目录项："."和".."。前者的inode号码就是当前目录的inode号码，等同于当前目录的"硬链接"；后者的inode号码就是当前目录的父目录的inode号码，等同于父目录的"硬链接"。所以，任何一个目录的"硬链接"总数，总是等于2（某一目录的目录名和该目录的当前目录名）

* 软连接

  * 除了硬链接以外，还有一种特殊情况
  * **文件A和文件B的inode号码虽然不一样**，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的"软链接"（soft link）或者"符号链接（symbolic link）
  * 这意味着，**文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错**："No such file or directory"。这是软链接与硬链接最大的不同：文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode"链接数"不会因此发生变化。
  * ln -s命令可以创建软链接：`ln -s sourcefile destfile`

* **inode的特殊作用**

  * 由于inode号码与文件名分离，这种机制导致了一些Unix/Linux系统特有的现象
    * 有时，**文件名包含特殊字符，无法正常删除**。这时，**直接删除inode节点，就能起到删除文件的作用**
    * **移动文件或重命名文件，只是改变文件名，不影响inode号码**
    * 打开一个文件以后，系统就以inode号码来识别这个文件，不再考虑文件名。因此，通常来说，系统无法从inode号码得知文件名
  * 第3点使得软件更新变得简单，可以在不关闭软件的情况下进行更新，不需要重启。因为系统通过inode号码，识别运行中的文件，不通过文件名。更新的时候，新版文件以同样的文件名，生成一个新的inode，不会影响到运行中的文件。等到下一次运行这个软件的时候，文件名就自动指向新版文件，旧版文件的inode则被回收


### [Linux的启动过程](https://www.runoob.com/linux/linux-system-boot.html)

* **内核引导**：当计算机打开电源后，首先是**BIOS开机自检**，按照BIOS中设置的启动设备（通常是硬盘）来启动。操作系统接管硬件以后，首先读入 /boot 目录下的内核文件

* **运行init**：init 进程是系统所有进程的起点，你可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动。init 程序首先是需要读取配置文件 /etc/inittab

  * 运行级别
    * 许多程序需要开机启动。它们在Windows叫做"服务"（service），在Linux就叫做"守护进程"（daemon）。init进程的一大任务，就是去运行这些开机启动的程序。但是，**不同的场合需要启动不同的程序**，比如用作服务器时，需要启动Apache，用作桌面就不需要
    * Linux允许为**不同的场合，分配不同的开机启动程序，这就叫做"运行级别"（runlevel）**。也就是说，启动时**根据"运行级别"，确定要运行哪些程序**
    * Linux系统有7个运行级别(runlevel)：
      - 运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动
      - 运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆
      - 运行级别2：多用户状态(没有NFS)
      - 运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式
      - 运行级别4：系统未使用，保留
      - 运行级别5：X11控制台，登陆后进入图形GUI模式
      - 运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动

* 系统初始化：在init的配置文件中有这么一行： si::sysinit:/etc/rc.d/rc.sysinit　它调用执行了/etc/rc.d/rc.sysinit，而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。它主要完成的工作有：**激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务**

* 建立终端：rc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。init接下来会打开6个终端，以便用户登录系统。在inittab中的以下6行就是定义了6个终端

  ```shell
  1:2345:respawn:/sbin/mingetty tty1
  2:2345:respawn:/sbin/mingetty tty2
  3:2345:respawn:/sbin/mingetty tty3
  4:2345:respawn:/sbin/mingetty tty4
  5:2345:respawn:/sbin/mingetty tty5
  6:2345:respawn:/sbin/mingetty tty6
  ```

  从上面可以看出在2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。同时它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份。

* 用户登录系统：一般来说，用户的登录方式有三种：

  - 命令行登录
  - ssh登录
  - 图形界面登录

* 对于运行级别为5的图形方式用户来说，他们的登录是通过一个图形化的登录界面。登录成功后可以直接进入 KDE、Gnome 等窗口管理器。而本文主要讲的还是文本方式登录的情况：当我们看到mingetty的登录界面时，我们就可以输入用户名和密码来登录系统了。Linux 的账号验证程序是 login，login 会接收 mingetty 传来的用户名作为用户名参数。然后 login 会对用户名进行分析：如果用户名不是 root，且存在 /etc/nologin 文件，login 将输出 nologin 文件的内容，然后退出。这通常用来系统维护时防止非root用户登录。**只有/etc/securetty中登记了的终端才允许 root 用户登录**，如果不存在这个文件，则 root 用户可以在任何终端上登录。/etc/usertty文件用于对用户作出附加访问限制，如果不存在这个文件，则没有其他限制

* 图形模式与文字模式的切换方式

  * Linux预设提供了**六个命令窗口终端机让我们来登录**
  * 默认我们登录的就是第一个窗口，也就是tty1，这个六个窗口分别为tty1,tty2 … tty6，你可以按下Ctrl + Alt + F1 ~ F6 来切换它们
  * 如果你安装了图形界面，默认情况下是进入图形界面的，此时你就可以按Ctrl + Alt + F1 ~ F6来进入其中一个命令窗口界面
  * 当你进入命令窗口界面后再返回图形界面只要按下Ctrl + Alt + F7 就回来了
  * 如果你用的vmware 虚拟机，命令窗口切换的快捷键为 Alt + Space + F1~F6. 如果你在图形界面下请按Alt + Shift + Ctrl + F1~F6 切换至命令窗口




#### 零拷贝技术

* 概念

  * **零拷贝（ zero-copy ）**技术可以有效地改善数据传输的性能，在内核驱动程序（比如网络堆栈或者磁盘存储驱动程序）处理 I/O 数据的时候，零拷贝技术可以在某种程度上减少甚至完全避免不必要 CPU 数据拷贝操作。
  * **零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术**。**针对操作系统中的设备驱动程序、文件系统以及网络协议堆栈而出现的各种零拷贝技术极大地提升了特定应用程序的性能，并且使得这些应用程序可以更加有效地利用系统资源**。这种性能的提升就是**通过在数据拷贝进行的同时，允许 CPU 执行其他的任务来实现的**
  * 概括如下
    * **避免数据拷贝**
      * **避免操作系统内核缓冲区之间进行数据拷贝操作**
      * **避免操作系统内核和用户应用程序地址空间这两者之间进行数据拷贝操作**
      * **用户应用程序可以避开操作系统直接访问硬件存储**
      * **数据传输尽量让 DMA 来做**
    * **综合目标**
      * **避免不必要的系统调用和上下文切换**
      * 需要拷贝的数据可以先被缓存起来
      * 对数据进行处理尽量让硬件来做

* 零拷贝使用场景

  * 在写一个服务端程序时（Web Server或者文件服务器），文件下载是一个基本功能。这时候服务端的任务是：将服务端主机磁盘中的文件不做修改地从已连接的socket发出去，我们通常用下面的代码完成：

    ```c++
    while((n = read(diskfd, buf, BUF_SIZE)) > 0)
       write(sockfd, buf , n);
    ```

  * 基本操作就是循环的从磁盘读入文件内容到缓冲区，再将缓冲区的内容发送到socket。但是由于Linux的I/O操作默认是缓冲I/O。这里面主要使用的也就是read和write两个系统调用，我们并不知道操作系统在其中做了什么。实际上在以上I/O操作中，发生了多次的数据拷贝。

  * 当应用程序访问某块数据时，操作系统首先会检查，是不是最近访问过此文件，文件内容是否缓存在内核缓冲区，如果是，操作系统则直接根据read系统调用提供的buf地址，将内核缓冲区的内容拷贝到buf所指定的用户空间缓冲区中去。如果不是，**操作系统则首先将磁盘上的数据拷贝的内核缓冲区，这一步目前主要依靠DMA来传输**，然后再把内核缓冲区上的内容拷贝到用户缓冲区中。接下来，write系统调用再把用户缓冲区的内容拷贝到网络堆栈相关的内核缓冲区中，最后socket再把内核缓冲区的内容发送到网卡上

    <img src="imgs/os/multi_copy.png" alt="multi_copy" style="zoom:80%;" />

  * 从上图中可以看出，共产生了**两次系统调用，四次数据拷贝**，即使使用了DMA来处理了与硬件的通讯，CPU仍然需要处理两次数据拷贝，与此同时，在用户态与内核态也发生了多次上下文切换，无疑也加重了CPU负担。在此过程中，我们没有对文件内容做任何修改，那么在内核空间和用户空间来回拷贝数据无疑就是一种浪费，而零拷贝主要就是为了解决这种低效性

  * 零拷贝主要的任务就是避免CPU将数据从一块存储拷贝到另外一块存储，主要就是利用各种零拷贝技术，避免让CPU做大量的数据拷贝任务，减少不必要的拷贝，或者让别的组件来做这一类简单的数据传输任务，让CPU解脱出来专注于别的任务。这样就可以让系统资源的利用更加有效

* 零拷贝技术使用

  * **使用mmap**

    * 减少拷贝次数的一种方法是调用mmap()来代替read调用：

      ```c++
      buf = mmap(diskfd, len);
      write(sockfd, buf, len);
      ```

    * 应用程序调用mmap()，**磁盘上的数据会通过DMA被拷贝的内核缓冲区**，**接着操作系统会把这段内核缓冲区与应用程序共享**，**这样就不需要把内核缓冲区的内容往用户空间拷贝**。应用程序**再调用write()**，**操作系统直接将内核缓冲区的内容拷贝到socket缓冲区中**，这一切都发生在内核态，最后，socket缓冲区再把数据发到网卡去

    <img src="imgs/os/mmap.png" alt="mmap" style="zoom:80%;" />

  * 使用mmap替代read很明显减少了一次拷贝，当拷贝数据量很大时，无疑提升了效率。**但是使用mmap是有代价的。当你使用mmap时，你可能会遇到一些隐藏的陷阱。例如，当你的程序map了一个文件，但是当这个文件被另一个进程截断(truncate)时, write系统调用会因为访问非法地址而被SIGBUS信号终止**。SIGBUS信号默认会杀死你的进程并产生一个coredump,如果你的服务器这样被中止了，那会产生一笔损失。通常可以使用以下解决方案避免这种问题：

    * **为SIGBUS信号建立信号处理程序**

      * 当遇到SIGBUS信号时，信号处理程序简单地返回，write系统调用在被中断之前会返回已经写入的字节数，并且errno会被设置成success，但是这是一种糟糕的处理办法，因为你并没有解决问题的实质核心

    * **使用文件租借锁**

      * 通常我们使用这种方法，在**文件描述符上使用租借锁**，我们为文件向内核申请一个租借锁，当其它进程想要截断这个文件时，内核会向我们发送一个实时的`RT_SIGNAL_LEASE`信号，告诉我们内核正在破坏你加持在文件上的读写锁。这样在程序访问非法内存并且被SIGBUS杀死之前，你的write系统调用会被中断。write会返回已经写入的字节数，并且置errno为success。我们应该在mmap文件之前加锁，并且在操作完文件后解锁：

        ```c++
        if(fcntl(diskfd, F_SETSIG, RT_SIGNAL_LEASE) == -1) {
            perror("kernel lease set signal");
            return -1;
        }
        /* l_type can be F_RDLCK F_WRLCK  加锁*/
        /* l_type can be  F_UNLCK 解锁*/
        if(fcntl(diskfd, F_SETLEASE, l_type)){
            perror("kernel lease set type");
            return -1;
        }
        ```

* 使用sendfile

  * sendfile原型

    ```c++
    #include<sys/sendfile.h>
    
    ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
    ```

  * 系统调用`sendfile()`在代表输入文件的描述符`in_fd`和代表输出文件的描述符`out_fd`之间传送文件内容（字节）。描述符`out_fd`**必须指向一个套接字**，而`in_fd`指向的文件必须是可以`mmap`的。这些局限限制了sendfile的使用，使**sendfile只能将数据从文件传递到套接字上**，反之则不行。使用sendfile不仅减少了数据拷贝的次数(1次)，还减少了上下文切换(一次调用，两次切换)，数据传送始终只发生在kernel space

    <img src="imgs/os/sendfile.png" alt="sendfile" style="zoom:80%;" />

  * 在调用sendfile时，如果有其它进程截断了文件会发生什么呢？假设我们没有设置任何信号处理程序，**sendfile调用仅仅返回它在被中断之前已经传输的字节数，errno会被置为success**。如果我们在调用sendfile之前给文件加了锁，sendfile的行为仍然和之前相同，我们还会收RT_SIGNAL_LEASE的信号

  * sendfile仍然存在一次拷贝，就是页缓存到socket缓存的拷贝。现在我们仅仅需要把**缓冲区描述符传到socket缓冲区，再把数据长度传过去，这样DMA控制器直接将页缓存中的数据打包发送到网络中就可以了**

    <img src="imgs/os/zero_sendfile.png" alt="zero_sendfile" style="zoom:80%;" />

    * sendfile系统调用利用DMA引擎将文件内容拷贝到内核缓冲区去，然后将带有文件位置和长度信息的缓冲区描述符添加socket缓冲区去，这一步不会将内核中的数据拷贝到socket缓冲区中，**DMA引擎会将内核缓冲区的数据拷贝到协议引擎中去，避免了最后一次拷贝**

    * 不过这一种收集拷贝功能是需要硬件以及驱动程序支持的。**需要网卡支持 SG-DMA**（*The Scatter-Gather Direct Memory Access*）技术（和普通的 DMA 有所不同）

    * 可以在 Linux 系统通过下面这个命令，查看网卡是否支持 scatter-gather 特性：

      ```shell
      $ ethtool -k eth0 | grep scatter-gather
      scatter-gather: on
      ```

* 使用splice

  * sendfile只适用于将数据**从文件拷贝到套接字**上，限定了它的使用范围。Linux在2.6.17版本引入splice系统调用，用于**在两个文件描述符中移动数据**

  * 原型

    ```c++
      #define _GNU_SOURCE         /* See feature_test_macros(7) */
      #include <fcntl.h>
      ssize_t splice(int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, size_t len, unsigned int flags);
    ```

      * splice调用在**两个文件描述符之间移动数据**，而**不需要数据在内核空间和用户空间来回拷贝**。他从`fd_in`拷贝`len`长度的数据到`fd_out`，**但是有一方必须是管道设备，这也是目前splice的一些局限性**。如果`fd_in`是一个管道文件描述符，那么off_in必须设为NULL；如果不是，那么表示从输入数据流的何处开始读取数据，此时若`fd_in`为NULL，则表示从输入数据流的当前偏移位置读入；不为NULL，则指出具体的偏移位置。``fd_out/off_out`同理使用与于输出流。flags参数有以下几种取值
      * SPLICE_F_MOVE ：尝试去移动数据而不是拷贝数据。这仅仅是对内核的一个小提示：**如果内核不能从pipe移动数据或者pipe的缓存不是一个整页面，仍然需要拷贝数据**。Linux最初的实现有些问题，**所以从2.6.21开始这个选项不起作用**，后面的Linux版本应该会实现
      * SPLICE_F_NONBLOCK ：splice 操作不会被阻塞。然而，如果文件描述符没有被设置为不可被阻塞方式的 I/O ，那么调用 splice 有可能仍然被阻塞
      * SPLICE_F_MORE： 后面的splice调用会有更多的数据。

  * splice调用利用了Linux提出的**管道缓冲区机制**， 所以**至少一个描述符要为管道**。以上几种零拷贝技术都是**减少数据在用户空间和内核空间拷贝技术实现的**，**但是有些时候，数据必须在用户空间和内核空间之间拷贝**。这时候，我们只能**针对数据在用户空间和内核空间拷贝的时机上下功夫了**。**Linux通常利用写时复制(copy on write)来减少系统开销，这个技术又时常称作COW**

* 使用tee

  * tee函数用于**两个管道之间复制数据**，也是零拷贝操作，它不消耗数据，源文件描述符上面的数据仍然可以用于后续读操作

  * 原型

    ```c++
    #include <fcntl.h>
    ssize_t tee(int fd_in, int fd_out, size_t len, unsigned int flags);
    ```

  * 上述参数与splice相同，但fd_in和fd_out都必须是管道文件描述符。成功返回两个文件描述符之间复制的数据，返回0表示没任何数据复制，失败返回-1并设置errno

