---
title: "4_RAFT协议"
layout: post
author: "Marco"
header-style: text
hidden: true
tags:
  - 分布式
---

## RAFT协议

### 1. 基本概念

- ***什么是分布式一致性算法？***

  ​	单机情况下，要保持并发数据的一致性，可以通过原子性操作以及锁、MVCC等方式实现一致性。可分布式是多机，单机的操作都不适用。而且分布式要更多考虑到网络故障、某个节点宕机等。
  
  ​	因此为了实现分布式一致性算法，最早是google提出了paxos，这是第一个被提出以及被证明的分布式一致性算法。但问题在于实践过程中，工程师很难按照协议完全做出一个raft的工程实现方案。大部分都是paxos的妥协方法。而raft就是paxos工程化的一个重要代表。
  
  ​	在进一步讨论什么是raft协议前，我们可以自己尝试设置一个分布式一致性协议，以便更好理解。
  
- ***发展演变***

  - 方案A

    - 实现：最朴素的的方法就是每次数据的CRUD都同时提交给所有节点，然后所有节点都修改。
    - 问题：因为网络阻塞，节点更新速度无法保证完全一致，比如说A节点收到甲账户+100，再-200操作，B节点可能收到的就是甲账户-200,在加100操作。两个操作因为异地，网络阻塞情况是有可能导致这种情况的。
    - 总结：这种其实就是完全没有考虑到节点的同步性了，也是最原始的。

  - 方案B

    - 实现：从所有节点选择一个主节点A，数据的CRUD请求提交到主节点A，然后主节点更新(add)请求，并向其余节点也发出更新(add)请求，其余节点收到后还会向A节点发出已更新(add already)请求，当A节点收到大多数add already请求后，就会发出提交请求(commit)。commit请求会提交所有add请求。
    - 问题：主节点如果宕机了，怎么办？如果某个节点宕机后，再重启，如何进行同步？
    - 总结：通过设定主节点，避免了不同节点更新速度差异的问题，速度由节点A管控；通过add、commit操作保证不同节点的更新问题。

  - 方案C

    - 实现：在方案B的基础上，动态选举主节点，为避免主节点宕机，主节点需要定时向其他节点发送心跳包数据，心跳包数据表明主节点还活着。如果其余节点没有收到心跳包数据，主节点有可能就是已经宕机了。这时候，其余节点随机一个等待时间，过了这个等待时间就会竞选主节点。之所以要随机一个等待时间，是为了其余节点同时竞选。

      其余节点需要与主节点同步所有add请求。

    - 总结：通过选举方式以及心跳机制，保证主节点存在，通过日志即add、commit操作保证数据的一致性。这个就已经和raft差不多了。

- ***完整的RAFT协议***

  > [视频链接](http://thesecretlivesofdata.com/raft/)

  ​	

### 2. 进阶概念