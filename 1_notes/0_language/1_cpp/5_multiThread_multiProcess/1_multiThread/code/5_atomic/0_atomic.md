## atomic

### 1. atomic的主要成员函数

#### 1.1 操作符
所有操作符都是线程安全的，对于原子变量而言，可以设定内存序进一步提升性能。
而操作符不能带参，自然而言就是默认最高等级的内存序。
相对应的`load()/store()/fetch_add()`其实都是和某个操作符对应的函数实现，就是方便设置内存序用的。

#### 1.2 is_lock_free()
is_lock_free() 方法用于检查原子操作是否是无锁的。无锁操作通常具有更高的性能，因为它们不需要使用互斥锁来同步访问。

不是所有原子类型都是可以无锁的，大部分自定义的原子类型都是有锁的。

#### 1.3 exchange
exchange 是 std::atomic 提供的一个成员函数，用于将原子对象的值设置为新值，并返回旧值。这个操作是原子的，保证了在多线程环境中操作的安全性。

#### 1.4 原子操作api
* store
* load
* fetch_add

#### 1.4 compare_exchange_weak/ compare_exchange_strong
暂时不需要掌握.

### 2. atomic_flag

#### 1. atomic_flag和atomic_bool有什么区别？
atomic_flag一定是无锁的。
atomic_bool是否无锁取决于架构。
一般而言，atomic_flag是用于实现自定义的atomic类型或者无锁编程的。
其他时候用atomic_bool就好了。

#### 2. test_and_set()/clear()怎么用？
test_and_set() 是 std::atomic_flag 和 std::atomic_bool 提供的一个成员函数，用于设置标志为 true，并返回之前的值。这个操作是原子的，通常用于实现简单的锁机制。

## 原子变量原理
原子变量（Atomic Variables）是指在多线程环境下，对其操作是原子性的，即不可分割的。这意味着当一个线程在修改原子变量时，其他线程不能同时进行修改，这样可以避免竞态条件和数据不一致的问题。原子变量的实现原理通常依赖于硬件支持的原子指令和编译器内存屏障（Memory Barrier）的合理使用。

以下是原子变量实现的一些关键点：

### 1. 硬件支持的原子指令

现代处理器提供了一些原子指令，这些指令可以保证某些操作的原子性。例如：

- **CMPXCHG**：比较并交换指令，用于实现原子的比较和设置操作。
- **XCHG**：交换指令，用于实现简单的原子交换操作。
- **LOCK**：一个前缀，用于在x86架构上确保紧随其后的指令是原子执行的。
- **Load-Acquire** 和 **Store-Release**：这些指令分别确保数据的加载和存储操作对其他处理器可见，它们是实现原子操作的一部分。

### 2. 内存屏障（Memory Barrier）

内存屏障（也称为内存栅栏）是一种CPU指令，它确保屏障之前的所有操作完成后才执行屏障之后的操作。内存屏障可以防止编译器和处理器对指令重排序。

- **Load Barrier**：加载屏障，确保所有在屏障前的读操作完成后，才执行屏障后的读操作。
- **Store Barrier**：存储屏障，确保所有在屏障前的写操作完成后，才执行屏障后的写操作。
- **Full Barrier**：全屏障，同时具有加载屏障和存储屏障的功能。

### 3. 原子操作的实现

原子操作通常通过组合上述硬件支持的原子指令和内存屏障来实现。以下是一些常见的原子操作及其实现原理：

- **原子读/写**：直接通过处理器的原子指令来保证读/写操作的原子性。
- **原子比较并设置（CAS）**：使用CMPXCHG指令实现，它允许只有一个线程能成功地将变量更新为新值，如果值匹配，则替换为新值，否则不做更改。
- **原子增加/减少**：可以通过XCHG指令或者ADD指令配合LOCK前缀来实现。
- **原子交换（Swap）**：通过XCHG指令实现，直接交换两个值。

### 4. 避免伪共享

在多核处理器系统中，多个核心可能共享同一缓存行。如果原子变量频繁地被不同的核心访问和修改，就可能发生伪共享（False Sharing），这会导致缓存一致性流量增加，降低性能。为了避免伪共享，可以在原子变量周围添加填充（Padding），使得每个核心访问的变量在不同的缓存行中。

### 5. 平台无关性

为了实现跨平台的原子操作，一些编程语言和库提供了平台无关的原子操作接口。例如，C++11标准库中的`std::atomic`，Java中的`java.util.concurrent.atomic`包，它们在底层会根据不同的平台和处理器架构选择合适的原子指令和内存屏障。

总结来说，原子变量的实现依赖于硬件提供的原子指令和内存屏障，通过这些机制来保证在多线程环境中的操作是安全的、不可分割的。
