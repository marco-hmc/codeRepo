## 路线图

前4章,介绍了标准库提供的各种库工具,展示了使用方法.

第5章,涵盖了底层内存模型和原子操作的实际情况,包括原子操作如何对执行顺序进行限制(这章标志着介绍部分的结束).

第6/7章,开始讨论高级主题,如何使用基本工具去构建复杂的数据结构__第6章是基于锁的数据结构,第7章是无锁数据结构.

第8章,对设计多线程代码给了一些指导意见,覆盖了性能问题和并行算法.

第9章,线程管理__线程池,工作队列和中断操作.

第10章,测试和调试__Bug类型,定位Bug的技巧,以及如何进行测试等等.

附录,包括新的语言特性的简要描述,主要是与多线程相关的特性,以及在第4章中提到的消息传递库的实现细节和C++11线程库的完整的参考.


# 2.5 标识线程

线程标识类型是`std::thread::id`，可以通过两种方式进行检索。

第一种，可以通过调用`std::thread`对象的成员函数`get_id()`来直接获取。如果`std::thread`对象没有与任何执行线程相关联，`get_id()`将返回`std::thread::type`默认构造值，这个值表示“无线程”。
第二种，当前线程中调用`std::this_thread::get_id()`(这个函数定义在`<thread>`头文件中)也可以获得线程标识。

# 3. data

## 不变量
*不变量*(invariants)的概念对程序员们编写的程序会有一定的帮助——对于特殊结构体的描述；比如，“变量包含列表中的项数”。
不变量通常会在一次更新中被破坏，特别是比较复杂的数据结构，或者一次更新就要改动很大的数据结构。

对于{1,2,3}的vector来说，如果我的不变量要求是向量大小不会减少，所以所有的线程如果不会减少其大小，那么就满足了不变量，对吗？

是的，你的理解是正确的。如果你的不变量是“向量的大小不会减少”，那么只要所有的线程都不会删除向量的元素（即只能添加元素），那么这个不变量就会被满足。

请注意，即使所有的线程都只添加元素，你仍然需要使用某种同步机制（如互斥量）来保护这个不变量。这是因为，即使单个的添加操作是安全的，多个添加操作可能仍然会导致数据竞争。例如，两个线程可能同时读取向量的大小，然后同时添加元素，这可能会导致一个元素被覆盖。

因此，你应该确保在任何时候只有一个线程可以修改向量。这可以通过`std::mutex`或其他同步机制来实现。
---

## 解决方式
1. 保持不变量
    1. 互斥量
    2. 无锁编程
2. 上transaction
是的，你的理解是正确的。数据竞争（Data Race）通常发生在两个或更多的线程并发访问同一内存位置，且至少有一个线程进行写操作，而其他线程可能进行读或写操作。

在你的例子中，如果线程B和线程C同时获取到了向量的大小，并且都试图在相同的位置添加元素，那么就会发生数据竞争。这是因为两个线程都试图修改同一内存位置，而且它们的操作没有被正确地同步。

这种情况可能会导致一些问题。例如，线程B可能会覆盖线程C添加的元素，或者反过来。或者，如果向量需要重新分配内存来容纳新元素，那么一个线程可能会看到一个无效的内存引用。

为了避免数据竞争，你需要使用某种同步机制（如互斥量）来确保在任何时候只有一个线程可以修改向量。这样，你就可以保证向量的大小和内容始终是一致的，不会被并发的修改操作破坏。

* 具有访问能力的指针或引用可以访问(并可能修改)被保护的数据，而不会被互斥锁限制。互斥量保护的数据需要对接口的设计相当谨慎，要确保互斥量能锁住任何对保护数据的访问，并且不留后门。
