## template

从用法来看，C++ 模板可以归类粗浅归为以下两种：
1. **泛型编程（Generic Programming）**：
   - **类型参数化**：模板允许编写与类型无关的代码，通过类型参数化实现代码复用。例如，`std::vector<T>` 可以存储任何类型的元素。
   - **函数模板**：函数模板允许编写与类型无关的函数，通过类型参数化实现函数的泛型。例如，`std::sort` 可以对任何类型的容器进行排序。
   - **类模板**：类模板允许编写与类型无关的类，通过类型参数化实现类的泛型。例如，`std::map<Key, Value>` 可以存储任何类型的键值对。
   - **模板特化**：模板特化允许为特定类型提供特殊的实现，从而优化特定类型的操作。例如，`std::hash` 可以为不同类型提供不同的哈希函数。

2. **模板元编程（Template Metaprogramming）**：
   - **编译期计算**：模板元编程允许在编译期进行计算和逻辑操作。这种能力使得程序可以在编译时生成代码，从而提高运行时性能。
   - **类型特征（Type Traits）**：通过模板元编程，可以实现类型特征，用于在编译期检查和操作类型。进一步地，可以认为是一种函数。其参数为类型或者字面量。例如，`std::is_integral` 可以用于检查一个类型是否是整型。
   - **递归模板**：模板元编程通常使用递归模板来实现复杂的编译期计算。例如，计算编译期常量、生成类型列表等。
   - **条件编译**：通过模板元编程，可以实现条件编译，根据不同的模板参数生成不同的代码。而SAFINAE是模板元编程，利用type traits实现条件编译的一种常见手段。

而进一步的，从本质角度出发，模板可以看成是操作类型。即在模板编程中，不管泛型编程号，还是模板元编程的各种操作，本质操作对象都是类型和常量。而类型是编译器去解析理解生成汇编代码的，然后基于此完善了一些相关语法（if判断则是通过模板匹配是否找到，循环是通过递归实现）
在实际开发中，模板似乎还是更多用于底层库的使用。模板编程基本的语法是依赖于模板匹配规则之类的。

* 泛型
   容器/ 封装（智能指针）/ 通用算法/ 设计模式的工厂类
* 元编程
   编译器计算，类型检查