模板元编程的时候要明白，c++编译器能处理的是类型, 常量。
为了扩展能力，这些概念在编译器下都需要进一步发展。

- 类型
  - 类 traits，类型能够特化和偏特化，
- 常量
  - 字面量/ 常量表达式/
    编译器没有变量的概念。


一门编程语言需要提供以下基本能力，以便开发者能够编写功能丰富、灵活且高效的程序：

1. 数据表示和操作
2. 条件判断能力（if）
3. 循环能力（loop）
4. 变量和常量
5. 函数和过程
6. 输入和输出
7. 错误处理
8. 模块化和命名空间
9. 面向对象编程（OOP）
10. 并发和并行


## template

模板囿于编译器技术限制，不得不带着缺陷诞生，语法晦涩，报错冗长，难以调试，应用层开发较少使用，相关技术书籍匮乏，因此掌握难度较大。
模板相关的经典技术书籍主要有三本，分别是 2001 年出版的 `Modern C++ Design`、2002 年出版的 `C++ Templates`、2004 年出版的 `C++ Template Metaprogramming`。但都不太适应modern c++的需要。特别是c++17出了很多新的简化模板使用的语法糖。
而介绍新的模板技术最好的书籍则为`C++ Templates 2ed`。
本文为`C++ Templates 2ed`的读后笔记。

而在此之前，结合我个人的理解，我认为 C++ 模板的主要能力可以归纳为以下两种：
1. **泛型编程（Generic Programming）**：
   - **类型参数化**：模板允许编写与类型无关的代码，通过类型参数化实现代码复用。例如，`std::vector<T>` 可以存储任何类型的元素。
   - **函数模板**：函数模板允许编写与类型无关的函数，通过类型参数化实现函数的泛型。例如，`std::sort` 可以对任何类型的容器进行排序。
   - **类模板**：类模板允许编写与类型无关的类，通过类型参数化实现类的泛型。例如，`std::map<Key, Value>` 可以存储任何类型的键值对。
   - **模板特化**：模板特化允许为特定类型提供特殊的实现，从而优化特定类型的操作。例如，`std::hash` 可以为不同类型提供不同的哈希函数。

2. **模板元编程（Template Metaprogramming）**：
   - **编译期计算**：模板元编程允许在编译期进行计算和逻辑操作。这种能力使得程序可以在编译时生成代码，从而提高运行时性能。
   - **类型特征（Type Traits）**：通过模板元编程，可以实现类型特征，用于在编译期检查和操作类型。例如，`std::is_integral` 可以用于检查一个类型是否是整型。
   - **递归模板**：模板元编程通常使用递归模板来实现复杂的编译期计算。例如，计算编译期常量、生成类型列表等。
   - **条件编译**：通过模板元编程，可以实现条件编译，根据不同的模板参数生成不同的代码。而SAFINAE是模板元编程，利用type traits实现条件编译的一种常见手段。

### 1. 泛型编程
略

### 2. 模板元编程

#### 2.1 concepts
* 模板元编程的好处？
* 有哪些地方建议使用模板元编程？或者说常见应用场景是什么？

#### 2.2 principles

#### 2.3 applications
##### 2.3.1 std提供的type traits技术
##### 2.3.2 常见的自定义实现的type traits技术
##### 2.3.3 递归模板技术
##### 2.3.4 条件编译（SFINAE）

- **SFINAE**：模板实例化过程中发生的类型不匹配或无法进行某种操作被视为替换失败，而不是编译错误。编译器会继续寻找其他可能的模板重载或特化来尝试匹配。
- **重载决议**：编译器在进行重载决议时，会根据实参和形参的匹配程度、函数声明的可见性、最佳匹配原则、模板特化和偏特化、参数类型退化、引用折叠和转发引用、`constexpr` 函数等因素来选择最佳匹配的函数。

###### 2.3.4.1 重载决议的关键点
1. **实参的推断要求一致**：
   - 在进行重载决议时，编译器会尝试匹配函数调用中实参的类型与各个重载函数形参的类型。虽然某些隐式类型转换是允许的（如从 `int` 到 `double`），但编译器不会进行过于复杂的转换尝试。实参类型需要与某个重载版本的形参类型足够“接近”，否则该重载版本不会被选中。
2. **函数声明的可见性**：
   - 只有在函数调用前声明的重载才会被匹配，即使后续有更优先的匹配，由于不可见也会被忽略。在 C++ 中，函数的可见性是基于声明的位置的。如果在调用一个重载函数时，编译器只能“看到”那些在调用点之前声明的重载版本。
3. **最佳匹配原则**：
   - 在所有可见的重载函数中，编译器会根据实参和形参的匹配程度来选择“最佳匹配”。这个选择过程考虑了参数的类型、数量、是否有默认参数等因素。如果有多个重载函数同样适合，但没有一个能被确定为最佳匹配，那么会导致编译错误，因为这种情况被认为是模糊的。
4. **模板特化和偏特化**：
   - 对于模板函数，重载决议还会考虑模板特化和偏特化。如果存在特化版本的模板函数，它们通常会被优先考虑，因为特化提供了更具体的实现。
5. **参数类型退化**：
   - 在函数模板重载决议中，参数类型可能会经历退化。例如，数组类型的参数会退化为指针，函数类型的参数会退化为函数指针。这种退化行为可能会影响哪个重载版本被选择。
6. **引用折叠和转发引用**：
   - C++11 引入了转发引用（Forwarding References）和引用折叠规则，这对于模板函数的重载决议尤其重要。转发引用允许函数模板完美地转发参数到另一个函数，而引用折叠规则决定了当模板参数被推导为引用时的行为。这些特性使得模板函数可以更灵活地处理不同的参数类型，包括左值和右值。
7. **constexpr 函数**：
   - 从 C++11 开始，`constexpr` 函数提供了在编译时进行计算的能力。在重载决议中，如果一个 `constexpr` 函数能够在编译时解析，它可能会被优先选择，这使得编译时优化和运行时性能得到提升。


##### 2.2.5 不定长参数

##### 2.2.6 concepts


### 99. quiz
#### 1. 怎么理解模板导致的代码膨胀？
不理解，似乎又说能保证odr(one-definition rule)
对于某一个普通函数，其代码文件只会存在于一个编译单元中；但如果使用了模板方法，则在不同的编译单元中，模板实例化的时候，都会有一个实例化代码。
使得增加了编译时间，和二进制文件的大小。




#### 2. 多个源文件中使用类模板
 在多个obj文件中可能产生多个重复的类模板对应的具体的实例化类，但链接的时候只会保留一个ATPL<int>类的实体，其余的会被忽略掉；
（3.1）虚函数的实例化
虚函数即使没有被调用，但也会被实例化出来，为什么？因为有虚函数，编译器就会产生虚函数表。虚函数表里是各个虚函数的地址，既然需要各个虚函数的地址，那么必须要实例化每个虚函数出来。
（3.2）显式实例化
显式实例化是指在代码中明确指定要实例化的模板参数，以确保模板类或函数在编译时生成特定类型的实例。这可以避免在多个源文件中重复实例化模板，并减少编译时间和二进制文件的大小。


#### 3. 类模板的实例化分析
如果程序代码中没有用到类模板ATPL，那么编译器对ATPL类模板视而不见，就好像从来没存在过一样；
（2.1）模板中的枚举类型，和类模板本身关系不大
（2.2）类模板中的静态成员变量
（2.3）类模板的实例化
1. 类模板指针不会实例化
2. 类模板引用会实例化
（2.4）成员函数的实例化
1. 实例化类模板，在不调用成员函数的情况下，不会实例化


### 99. quiz
#### 1. 注入类名
是说对类模板的作用域内，如果这个类型没有显式指定模板参数，默认都是用当前模板类型T的类型吗？

#### 2. 模板函数内联和不内联的区别是什么？

#### 3. 模板参数parameter和模板实参argument概念的区分


使用了 decltype(a)，各种莫名其妙报错，is_same_v 判断无效（因为 decltype(a) 会返回 A const & 而不是 A，用 std::decay_t<decltype(a)> 即可）

T::value_type 无法编译通过（由于缺乏 typename 前缀，用 typename T::value_type 即可）
