## template

笔者认为 C++ 模板的主要能力可以归纳为以下两种：
1. **泛型编程（Generic Programming）**：
   - **类型参数化**：模板允许编写与类型无关的代码，通过类型参数化实现代码复用。例如，`std::vector<T>` 可以存储任何类型的元素。
   - **函数模板**：函数模板允许编写与类型无关的函数，通过类型参数化实现函数的泛型。例如，`std::sort` 可以对任何类型的容器进行排序。
   - **类模板**：类模板允许编写与类型无关的类，通过类型参数化实现类的泛型。例如，`std::map<Key, Value>` 可以存储任何类型的键值对。
   - **模板特化**：模板特化允许为特定类型提供特殊的实现，从而优化特定类型的操作。例如，`std::hash` 可以为不同类型提供不同的哈希函数。

2. **模板元编程（Template Metaprogramming）**：
   - **编译期计算**：模板元编程允许在编译期进行计算和逻辑操作。这种能力使得程序可以在编译时生成代码，从而提高运行时性能。
   - **类型特征（Type Traits）**：通过模板元编程，可以实现类型特征，用于在编译期检查和操作类型。例如，`std::is_integral` 可以用于检查一个类型是否是整型。
   - **递归模板**：模板元编程通常使用递归模板来实现复杂的编译期计算。例如，计算编译期常量、生成类型列表等。
   - **条件编译**：通过模板元编程，可以实现条件编译，根据不同的模板参数生成不同的代码。而SAFINAE是模板元编程，利用type traits实现条件编译的一种常见手段。

### 1. 泛型编程
#### 1.1 特化和偏特化
#### 1.2 typename

### 2. 模板元编程

模板元编程（Template Metaprogramming, TMP）是一种通过模板技术在编译时进行计算的方式。模板元编程通过提前在编译阶段进行类型推导、计算和选择，能显著提升程序的运行时性能和灵活性。模板元编程在 C++ 中非常强大，能够处理各种类型推导、递归计算和条件编译等复杂任务。

C++的模板元编程在理论上是图灵完备的，即能完成任何可计算的任务，而一个图灵完备的计算系统具备以下几个关键特征：
   * **条件控制**：
      * 能够执行条件语句（如 if-else 或 switch-case）。
      * 模板元编程可通过std::enable_if或者sfinae实现
   * **循环或递归**：
      * 能够执行循环或递归操作（递归和循环在计算理论中是等价的，是可相互转换的）。
      * 模板元编程可通过递归模板类和结构体实现，而constexpr方法也是可以直接调用的。
   * **内存管理**：
      * 能够读取和修改变量的值（或进行类似的操作）。
      * 模板元编程中，值的概念对应的是类型和编译器常量，其中编译器常量就是里面可被赋值的。
总结，图灵完备的计算系统的特征其实模板元编程都符合。只是体现方式上不同，如条件控制（没有if，只有sfinae），如循环的体现（通过递归），如值的体现（没有变量，只有编译器常量和类型）。

#### 2.1 模板元编程的好处与应用场景

* **模板元编程的好处**：
   1. **编译期计算与性能优化**：
      - 通过模板元编程，许多计算可以在编译期完成，减少了运行时的计算负担。例如，使用递归模板计算常量值，避免在运行时重新计算。
      - 可以根据类型在编译时决定不同的实现，从而避免不必要的运行时分支和性能损耗。
   2. **类型安全**：
      - 模板元编程通过类型特征（type traits）和启用条件（如 `std::enable_if`）提供了类型安全检查。在编译时检查类型，减少了潜在的运行时错误。
      - 可以通过静态断言（`static_assert`）来确保类型或计算结果在编译时符合要求。
   3. **代码复用与抽象**：
      - 模板元编程为不同的类型提供统一的接口，减少代码冗余。例如，标准库中的容器和算法都利用模板技术，使得同一段代码能适应多种类型。
      - 通过模板元编程可以轻松地编写与类型无关的通用代码，增强代码的复用性和可扩展性。
   4. **条件编译与类型推导**：
      - 通过 SFINAE（Substitution Failure Is Not An Error）技术，模板元编程能够在不同的条件下选择合适的实现路径。可以根据不同的类型选择不同的算法，进行条件编译。

* **常见应用场景**：
   1. **类型计算与推导**：
      - 在编译期进行类型推导和计算，如计算类型大小、类型之间的转换、数组的维度和大小等。
      - 例如，可以通过模板推导判断一个类型是否是整数、浮点数或指针类型。
   2. **编译期常量与优化**：
      - 通过递归模板计算阶乘、斐波那契数列等常量，并在编译期直接得到结果，避免在运行时计算。
      - 可以根据编译期条件优化算法或数据结构选择，如选择适合的排序算法、内存管理方式等。
   3. **自定义类型特征与启用条件**：
      - 通过类型特征（`std::is_integral`）实现编译期类型检查。
      - 使用 SFINAE 技术和 `std::enable_if` 编写基于类型的函数重载。
   4. **简化接口与抽象**：
      - 通过模板特化和 SFINAE，实现更为灵活的接口和抽象。例如，根据类型的不同选择不同的处理方式，提高程序的扩展性。
   5. **提高编译时安全性**：
      - 通过 `static_assert` 或类型特征检查，增强程序的编译时安全性，减少类型错误。

#### 2.2 原则
模板元编程的原则主要围绕如何高效、可靠地在编译期完成复杂的计算和类型推导。以下是一些常见的原则：

   1. **递归是核心技术**：
      - 模板元编程往往依赖递归模板来完成编译期的计算任务，如递归展开类型序列、计算阶乘、斐波那契数列等。
   2. **终止条件的定义**：
      - 递归模板需要明确的终止条件，通常通过模板特化来实现终止。在递归过程中，必须确保最终能够到达终止条件，避免编译时死循环。
   3. **编译期常量**：
      - 利用 `constexpr` 和递归模板，能够在编译期计算常量，提高效率。
      - 这些常量可以是常规的数值，也可以是与类型相关的特征信息。
   4. **SFINAE与重载决议**：
      - 利用 SFINAE 技术，通过类型特征选择合适的重载函数或模板特化。重载决议过程中，编译器会尝试匹配最适合的模板，如果某个匹配失败，会继续尝试其他可行的模板，而不会报错。
   5. **类型特征与模板推导**：
      - 通过类型特征（如 `std::is_integral`, `std::is_pointer`）可以在编译时检查类型特性，从而决定模板实例化时的行为。

#### 2.3 应用

##### 2.3.1 `std` 提供的类型特征技术

C++标准库提供了丰富的类型特征工具（`type_traits`），这些工具允许在编译时检查和推导类型特性，使得模板编程更加高效和灵活。

常用的类型特征包括：

   - **`std::is_integral<T>`**：检查类型 `T` 是否为整数类型。
   - **`std::is_floating_point<T>`**：检查类型 `T` 是否为浮点类型。
   - **`std::is_pointer<T>`**：检查类型 `T` 是否为指针类型。
   - **`std::is_same<T, U>`**：检查类型 `T` 和 `U` 是否相同。
   - **`std::is_convertible<T, U>`**：检查类型 `T` 是否可以转换为 `U` 类型。
   - **`std::conditional<T, U, V>`**：根据条件 `T` 来选择 `U` 或 `V` 类型。
   - **`std::remove_reference<T>`**：移除类型 `T` 的引用部分。

通过这些类型特征，我们可以在模板中进行条件选择和优化，从而实现不同类型的定制化操作。

##### 2.3.2 常见的自定义实现的类型特征技术

除了标准库提供的类型特征，开发者还可以根据具体需求实现自定义类型特征。常见的自定义实现包括：

- **检查类型是否为容器类型**：我们可以通过模板特征检查一个类型是否是容器类型（如 `std::vector`, `std::list` 等），从而在不同容器类型上选择不同的操作。
  
  ```cpp
  template<typename T>
  struct is_container {
      template<typename U> static auto test(U*) -> decltype(std::declval<U>().begin(), std::declval<U>().end(), std::true_type());
      template<typename U> static std::false_type test(...);
      
      static constexpr bool value = std::is_same<decltype(test<T>(0)), std::true_type>::value;
  };
  ```

- **提取类型的首元素**：通过模板特化，提取容器类型的首元素类型。

##### 2.3.3 递归模板技术

递归模板是模板元编程中的一个重要技术，允许我们在编译期间进行复杂的计算和逻辑判断。递归模板通常用于实现编译期常量的计算和类型拆解。

常见应用场景：
- **计算编译期常量**：如阶乘、斐波那契数列等。
- **类型列表的递归处理**：对类型序列进行递归操作，如类型列表的生成和拆解。

示例：计算阶乘

```cpp
template<int N>
struct Factorial {
    static const int value = N * Factorial<N - 1>::value;
};

template<>
struct Factorial<0> {
    static const int value = 1;
};

int main() {
    int val = Factorial<5>::value;  // 120
}
```

##### 2.3.4 条件编译（SFINAE）

**SFINAE（Substitution Failure Is Not An Error）** 是模板元编程中的一项技术，它允许编译器在类型不匹配时继续尝试其他模板，而不是报错。这对于实现条件编译非常有用。

SFINAE 的主要用途：
- 根据类型的不同选择不同的模板函数或模板特化。
- 实现类型特定的行为，如根据类型判断是否支持某些操作（例如，是否支持加法、是否是容器类型等）。

示例：根据类型启用不同的函数重载

```cpp
template<typename T>
typename std::enable_if<std::is_integral<T>::value, void>::type print_type(T t) {
    std::cout << "Integral: " << t << std::endl;
}

template<typename T>
typename std::enable_if<std::is_floating_point<T>::value, void>::type print_type(T t) {
    std::cout << "Floating point: " << t << std::endl;
}

int main() {
    print_type(42);         // 输出 Integral: 42
    print_type(3.14);       // 输出 Floating point: 3.14
}
```

- **SFINAE**：模板实例化过程中发生的类型不匹配或无法进行某种操作被视为替换失败，而不是编译错误。编译器会继续寻找其他可能的模板重载或特化来尝试匹配。
- **重载决议**：编译器在进行重载决议时，会根据实参和形参的匹配程度、函数声明的可见性、最佳匹配原则、模板特化和偏特化、参数类型退化、引用折叠和转发引用、`constexpr` 函数等因素来选择最佳匹配的函数。

###### 2.3.4.1 重载决议的关键点
   1. **实参的推断要求一致**：
      - 在进行重载决议时，编译器会尝试匹配函数调用中实参的类型与各个重载函数形参的类型。虽然某些隐式类型转换是允许的（如从 `int` 到 `double`），但编译器不会进行过于复杂的转换尝试。实参类型需要与某个重载版本的形参类型足够“接近”，否则该重载版本不会被选中。
   2. **函数声明的可见性**：
      - 只有在函数调用前声明的重载才会被匹配，即使后续有更优先的匹配，由于不可见也会被忽略。在 C++ 中，函数的可见性是基于声明的位置的。如果在调用一个重载函数时，编译器只能“看到”那些在调用点之前声明的重载版本。
   3. **最佳匹配原则**：
      - 在所有可见的重载函数中，编译器会根据实参和形参的匹配程度来选择“最佳匹配”。这个选择过程考虑了参数的类型、数量、是否有默认参数等因素。如果有多个重载函数同样适合，但没有一个能被确定为最佳匹配，那么会导致编译错误，因为这种情况被认为是模糊的。
   4. **模板特化和偏特化**：
      - 对于模板函数，重载决议还会考虑模板特化和偏特化。如果存在特化版本的模板函数，它们通常会被优先考虑，因为特化提供了更具体的实现。
   5. **参数类型退化**：
      - 在函数模板重载决议中，参数类型可能会经历退化。例如，数组类型的参数会退化为指针，函数类型的参数会退化为函数指针。这种退化行为可能会影响哪个重载版本被选择。
   6. **引用折叠和转发引用**：
      - C++11 引入了转发引用（Forwarding References）和引用折叠规则，这对于模板函数的重载决议尤其重要。转发引用允许函数模板完美地转发参数到另一个函数，而引用折叠规则决定了当模板参数被推导为引用时的行为。这些特性使得模板函数可以更灵活地处理不同的参数类型，包括左值和右值。
   7. **constexpr 函数**：
      - 从 C++11 开始，`constexpr` 函数提供了在编译时进行计算的能力。在重载决议中，如果一个 `constexpr` 函数能够在编译时解析，它可能会被优先选择，这使得编译时优化和运行时性能得到提升。

##### 2.3.5 不定长参数

不定长参数模板（Variadic Templates）允许函数或类接受任意数量的模板参数。它使得模板能够处理任意数量的参数，从而增强了模板的灵活性。

常见应用：
- **参数包展开**：将不定数量的模板参数展开到函数调用中。
- **元组和类型列表**：通过不定长参数处理类型列表和元组等数据结构。

示例：计算参数包中所有整数之和：

```cpp
template<typename... Args>
int sum(Args... args) {
    return (args + ...);  // C++17 中的折叠表达式
}

int main() {
    int result = sum(1, 2, 3, 4);  // 输出 10
}
```

##### 2.3.6 Concepts（C++20）

C++20 引入了 Concepts，为模板提供了类型约束的机制。Concepts 允许我们在模板参数上直接指定要求的特性，从而简化模板编程，提升代码的可读性和可维护性。

示例：通过 Concepts 限制模板参数为整数类型：

```cpp
template<std::integral T>
T add(T a, T b) {
    return a + b;
}

int main() {
    int result = add(1, 2);   // 编译通过
    // double result2 = add(1.1, 2.2); // 编译错误，因为 double 不是整数类型
}
```

### 3. 
### 4. 总结

从数学的角度出发，可以将编程中函数理解为给定一个输入，返回一个输出的行为，输入一定，输出也不一定一定，因为这个函数可以有一些内部状态变量。但这个抽象是没问题的。
那么模板元编程的输入则是一个必须在编译器给定，也就是运行之前给定的一个输入。

那对于应用开发层面使用模板元编程实现一个复杂的计算来说，这个能力则太弱了。如果输入是固定的，我算一次，记住即可，连编译器计算都可以省略。因此模板元编程主要还是应用于库开发，因为我知道某一个数值需要被计算和使用，但我不知道他人将要怎么使用，因此模板元编程是有意义的。

除此之外，模板元编程的还有一大意义在于类型计算。出于极致的性能考虑，c++代码运行时不一定都是存在类型信息的，且这个类型信息能力很弱，无法提供一些是否为引用，指针，常量等信息数据。这些类型信息的获取都得通过模板的方式，因为类型在编译器是一直存在的。也就是不管类型检查，类型比较，类型计算都得使用模板去做比较好。比如说通过类型比较，实现设计模式中的策略模式去选择调用方法。


### 99. quiz
#### 1. 怎么理解模板导致的代码膨胀？
不理解，似乎又说能保证odr(one-definition rule)
对于某一个普通函数，其代码文件只会存在于一个编译单元中；但如果使用了模板方法，则在不同的编译单元中，模板实例化的时候，都会有一个实例化代码。
使得增加了编译时间，和二进制文件的大小。


#### 2. 多个源文件中使用类模板
 在多个obj文件中可能产生多个重复的类模板对应的具体的实例化类，但链接的时候只会保留一个ATPL<int>类的实体，其余的会被忽略掉；
（3.1）虚函数的实例化
虚函数即使没有被调用，但也会被实例化出来，为什么？因为有虚函数，编译器就会产生虚函数表。虚函数表里是各个虚函数的地址，既然需要各个虚函数的地址，那么必须要实例化每个虚函数出来。
（3.2）显式实例化
显式实例化是指在代码中明确指定要实例化的模板参数，以确保模板类或函数在编译时生成特定类型的实例。这可以避免在多个源文件中重复实例化模板，并减少编译时间和二进制文件的大小。


#### 3. 类模板的实例化分析
如果程序代码中没有用到类模板ATPL，那么编译器对ATPL类模板视而不见，就好像从来没存在过一样；
（2.1）模板中的枚举类型，和类模板本身关系不大
（2.2）类模板中的静态成员变量
（2.3）类模板的实例化
1. 类模板指针不会实例化
2. 类模板引用会实例化
（2.4）成员函数的实例化
1. 实例化类模板，在不调用成员函数的情况下，不会实例化


#### 4. 注入类名
是说对类模板的作用域内，如果这个类型没有显式指定模板参数，默认都是用当前模板类型T的类型吗？

#### 5. 模板函数内联和不内联的区别是什么？

#### 6. 模板参数parameter和模板实参argument概念的区分

使用了 decltype(a)，各种莫名其妙报错，is_same_v 判断无效（因为 decltype(a) 会返回 A const & 而不是 A，用 std::decay_t<decltype(a)> 即可）

T::value_type 无法编译通过（由于缺乏 typename 前缀，用 typename T::value_type 即可）


