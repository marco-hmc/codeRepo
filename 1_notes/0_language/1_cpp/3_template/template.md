* C++ [模板](https://en.cppreference.com/w/cpp/language/templates)技术是泛型编程的核心，但囿于编译器技术限制，不得不带着缺陷诞生，语法晦涩，报错冗长，难以调试，应用层开发较少使用，相关技术书籍匮乏，因此掌握难度较大。

* 模板相关的经典技术书籍主要有三本，分别是 2001 年出版的 [*Modern C++ Design*](https://book.douban.com/subject/1755195/)、2002 年出版的 [*C++ Templates*](https://book.douban.com/subject/1455780/)、2004 年出版的 [*C++ Template Metaprogramming*](https://book.douban.com/subject/1920800/)。

* 三者基于的 C++ 标准都是 C++98，*Modern C++ Design* 涉及 [Andrei Alexandrescu](https://en.wikipedia.org/wiki/Andrei_Alexandrescu) 写书时配套的 [Loki](http://loki-lib.sourceforge.net/)，*C++ Template Metaprogramming* 涉及 [Boost](https://www.boost.org/)，二者以介绍元编程（模板技术的一种应用）为主，只有 *C++ Templates* 主要介绍 C++98 标准的模板技术。时过境迁，C++ 标准的更新逐步修复了一些语法缺陷，减少了使用者的心智负担，并引入了语法糖和工具，让编写模板越来越简单。2017 年 9 月 25 日，基于 C++17 标准，[*C++ Templates 2ed*](https://book.douban.com/subject/11939436/) 出版，填补了十多年间模板技术进化时相关书籍的空白，堪称最全面的模板教程，也是对 C++11/14/17 特性介绍最为全面的书籍之一。


## template

模板在 C++ 中提供了强大的能力，主要可以归纳为以下两种：
1. **泛型编程（Generic Programming）**：
   - **类型参数化**：模板允许编写与类型无关的代码，通过类型参数化实现代码复用。例如，`std::vector<T>` 可以存储任何类型的元素。
   - **函数模板**：函数模板允许编写与类型无关的函数，通过类型参数化实现函数的泛型。例如，`std::sort` 可以对任何类型的容器进行排序。
   - **类模板**：类模板允许编写与类型无关的类，通过类型参数化实现类的泛型。例如，`std::map<Key, Value>` 可以存储任何类型的键值对。
   - **模板特化**：模板特化允许为特定类型提供特殊的实现，从而优化特定类型的操作。例如，`std::hash` 可以为不同类型提供不同的哈希函数。

2. **模板元编程（Template Metaprogramming）**：
   - **编译期计算**：模板元编程允许在编译期进行计算和逻辑操作。这种能力使得程序可以在编译时生成代码，从而提高运行时性能。
   - **类型特征（Type Traits）**：通过模板元编程，可以实现类型特征，用于在编译期检查和操作类型。例如，`std::is_integral` 可以用于检查一个类型是否是整型。
   - **递归模板**：模板元编程通常使用递归模板来实现复杂的编译期计算。例如，计算编译期常量、生成类型列表等。
   - **条件编译**：通过模板元编程，可以实现条件编译，根据不同的模板参数生成不同的代码。而SAFINAE是模板元编程，利用type traits实现条件编译的一种常见手段。

### 1. 泛型编程
略

### 2. 模板元编程

#### 2.1 concepts
* 模板元编程的好处？
* 有哪些地方建议使用模板元编程？或者说常见应用场景是什么？

#### 2.2 principles

#### 2.3 applications
##### 2.3.1 std提供的type traits技术
##### 2.3.2 常见的自定义实现的type traits技术
##### 2.3.3 递归模板技术
##### 2.3.4 条件编译（SFINAE）
模板参数推导和替换失败不是错误（SFINAE，Substitution Failure Is Not An Error）。
所以模板替换不是错误，是指模板实例化的时候如果和当前的模板函数匹配错误，不算失败，会继续尝试和其他模板匹配并完成实例化，但是如果没有任何一个模板函数能够完成模板实例化，还是会出现编译错误。
简单来说，当模板实例化过程中发生了类型不匹配或者无法进行某种操作时，这种情况被视为替换失败，而不是一个编译错误。编译器会忽略这个失败的实例化尝试，继续寻找其他可能的模板重载或特化来尝试匹配。如果最终没有任何模板能够匹配，那么编译器才会报错。这个机制允许模板库的设计者编写出更加灵活和通用的代码，通过重载和特化来处理不同的类型和操作。

而选择用哪一个完成模板实例化的能力，叫做重载决议。那重载决议有什么关键点呢？
* 实参的推断要求一致，其本身不会为了编译通过自动做类型转换 在进行重载决议时，编译器会尝试匹配函数调用中实参的类型与各个重载函数形参的类型。这个过程中，虽然某些隐式类型转换是允许的（如从int到double），但编译器不会进行过于复杂的转换尝试。实参类型需要与某个重载版本的形参类型足够“接近”，否则该重载版本不会被选中。这意味着，如果没有任何一个重载版本能够直接或通过简单的隐式转换与实参类型匹配，重载决议会失败。

* 只有在函数调用前声明的重载才会被匹配，即使后续有更优先的匹配，由于不可见也会被忽略。在C++中，函数的可见性是基于声明的位置的。如果在调用一个重载函数时，编译器只能“看到”那些在调用点之前声明的重载版本。即使在调用点之后有一个“更好”的重载版本，由于它在调用时不可见，编译器不会考虑它。这强调了声明顺序的重要性，以及在编写库或大型程序时组织代码的方式。

* 最佳匹配原则：在所有可见的重载函数中，编译器会根据实参和形参的匹配程度来选择“最佳匹配”。这个选择过程考虑了参数的类型、数量、是否有默认参数等因素。如果有多个重载函数同样适合，但没有一个能被确定为最佳匹配，那么会导致编译错误，因为这种情况被认为是模糊的。

* 模板特化和偏特化：对于模板函数，重载决议还会考虑模板特化和偏特化。如果存在特化版本的模板函数，它们通常会被优先考虑，因为特化提供了更具体的实现。

* 参数类型退化：在函数模板重载决议中，参数类型可能会经历退化。例如，数组类型的参数会退化为指针，函数类型的参数会退化为函数指针。这种退化行为可能会影响哪个重载版本被选择。

* 引用折叠和转发引用：C++11引入了转发引用（Forwarding References）和引用折叠规则，这对于模板函数的重载决议尤其重要。转发引用允许函数模板完美地转发参数到另一个函数，而引用折叠规则决定了当模板参数被推导为引用时的行为。这些特性使得模板函数可以更灵活地处理不同的参数类型，包括左值和右值。

* constexpr函数：从C++11开始，constexpr函数提供了在编译时进行计算的能力。在重载决议中，如果一个constexpr函数能够在编译时解析，它可能会被优先选择，这使得编译时优化和运行时性能得到提升。

##### 2.2.5 不定长参数

##### 2.2.6 concepts


### 99. quiz
#### 1. 怎么理解模板导致的代码膨胀？
对于某一个特定类型的函数实现，如果不是用模板的方法，则只会存在于一个编译单元中；但如果使用了模板方法，则在不同的编译单元中如果使用了这一个特定类型，都会有一个实例化代码。
使得增加了编译时间，和二进制文件的大小。

