## stl

### 1. concepts
* stl包含什么内容?
STL，全称Standard Template Library（标准模板库），是C++标准库的一部分。它包含了一系列的模板类和函数，主要用于数据处理和算法操作。STL的主要内容包括：

1. **容器（Containers）**：如vector、list、deque、set、map等，用于存储和操作数据。

2. **算法（Algorithms）**：如sort、find、copy、for_each等，提供了一系列对容器进行操作的通用算法。

3. **迭代器（Iterators）**：提供了一种方法，可以按照一定的顺序访问容器中的元素，而无需暴露容器的内部表示。

4. **函数对象（Functors）**：这是一种特殊的对象，可以像函数一样被调用。函数对象通常用于创建可定制的算法。

5. **适配器（Adapters）**：如stack、queue、priority_queue等，它们是在其他容器的基础上，提供了不同的接口。

6. **分配器（Allocators）**：用于控制STL容器的内存分配。

以上就是STL的主要内容。

### 2. 容器

#### 2.1 序列容器

1. **vector**
   * 数据结构：动态数组
   * 复杂度：插入、删除元素（尾部）O(1)，插入、删除元素（非尾部）O(n)，访问元素O(1)
   * 特点：支持快速随机访问，内存连续，尾部插入删除效率高，非尾部插入删除效率低

2. **deque**
   * 数据结构：双端队列
   * 复杂度：插入、删除元素（头尾）O(1)，插入、删除元素（非头尾）O(n)，访问元素O(1)
   * 特点：支持快速随机访问，头尾插入删除效率高，非头尾插入删除效率低

3. **list**
   * 数据结构：双向链表
   * 复杂度：插入、删除元素O(1)，访问元素O(n)
   * 特点：插入删除效率高，不支持随机访问，内存使用相对较高

4. **forward_list**
   * 数据结构：单向链表
   * 复杂度：插入、删除元素O(1)，访问元素O(n)
   * 特点：插入删除效率高，不支持随机访问，只能向前遍历

5. **array**
   * 数据结构：静态数组
   * 复杂度：插入、删除元素N/A（不支持插入删除操作），访问元素O(1)
   * 特点：支持快速随机访问，内存连续，大小固定，不支持插入删除操作

#### 2.2 有序关联容器

1. **set**
   * 数据结构：基于红黑树的集合
   * 复杂度：插入、删除、查找元素O(log n)
   * 特点：元素唯一，自动排序，查找效率高

2. **multiset**
   * 数据结构：基于红黑树的集合
   * 复杂度：插入、删除、查找元素O(log n)
   * 特点：元素可以重复，自动排序，查找效率高

3. **map**
   * 数据结构：基于红黑树的键值对集合
   * 复杂度：插入、删除、查找元素O(log n)
   * 特点：键值对，键唯一，自动排序，通过键快速查找值

4. **multimap**
   * 数据结构：基于红黑树的键值对集合
   * 复杂度：插入、删除、查找元素O(log n)
   * 特点：键值对，键可以重复，自动排序，通过键快速查找值

#### 2.3 无序关联容器

1. **unordered_set**
   * 数据结构：基于哈希表的集合
   * 复杂度：插入、删除、查找元素平均O(1)，最坏O(n)
   * 特点：元素唯一，不自动排序，查找效率高

2. **unordered_multiset**
   * 数据结构：基于哈希表的集合
   * 复杂度：插入、删除、查找元素平均O(1)，最坏O(n)
   * 特点：元素可以重复，不自动排序，查找效率高

3. **unordered_map**
   * 数据结构：基于哈希表的键值对集合
   * 复杂度：插入、删除、查找元素平均O(1)，最坏O(n)
   * 特点：键值对，键唯一，不自动排序，通过键快速查找值

4. **unordered_multimap**
   * 数据结构：基于哈希表的键值对集合
   * 复杂度：插入、删除、查找元素平均O(1)，最坏O(n)
   * 特点：键值对，键可以重复，不自动排序，通过键快速查找值

#### 2.4 容器适配器

1. **stack**
   * 数据结构：基于其他容器（如deque）实现的后进先出（LIFO）数据结构
   * 复杂度：插入、删除元素（顶部）O(1)，访问元素（顶部）O(1)
   * 特点：只能在顶部插入删除元素，后进先出（LIFO）

2. **queue**
   * 数据结构：基于其他容器（如deque）实现的先进先出（FIFO）数据结构
   * 复杂度：插入元素（尾部）O(1)，删除元素（头部）O(1)，访问元素（头部）O(1)
   * 特点：在尾部插入元素，在头部删除元素，先进先出（FIFO）

3. **priority_queue**
   * 数据结构：基于其他容器（如vector和make_heap）实现的优先队列
   * 复杂度：插入元素O(log n)，删除元素（顶部）O(log n)，访问元素（顶部）O(1)
   * 特点：元素按优先级排序，顶部元素优先级最高，只能访问顶部元素

### 3. 算法

* 为什么stl中的内存分配器要设计为一个模板参数而不是一个构造函数参数?
* 
* 请你回答一下STL里vector的resize和reserve的区别
  * resize()：改变当前容器内含有元素的数量size，eg: vector\<int\>v；v.resize(len)；v的size变为len，**如果原来v的size小于len，那么容器新增（len-size）个元素，元素的值为默认为0**。当v.push_back(3);之后，则是3是放在了v的末尾，即下标为len，此时容器是size为len+1；**如果原来v的size大于len，resize会移除那些超出len的元素同时销毁他们**
  * reserve()：改变当前容器的最大容量（capacity），**它不会生成元素**，只是确定这个容器允许放入多少对象，如果reserve(len)的len值大于当前的capacity，那么会重新分配一块能存len个对象的空间，然后把之前v.size()个对象通过copy construtor复制过来，销毁之前的内存。len值小于当前capacity，不做处理
  * **resize既分配了空间，也创建了对象，可以通过下标访问。resize既修改capacity大小，也修改size大小**
  * **reserve只修改capacity大小，不创建对象，push或insert时才创建，不修改size大小**
* 请你来说一下map和set有什么区别，分别又是怎么实现的？

  * map和set都是C++的关联容器，其底层实现都是红黑树（RB-Tree）。由于 map 和set所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 map 和set的操作行为，都只是转调 RB-tree 的操作行为。

  * map和set区别在于：

    * map中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。
    * **set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key**。其原因是因为map和set是**根据关键字排序来保证其有序性**的，**如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置**。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。

    * map支持下标操作，set不支持下标操作。如果find能解决需要，尽可能用find

* functional头文件支持的基于模板的比较函数对象
  * equal_to<Type>、not_equal_to<Type>、greater<Type>、greater_equal<Type>、less<Type>、less_equal<Type>
  * 常用的有greater <Type>()从大到小排序，less <Type>()从小到大排序

* ***vector问题***
    尽量不要在vector中存放bool类型,vector为了做优化,它的内部存放的其实不是bool.

* ***vector删除***
```c++
    std::vector<int> vec(1000000, 42);  // 创建一个包含1000000个元素的vector,并初始化为42
    vec.clear();  // 使用clear方法清空vector,但容量仍然是1000000
    // 在这之后,vec仍然占用着大量内存,即使已经没有实际的元素

    std::vector<int>().swap(vec);  // 使用swap方法将一个新的空vector与vec交换
```

#### (23)实现一个动态数组要怎么实现,说思路(腾讯teg一面)
模拟STL中vector的实现即可,去看一下vector的源码.

#### (6) 实现一个strcpy函数(或者memcpy),如果内存可能重叠呢

#### (48)string的底层实现
string继承自basic_string,其实是对char\*进行了封装,封装的string包含了char\*数组,容量,长度等等属性.

string可以进行动态扩展,在每次扩展的时候另外申请一块原空间大小两倍的空间(2^n),然后将原字符串拷贝过去,并加上新增的内容.


* 隔一个删除一个map中的元素(主要考察迭代器的失效问题)
* 
## stl的algorithm

### 1. tricks
#### 1. 使用`std::transform`
是的,使用`std::transform`时,你需要预先为输出范围分配足够的空间.这是因为`std::transform`不会自动为你的输出范围分配空间,它只是将转换后的元素写入到输出迭代器指向的位置.

例如,如果你正在处理一个`std::vector<int>`,并且你想要将其所有元素转换为其自身的平方,那么你需要先为输出范围分配足够的空间,如下所示:

```cpp
std::vector<int> input = {1, 2, 3, 4, 5};
std::vector<int> output(input.size());  // 预先分配足够的空间

std::transform(input.begin(), input.end(), output.begin(), [](int x) { return x * x; });
```

在这个例子中,`output`的大小在调用`std::transform`之前就已经被设置为与`input`相同.这样,`std::transform`就可以安全地将转换后的元素写入到`output`中.

#### STL库,vector的内存管理,deque的内存管理,list的排序
vector的内存管理原理是动态数组.当我们创建一个vector对象时,它会分配一块连续的内存来存储元素.当我们向vector中添加元素时,如果当前内存空间不足以容纳新的元素,vector会自动重新分配更大的内存块,并将原有的元素复制到新的内存块中.这个过程称为动态内存分配.当我们从vector中删除元素时,vector会释放不再使用的内存,以便节省内存空间.

deque的内存管理原理是双端队列.deque是由多个连续的内存块组成的,每个内存块都存储一定数量的元素.当我们向deque中添加或删除元素时,deque会根据需要在内存块的前端或后端进行插入或删除操作.这种设计使得deque在插入和删除元素时具有较好的性能,因为它不需要像vector那样重新分配内存和复制元素.

list的排序是通过链表的操作实现的.链表是由一系列节点组成的数据结构,每个节点都包含一个元素和指向下一个节点的指针.当我们对list进行排序时,list会使用一种称为"归并排序"的算法.归并排序将链表分割成较小的子链表,然后逐步合并这些子链表,直到得到一个有序的链表.归并排序的时间复杂度为O(nlogn),在大多数情况下比其他排序算法更高效.

* 容器的迭代器有哪些?
在C++标准库中,每种容器都有与之关联的迭代器.以下是一些常见的容器和它们的迭代器:

1. `std::vector`/`std::string`/`std::deque`:这些容器提供了随机访问迭代器,这意味着你可以在常数时间内前进或后退任意步数.你可以使用`+`/`-`操作符,也可以使用`<`/`>`等比较操作符.

2. `std::list`/`std::set`/`std::multiset`/`std::unordered_set`/`std::unordered_multiset`:这些容器提供了双向迭代器,这意味着你可以在常数时间内前进或后退一步.

3. `std::forward_list`:这个容器提供了前向迭代器,这意味着你只能在常数时间内前进一步.

4. `std::map`/`std::multimap`/`std::unordered_map`/`std::unordered_multimap`:这些容器也提供了双向迭代器.

5. `std::array`:这个容器提供了随机访问迭代器.

每种迭代器都提供了一组操作,包括解引用(`*`)/前进(`++`)和(对于双向和随机访问迭代器)后退(`--`).随机访问迭代器还提供了额外的操作,如跳过多个元素和比较两个迭代器的相对位置.

注意,不同类型的迭代器提供的功能是不同的,例如,你不能对一个只提供前向迭代器的容器使用`--`操作.



* 容器的线程安全是怎么保证的?如何判断一个容器是否是线程安全的?
容器的线程安全性是指在多线程环境中使用容器时,是否能够保证操作的原子性和正确性.不同的容器在多线程环境中有不同的线程安全性保障.

判断一个容器是否是线程安全的方式:

阅读文档: 查阅官方文档或标准,通常会明确容器的线程安全性.

查看实现: 不同的标准库实现可能对线程安全性有不同的实现.如果你知道你在使用哪个标准库的实现,可以查看该实现的文档或源代码.

使用锁: 如果容器并非线程安全的,你可以通过在操作容器时手动加锁来确保线程安全.但这样可能会影响性能,并且需要开发者对线程安全性有较深的了解.

第三方库: 有一些第三方库提供了线程安全的容器实现,这些库通常有更丰富的线程安全选项.

容器的线程安全性分类:

线程不安全容器: 大多数容器在多线程环境下不是线程安全的,例如 std::vector/std::deque/std::list.

部分线程安全容器: 有些容器提供了基本的线程安全保障,例如 std::queue 提供了一些原子操作,但在复杂操作时可能需要额外的手动同步.

全局线程安全容器: 有些容器是全局线程安全的,例如 std::shared_timed_mutex,但这种线程安全性可能会伴随一些性能开销.

并发容器: 一些库(如C++17中引入的)提供了专门的并发容器,例如 std::shared_mutex/std::shared_lock.

在使用容器时,了解容器的线程安全性是非常重要的,以确保在多线程环境下正确且高效地使用容器.