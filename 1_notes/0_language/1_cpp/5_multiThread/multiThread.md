## 多线程

### 1. 进程和线程的概念

#### 1.0 进程和线程的状态
在操作系统中，进程和线程的状态是一样的，通常有以下几种状态：

1. **新建（New）**：进程/线程正在被创建。
2. **就绪（Ready）**：进程/线程已经创建并等待被分配 CPU 时间片。
3. **运行（Running）**：进程/线程正在执行。
4. **等待（Waiting）或阻塞（Blocked）**：进程/线程正在等待某个事件（如 I/O 操作完成或资源可用）。
5. **终止（Terminated）或完成（Completed）**：进程/线程已经完成执行或被终止。

* **进程状态转换图**

以下是一个简单的进程状态转换图：

```
        +-------+       +-------+
        | New   |  ->   | Ready |
        +-------+       +-------+
                          ^  |
                          |  v
        +-----------------------+
        |       Running         |
        +-----------------------+
            |  ^             |
            v  |             v
        +-------+        +-------+
| waiting/Blocked|       | Terminated|
        +-------+        +-------+
```

#### 1.1 进程线程的调度
在 Linux 中，调度的基本单位是线程（也称为轻量级进程，LWP）。每个线程被视为一个独立的调度实体，操作系统的调度器会选择一个线程来运行。

* **调度方法**

Linux 使用完全公平调度器（CFS）作为默认的调度器。CFS 旨在提供公平的 CPU 时间分配，以下是一些常见的调度方法：

  1. **完全公平调度器（CFS）**：
    - CFS 是 Linux 的默认调度器，旨在提供公平的 CPU 时间分配。
    - CFS 使用红黑树数据结构来管理可运行的任务，并根据任务的虚拟运行时间进行调度。

  2. **实时调度器**：
    - Linux 还支持实时调度策略，包括 SCHED_FIFO 和 SCHED_RR。
    - SCHED_FIFO：先进先出调度策略，优先级高的任务先运行，直到任务主动放弃 CPU 或被更高优先级的任务抢占。
    - SCHED_RR：轮转调度策略，与 SCHED_FIFO 类似，但每个任务有一个固定的时间片，时间片用完后任务被放到队列末尾。

  3. **批处理调度器**：
    - SCHED_BATCH：适用于批处理任务，调度器会尽量减少这些任务对交互性任务的影响。

  4. **空闲调度器**：
    - SCHED_IDLE：适用于最低优先级的任务，只有在系统空闲时才会运行这些任务。
---

* **优先级设定**

Linux 中的调度优先级分为两类：实时优先级和普通优先级。

  1. **实时优先级**：
    - 实时优先级范围为 1 到 99，数值越大优先级越高。
    - 可以使用 `sched_setscheduler` 系统调用来设置实时优先级。

  2. **普通优先级**：
    - 普通优先级范围为 -20 到 19，数值越小优先级越高。
    - 可以使用 `nice` 和 `renice` 命令来调整普通优先级。


#### 1.2 进程和线程的区别
* **进程**

   1. **定义**：
      - 进程是操作系统中资源分配的基本单位。每个进程都有自己独立的地址空间、内存、文件描述符等资源。
   2. **资源**：
      - 进程拥有独立的资源，包括内存空间、文件描述符、全局变量等。
      - 进程之间的资源是相互隔离的，一个进程不能直接访问另一个进程的资源。
   3. **开销**：
      - 进程的创建和销毁开销较大，因为需要分配和回收大量的系统资源。
      - 进程之间的上下文切换开销也较大，因为需要保存和恢复独立的内存空间和资源。
   4. **通信**：
      - 进程之间的通信需要通过进程间通信（IPC）机制，如管道、消息队列、共享内存、信号等。
      - 进程间通信相对复杂，开销较大。

* **线程**

   1. **定义**：
      - 线程是操作系统中调度的基本单位。一个进程可以包含多个线程，线程共享进程的资源。
   2. **资源**：
      - 线程共享进程的资源，包括内存空间、文件描述符、全局变量等。
      - 线程之间可以直接访问共享的资源，通信和同步相对简单。
   3. **开销**：
      - 线程的创建和销毁开销较小，因为线程共享进程的资源。
      - 线程之间的上下文切换开销也较小，因为不需要切换独立的内存空间和资源。
   4. **通信**：
      - 线程之间的通信可以通过共享内存和同步机制（如互斥锁、条件变量等）实现。
      - 线程间通信相对简单，开销较小。


#### 1.3 线程之间私有和共享的资源有哪些?
线程之间的私有和共享资源主要包括以下几种：

**私有资源**：

1. **栈内存**：每个线程都有自己的栈内存，用于存储局部变量和函数调用的上下文信息。其他线程无法访问一个线程的栈内存。

2. **寄存器**：每个线程都有自己的寄存器集，包括程序计数器和其他寄存器。这些寄存器的值在线程切换时会被保存和恢复。

3. **线程局部存储（Thread Local Storage，TLS）**：这是一种特殊的机制，允许每个线程拥有自己的全局变量或静态变量的副本。

**共享资源**：

1. **堆内存**：所有线程共享同一块堆内存，线程可以创建对象并将其地址传递给其他线程。

2. **全局变量和静态变量**：全局变量和静态变量存储在所有线程共享的内存中，任何线程都可以访问它们。

3. **文件和网络资源**：如果一个程序打开了一个文件或网络连接，所有的线程都可以使用这些资源。

请注意，虽然线程可以共享许多资源，但在访问这些资源时需要小心，因为这可能会导致竞态条件和其他并发问题。为了避免这些问题，通常需要使用互斥锁、信号量等同步机制来保护共享资源。


### 2. 多进程的概念
* **进程的 ID**
  - **PID**：
    - 进程的唯一标识。对于多线程的进程而言，所有线程调用 `getpid` 函数会返回相同的值。
  - **PGID**：
    - 进程组 ID。每个进程都会有进程组 ID，表示该进程所属的进程组。默认情况下，新创建的进程会继承父进程的进程组 ID。
  - **SID**：
    - 会话 ID。每个进程也都有会话 ID。默认情况下，新创建的进程会继承父进程的会话 ID。

#### 2.1 守护进程概念

* **守护进程**
  - **定义**：
    - 守护进程是后台运行的、不与任何终端关联的进程，无法通过终端进行输入输出。它们通常用于周期性地执行某种任务或等待处理特定的事件。
  - **实现思路**：
    - 将普通进程改造为守护进程的过程。不同版本的 Unix 系统其实现机制不同，BSD 和 Linux 下的实现细节有所不同。

#### 2.2 后台进程概念

后台进程是指在终端中启动后，不会阻塞终端，可以在终端中继续执行其他命令的进程。后台进程通常通过在命令末尾加上 & 符号来启动。后台进程在执行时，用户可以继续在终端中输入其他命令，而不需要等待后台进程完成。
后台进程其实和守护进程是非常类似的，只是严格意义下，后台进程一般还是和终端程序挂钩，而守护进程是与终端进程挂钩的。

#### 2.3 孤儿进程和僵尸进程
在操作系统中，进程的管理和状态是非常重要的。以下是对孤儿进程和僵尸进程的详细解释及其处理方法。

* **孤儿进程**
  - **定义**：
    - 孤儿进程是指一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。
    - 孤儿进程将被 `init` 进程（进程号为 1）所收养，并由 `init` 进程对它们完成状态收集工作。
  - **特点**：
    - 孤儿进程不会对系统造成危害，因为 `init` 进程会负责它们的状态收集和资源释放。

* **僵尸进程**
  - **定义**：
    - 僵尸进程是指一个进程使用 `fork` 创建子进程，如果子进程退出，而父进程没有调用 `wait` 或 `waitpid` 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。
  - **特点**：
    - 任何一个子进程（`init` 除外）在 `exit()` 之后，并非马上就消失，而是留下一个称为僵尸进程（Zombie）的数据结构，等待父进程处理。
    - 僵尸进程的进程号会一直被占用，系统所能使用的进程号是有限的，如果大量产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。
  - **危害**：
    - 僵尸进程会占用系统的进程号资源，如果不及时处理，可能导致系统无法创建新的进程。
  - **解决办法**：
    - 子进程退出时向父进程发送 `SIGCHLD` 信号，父进程处理 `SIGCHLD` 信号，在处理函数中调用 `wait` 或 `waitpid`。

* **僵尸进程的危害场景**
  - **场景描述**：
    - 例如有个进程，它定期产生一个子进程，这个子进程需要做的事情很少，做完它该做的事情之后就退出了。因此这个子进程的生命周期很短。
    - 但是，父进程只管生成新的子进程，至于子进程退出之后的事情，则一概不闻不问。这样，系统运行一段时间之后，系统中就会存在很多的僵尸进程。如果用 `ps` 命令查看的话，就会看到很多状态为 `Z` 的进程。
  - **根本原因**：
    - 严格地来说，僵尸进程并不是问题的根源，罪魁祸首是产生出大量僵尸进程的那个父进程。因此，当我们寻求如何消灭系统中大量的僵尸进程时，答案就是把产生大量僵尸进程的那个元凶进程终止掉（通过 `kill` 发送 `SIGTERM` 或者 `SIGKILL` 信号）。
  - **处理方法**：
    - 终止元凶进程之后，它产生的僵尸进程就变成了孤儿进程，这些孤儿进程会被 `init` 进程接管，`init` 进程会 `wait()` 这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经僵死的孤儿进程就能被清理掉。

* **总结**
    简单来说孤儿进程是死了父进程，但是父进程还是会将孤儿进程委托给收养院。因此孤儿能健康长大；而僵尸进程则是被父进程遗弃了，父进程不处理子进程了。因此这个时候子进程就不能健康长大，就有危险了。
  

### 3. 多线程的概念

#### 3.1 C++多线程的主要关键字

c++关于多线程开发的关键字可以有以下分类：

- **创建和管理线程或异步任务:**
  * **1. `std::thread`**
    - **适用场景**：
      - **需要直接控制线程的生命周期**：当你需要精细控制线程的创建、启动、暂停、恢复和终止时，使用 `std::thread` 是合适的选择。
      - **需要共享资源的复杂同步**：当多个线程需要访问共享资源，并且需要复杂的同步机制（如互斥锁、条件变量）时，`std::thread` 提供了更大的灵活性。
      - **需要高性能**：在某些高性能计算场景中，直接使用 `std::thread` 可以避免一些抽象层带来的开销。

  * **2. `std::async`**
    - **适用场景**：
      - **简单的异步任务**：当你需要启动一个简单的异步任务，并且不需要显式管理线程时，使用 `std::async` 是最方便的选择。
      - **任务的启动策略**：当你希望任务可以根据需要立即执行或延迟执行时，`std::async` 提供了灵活的启动策略（如 `std::launch::async` 和 `std::launch::deferred`）。
      - **需要返回值的异步任务**：当你需要启动一个异步任务并获取其返回值时，`std::async` 会返回一个 `std::future` 对象，方便获取结果。

  * 3. `std::packaged_task`**
    - **适用场景**：
      - **需要更高的灵活性**：当你需要将任务与线程分离，并在不同的时间和上下文中启动任务时，使用 `std::packaged_task` 是合适的选择。
      - **复杂的任务管理**：当你需要显式管理任务的生命周期，并且可能需要将任务传递给其他线程或存储在容器中时，`std::packaged_task` 提供了更高的灵活性。
      - **需要返回值的任务**：与 `std::async` 类似，`std::packaged_task` 也会返回一个 `std::future` 对象，用于获取任务的结果。

- **用于线程间的同步和通信，确保线程安全:**
  * **1. `std::promise` 和 `std::future` / `std::shared_future`**
    - **适用场景**：
      - **线程之间的值传递**：当你需要在线程之间传递值时，使用 `std::promise` 和 `std::future` 是合适的选择。
    - **解释**：
      - `std::promise` 用于设置值，`std::future` 用于获取值。
      - 在一个线程中设置值，在另一个线程中获取值，实现线程间的值传递。

  * **2. `std::atomic`**
    - **适用场景**：
      - **原子操作**：当你需要进行原子操作以确保线程安全时，使用 `std::atomic` 是合适的选择。
    - **解释**：
      - `std::atomic` 提供了原子操作，确保多个线程对共享变量的操作是线程安全的。
      - 在多个线程中对 `std::atomic` 变量进行操作，避免数据竞争。

  * **3. `std::mutex`**
    - **适用场景**：
      - **互斥锁**：当你需要确保只有一个线程可以访问共享资源时，使用 `std::mutex` 是合适的选择。
    - **解释**：
      - `std::mutex` 提供了互斥锁，确保只有一个线程可以访问共享资源。
      - 使用 `std::lock_guard` 自动管理锁的生命周期，避免死锁。

  * **4. `std::condition_variable`**
    - **适用场景**：
      - **条件变量**：当你需要线程间的同步和通信时，使用 `std::condition_variable` 是合适的选择。
    - **解释**：
      - `std::condition_variable` 提供了条件变量，用于线程间的同步和通信。
      - 一个线程等待条件变量，另一个线程设置条件并通知等待的线程。


#### 3.2 线程安全

* **什么是线程安全？**
  简单来说就是，多线程一般是在同一个进程空间，共享内存空间。
  因此多线程同时对一个变量操作的时候，就会出现安全问题。
  - 简单理解，确保在多线程访问的时候，我们的程序还能按照我们预期的行为去执行，那么就是线程安全
  线程安全的定义可以总结为以下几点：

  1. **正确性**：在多线程环境下，多个线程同时访问同一个对象时，程序的行为和结果是正确的，不会出现数据不一致或程序崩溃的情况。
  2. **原子性**：操作是不可分割的，要么全部执行，要么全部不执行，不会被其他线程的操作中断。
  3. **可见性**：一个线程对共享变量的修改对其他线程是可见的。
  4. **有序性**：程序的执行顺序按照代码的先后顺序执行，不会因为指令重排序导致意外的行为。
---

* **怎么实现线程安全**
  1. **使用锁（Mutex）**：通过互斥锁（`std::mutex`）来保护共享数据，确保同一时间只有一个线程可以访问或修改数据。
  2. **使用原子操作（Atomic Operations）**：使用原子操作（`std::atomic`）来保证操作的原子性，不需要显式使用锁。
  3. **使用线程本地存储（Thread Local Storage）**：为每个线程分配独立的数据，避免多个线程访问同一个共享数据。
  4. **无锁数据结构（Lock-Free Data Structures）**：使用无锁数据结构，如无锁队列，避免使用锁来实现线程安全。

  * **线程安全具有传染性**
  线程安全具有传染性。如果一个函数 A 希望是线程安全的，那么在 A 函数调用 B 函数时，B 函数也应该是线程安全的。
---

#### 3.3 可重入函数

* **什么是可重入函数**
  可重入函数是指在任何时刻都可以安全地被中断，并且在中断后可以安全地重新进入执行的函数。具体来说，可重入函数具有以下特性：
  1. **可以被中断**：函数可以在执行过程中被中断，并且在中断后可以安全地重新进入执行。
  2. **不依赖外部环境**：函数除了使用自己栈上的变量外，不依赖于任何外部环境（包括静态变量和全局变量）。这样的函数被称为纯代码（pure code）可重入函数，可以允许多个副本同时运行，因为它们使用的是独立的栈，不会互相干扰。
  简单来说，可重入函数只使用自己栈上的数据，不使用静态变量、全局变量或类成员变量。如果调用的子函数也只使用自己栈上的数据，那么这个函数就是可重入的。
---

* **可重入函数的特点**
  1. 不在函数内部使用静态或全局数据。
  2. 不返回静态或全局数据，所有数据都由函数的调用者提供。
  3. 使用本地数据，或者通过制作全局数据的本地拷贝来保护全局数据。
  4. 不调用不可重入函数。
---

* **可重入函数的意义是什么？**
  1. **信号处理程序**：
    - 信号处理程序是处理异步信号的函数。当程序运行时，如果接收到某个信号（如 `SIGINT`、`SIGTERM` 等），操作系统会中断当前的执行流，转而执行信号处理程序。由于信号处理程序可以在任何时候被调用，因此它们必须是可重入的，以避免在中断时修改共享数据导致的数据不一致或程序崩溃。

  2. **中断处理程序**：
    - 在嵌入式系统或操作系统内核中，中断处理程序用于处理硬件中断。中断处理程序可以在任何时候被调用，因此它们也必须是可重入的，以确保在中断时不会破坏系统的稳定性。

  3. **多线程环境中的库函数**：
    - 在多线程环境中，高优先级的线程可能会抢占低优先级线程的执行。如果库函数是可重入的，那么即使在高优先级线程抢占时，也不会导致数据不一致或程序崩溃。
    - 在多线程环境中，多个线程可能会同时调用同一个库函数。如果这个库函数是可重入的，那么它可以安全地被多个线程同时调用，而不需要额外的同步机制。

  4. **实时系统**：
    - 在实时系统中，任务的执行时间和响应时间是非常关键的。可重入函数可以确保在任务被中断和重新调度时，系统的行为是可预测和稳定的。
---

* **可重入函数和线程安全的联系是什么**
  - **可重入函数**是线程安全函数的一个子集。可重入函数在任何时刻都可以安全地被中断，并且在中断后可以安全地重新进入。
  - **线程安全函数**可以通过使用锁来保护共享数据，但使用锁的函数在被中断后重新进入时可能会导致死锁或其他同步问题。
  - 线程安全函数可以使用静态或全局数据，只要这些数据受到适当的保护，但可重入函数不能使用静态或全局数据。
  - 线程安全函数可以调用其他线程安全但不可重入的函数，但可重入函数不能调用不可重入的函数。

* **为什么线程安全的不一定可重入？**
  线程安全的函数可以被打断。例如，当一个线程正在执行一个线程安全的函数时，可能会被操作系统的信号处理程序中断，或者被其他高优先级的线程抢占。
  1. **使用锁实现线程安全**：
    - 线程安全的函数可以通过使用锁（如 `std::mutex`）来保护共享数据，确保同一时间只有一个线程可以访问或修改数据。
    - 但是，使用锁的函数在被中断后重新进入时，可能会导致死锁或其他同步问题，因为锁的状态可能已经被改变。
  2. **使用静态或全局数据**：
    - 线程安全的函数可以使用静态或全局数据，只要这些数据受到适当的保护（如使用锁）。
    - 但是，可重入函数不能使用静态或全局数据，因为这些数据在函数被中断后重新进入时可能已经被修改。
  3. **调用不可重入的函数**：
    - 线程安全的函数可以调用其他线程安全但不可重入的函数，只要这些函数受到适当的保护。
    - 但是，可重入函数不能调用不可重入的函数，因为这些函数在被中断后重新进入时可能会导致数据不一致或程序崩溃。

* **不可重入的几种情况**：
  1. **使用静态数据结构**：例如 `getpwnam` 和 `getpwuid`。如果信号发生时正在执行 `getpwnam`，信号处理程序中执行 `getpwnam` 可能会覆盖原来 `getpwnam` 获取的旧值。
  2. **调用 `malloc` 或 `free`**：如果信号发生时正在执行 `malloc`（修改堆上存储空间的链接表），信号处理程序又调用 `malloc`，会破坏内核的数据结构。
  3. **使用标准 IO 函数**：许多标准 IO 的实现都使用全局数据结构，例如 `printf`（文件偏移是全局的）。
  4. **调用 `longjmp` 或 `siglongjmp`**：如果信号发生时程序正在修改一个数据结构，处理程序返回到另外一处，可能会导致数据被部分更新。

---

##### 3.3.1 异步信号安全(async-signal-safe)函数

- **异步信号安全的函数是指当从信号处理器函数调用时，可以保证其实现是安全的，如果某一函数是可重入的，或者信号处理器函数无法将其中断时，就称该函数是异步信号安全的**
- 但同时指出，仅当信号处理器函数中断了不安全函数的执行，且处理器函数自身也调用了这个不安全函数时，该函数才是不安全的
- 由于**可能会更新 errno，依然会导致信号处理器函数不可重入**，因为它们可能会覆盖之前由主程序调用函数时所设置的 errno 值。有一种变通方法，即当信号处理器函数使用了标准所列可重入函数时，可在其入口处保存 errno 值，并在其出口处恢复 errno 的旧有值

* 从多个线程访问时,其表现出正确的行为
* 无论操作系统如何调度这些线程,无论这些线程的执行顺序如何交织
* 调用端代码无需额外的同步或其他协调动作

​ 依据这个定义,C++ 标准库里的大多数类都不是线程安全的,无论 std::string 还是 std::vector 或 std::map,因为这些类通常需要在外部加锁.


### 98. Expanded content
#### 1. Futex 设计与实现

Futex（fast userspace mutex）是 Linux 的一个基础组件，可以用来构建各种更高级别的同步机制，比如锁或者信号量等。POSIX 信号量就是基于 futex 构建的。大多数时候，编写应用程序并不需要直接使用 futex，一般使用基于它所实现的系统库就足够了。

* **背景**

1. **传统的 System V IPC 机制**：
   - 传统的 System V IPC（进程间通信）同步机制都是通过内核对象来实现的。例如，使用信号量（semaphore）进行进程间同步时，必须通过系统调用 `semop(2)` 进入内核进行 PV 操作。
   - 系统调用的缺点是开销很大，需要从用户模式（user mode）切换到内核模式（kernel mode）、保存寄存器状态、从用户栈切换到内核栈等，通常要消耗上百条指令。

2. **避免不必要的系统调用**：
   - 事实上，有一部分系统调用是可以避免的，因为现实中很多同步操作进行时根本不存在竞争。即某个进程从持有信号量到释放信号量的这段时间内，常常没有其他进程对同一信号量有需求。
   - 在这种情况下，内核的参与本来是不必要的。然而在传统机制下，持有信号量必须先调用 `semop(2)` 进入内核查看是否有竞争，释放信号量也必须调用 `semop(2)` 进入内核查看是否有进程在等待同一信号量。这些不必要的系统调用造成了大量的性能损耗。

3. **用户态与内核态的同步机制**：
   - 在 futex 诞生之前，Linux 下的同步机制可以归为两类：用户态的同步机制和内核态的同步机制。
   - 用户态的同步机制基本上是利用原子指令实现的自旋锁（spinlock）。最简单的实现是使用一个整型数，0 表示未上锁，1 表示已上锁。`trylock` 操作利用原子指令尝试将 0 改为 1。

1. **Futex 的解决思路**：
   - Futex 的设计思想是：在无竞争的情况下操作完全在用户态进行，不需要系统调用，仅在发生竞争的时候进入内核去完成相应的处理（`wait` 或者 `wake up`）。
   - 所以说，Futex 是一种用户态和内核态混合的同步机制，需要两种模式合作才能完成。

2. **Futex 的实现**：
   - Futex 变量必须位于用户空间，而不是内核对象。
   - Futex 的代码分为用户态和内核态两部分，无竞争的情况下在用户态处理，发生竞争时通过 `sys_futex` 系统调用进入内核态处理。


### 99. quiz

#### 1. new 操作是如何保证线程安全的?
  内存管理器会使用一种称为锁的机制来保证在同一时刻只有一个线程可以分配或释放内存。
  当一个线程正在进行 `new` 操作时，其他试图进行 `new` 操作的线程将会被阻塞，直到第一个线程完成 `new` 操作。

#### 3. 原子操作实现原理
原子操作通过硬件支持的原子指令和缓存行锁机制，确保在多核 CPU 环境中，对共享数据的操作是原子的。通过在操作期间将缓存行标记为 locked，可以防止多个 CPU 核心同时修改同一份数据，从而实现原子操作。这种实现方式要求操作的变量位于一个缓存行中。

* **Cache Line Lock 的实现步骤**
    1. **CPU1 发出 "Read Invalidate" 消息**：
    - CPU1 发出 "Read Invalidate" 消息，通知其他 CPU 将原子变量所在的缓存无效，并从 Cache 返回数据。
    - CPU1 将 Cache Line 置为 Exclusive 状态，并将该 Cache Line 标记为 locked。

    2. **CPU1 读取和修改原子变量**：
    - CPU1 读取原子变量，进行修改，并将修改后的数据写入 Cache Line。

    3. **将 Cache Line 置为 unlocked**：
    - CPU1 完成操作后，将 Cache Line 置为 unlocked。

* **处理并发操作**
    在步骤 (1) 和 (3) 之间，如果其他 CPU（例如 CPU0）尝试执行一个原子递增操作，以下是处理流程：

    1. **CPU0 发送 "Read Invalidate" 消息**：
    - CPU0 发送 "Read Invalidate" 消息，通知 CPU1 将原子变量所在的缓存无效。

    2. **CPU1 检查 Cache Line 状态**：
    - CPU1 收到消息后，检查对应的 Cache Line 的状态是 locked，暂时不回复消息。
    - CPU0 会一直等待 CPU1 回复 Invalidate Acknowledge 消息。

    3. **等待 Cache Line 变为 unlocked**：
    - CPU0 等待 Cache Line 变为 unlocked。
    - 当 CPU1 将 Cache Line 置为 unlocked 后，CPU0 收到 Invalidate Acknowledge 消息，继续执行原子操作。

* **总结**
    这种方式称为锁 Cache Line，通过在操作期间将 Cache Line 标记为 locked，确保在操作期间其他 CPU 核心无法修改该数据，从而实现原子操作。这种实现方式要求操作的变量位于一个 Cache Line 中。


#### 4. 多核 cpu 的缓存以及如何保持缓存一致性
在多核 CPU 环境中，每个 CPU 核心都有自己的高速缓存（Cache），用于加速数据访问。然而，当多个 CPU 核心同时操作同一份数据时，可能会导致数据不一致的问题。为了确保数据的一致性，多核 CPU 使用了一些机制来保持缓存一致性。

* **缓存一致性问题**

1. **缓存一致性问题**：
   - 当多个 CPU 核心同时读取和写入同一内存地址时，可能会导致缓存中的数据不一致。
   - 例如，CPU 核心 A 和 CPU 核心 B 都有一个变量 `x` 的缓存副本。如果 CPU 核心 A 修改了 `x` 的值，而 CPU 核心 B 仍然使用旧的缓存值，就会导致数据不一致。

* **缓存一致性协议**

为了保持缓存一致性，多核 CPU 使用了缓存一致性协议。以下是一些常见的缓存一致性协议：

1. **MESI 协议**：
   - MESI 协议是最常见的缓存一致性协议之一。MESI 是四个状态的缩写：Modified（修改）、Exclusive（独占）、Shared（共享）和 Invalid（无效）。
   - 每个缓存行都有一个状态，表示该缓存行的当前状态。

2. **MESI 协议的工作原理**：
   - **Modified（修改）**：缓存行的数据已被修改，与主内存中的数据不一致。只有一个 CPU 核心可以持有该状态的缓存行。
   - **Exclusive（独占）**：缓存行的数据与主内存中的数据一致，且只有一个 CPU 核心持有该缓存行。
   - **Shared（共享）**：缓存行的数据与主内存中的数据一致，且多个 CPU 核心可以持有该缓存行。
   - **Invalid（无效）**：缓存行的数据无效，不能使用。

3. **缓存一致性操作**：
   - **读取操作**：当一个 CPU 核心读取一个缓存行时，如果该缓存行的状态是 Invalid，则需要从主内存或其他 CPU 核心的缓存中获取最新的数据。
   - **写入操作**：当一个 CPU 核心写入一个缓存行时，需要通知其他 CPU 核心将该缓存行的状态设置为 Invalid。

#### 5. 什么是虚假唤醒？为什么会有虚假唤醒？可以避免虚假唤醒吗？

```c++
std::mutex mtx;
std::condition_variable cond;
std::deque<int> queue;

int dequeue() {
    std::unique_lock<std::mutex> lock(mtx);
    cond.wait(lock, [] { return !queue.empty(); });  // 使用 lambda 表达式检查条件
    int top = queue.front();
    queue.pop_front();
    return top;
}

int dequeue2() {
    std::unique_lock<std::mutex> lock(mtx);
    while (queue.empty()) {  // 不能用 if，必须用 while，避免虚假唤醒
        cond.wait(lock);
    }
    int top = queue.front();
    queue.pop_front();
    return top;
}

int dequeue3() {
    std::unique_lock<std::mutex> lock(mtx);
    if (queue.empty()) {  // 使用 if 判断，可能会出现虚假唤醒
        cond.wait(lock);
    }
    int top = queue.front();
    queue.pop_front();
    return top;
}
```
在多线程编程中，使用条件变量（Condition Variable）进行线程同步时，可能会遇到虚假唤醒的问题。以下是对虚假唤醒及其处理方法的详细解释：

* **什么是虚假唤醒？**
  虚假唤醒（Spurious Wakeup）是指线程在等待条件变量时，即使没有任何线程调用 `notify_one` 或 `notify_all`，也会被唤醒的情况，即`wait`的时候被唤醒了。这种现象在某些操作系统和硬件平台上可能会发生。

* **为什么会有虚假唤醒？**
  虚假唤醒的原因可能包括：
  1. **操作系统的调度策略**：
    - 操作系统可能会出于各种原因唤醒等待的线程，例如资源重新分配或优先级调整。
  2. **硬件中断**：
    - 硬件中断可能会导致等待的线程被唤醒。
  3. **其他系统级别的事件**：
    - 系统级别的事件（如信号处理）也可能导致线程被唤醒。

* **如何处理虚假唤醒？**
  为了正确处理虚假唤醒，通常在一个 `while` 循环中调用 `.wait()` 方法，而不是使用 `if` 判断。这样可以多次检验条件，确保条件满足后才继续执行。

* **总结**
  - **虚假唤醒**：虚假唤醒是指线程在等待条件变量时，即使没有任何线程调用 `notify_one` 或 `notify_all`，也会被唤醒的情况。
  - **原因**：虚假唤醒可能由操作系统的调度策略、硬件中断或其他系统级别的事件引起。
  - **处理方法**：为了正确处理虚假唤醒，通常在一个 `while` 循环中调用 `.wait()` 方法，确保每次被唤醒时都重新检查条件是否满足。

#### 6. 如果函数返回一个 future,对这个 future 不调用 get(),会发生什么
* **1. `std::async` 的返回值**
  - **临时 `std::future` 对象**：
    - 如果你调用 `std::async` 但不将返回值存储在一个 `std::future` 对象中，一个临时的 `std::future` 对象会被创建。
    - 这个临时对象会在表达式结束时被销毁，销毁时会阻塞等待异步任务完成。
    - 因此，如果你不想阻塞当前线程，不能简单地忽略 `std::async` 的返回值。你需要将返回的 `std::future` 对象存储在某个地方，以便在适当的时候等待任务完成。

* **2. `std::future` 的析构行为**
  - **阻塞等待异步任务完成**：
    - 如果你创建了一个 `std::future` 对象，但没有调用 `get()` 方法，那么在 `std::future` 对象被销毁时，如果关联的异步操作（例如 `std::async`）还没有完成，程序会阻塞，直到异步操作完成。
    - 这是因为 `std::future` 的析构函数会检查关联的异步操作是否已经完成。如果没有完成，析构函数会阻塞，直到异步操作完成。这是为了确保异步操作能够安全地完成，而不会在还没有完成的情况下被强制停止。

* **3. 避免阻塞的方法**
  - **使用 `std::future::detach()`**：
    - 如果你不想在 `std::future` 对象被销毁时阻塞，可以调用 `std::future::detach()` 方法。这将使 `std::future` 对象与其关联的异步操作分离，这样，即使 `std::future` 对象被销毁，异步操作也会继续运行。
    - 需要注意的是，如果你没有调用 `get()` 方法，那么你将无法获取异步操作的结果。此外，`get()` 方法只能被调用一次，因为调用 `get()` 方法后，`std::future` 对象会变为无效状态。

* **4. 函数返回值的处理**
  - **函数返回值的析构**：
    - 函数的返回值即使没有用变量接收，实际上也是存在的，并且在外部函数结束时会被析构。
    - 而 `std::future` 的析构又要确保 `get()` 方法完成，所以如果不接收返回值，就会产生阻塞。

* **总结**
  在使用 `std::async` 和 `std::future` 时，需要注意以下几点：

  - 将 `std::async` 的返回值存储在 `std::future` 对象中，以避免临时对象销毁时阻塞当前线程。
  - 在 `std::future` 对象被销毁前，调用 `get()` 方法等待异步任务完成，或使用 `detach` 方法分离异步操作。
  - 理解 `std::future` 的析构行为，确保异步操作能够安全地完成。

#### 7. 对于单次事件通信使用atomic, mutex, promise的比较

这段文本讨论了在多线程编程中，如何有效地进行单次事件通信。具体来说，它比较了使用标志位、线程锁和`std::promise`三种不同的方法来实现线程间的同步和通信。

1. **使用标志位(flag)**:

   - 代码示例中没有直接展示，但提到了一种常见的做法，即在一个线程中使用`while(!flag){}`循环等待另一个线程改变`flag`的值。这种方法简单，但它会导致忙等待（busy-waiting），浪费 CPU 资源，因为等待的线程会持续检查`flag`而不做任何有用的工作。

2. **使用线程锁**:

   - 文本提到可以使用线程锁来代替标志位，以避免忙等待。示例代码中，`std::lock_guard<std::mutex>`用于自动管理互斥锁，但示例似乎有误，因为它没有展示如何正确使用互斥锁来等待某个条件。正确的做法通常涉及到`std::condition_variable`，它可以与互斥锁一起使用，让线程在条件不满足时休眠，直到条件被另一个线程改变并通知。

3. **使用`std::promise`**:
   - 最后，文本推荐使用`std::promise`来进行单次事件通信。`std::promise`是一种同步机制，可以在一个线程中存储一个值或异常，然后在另一个线程中通过与之对应的`std::future`对象来检索这个值或异常。示例中，`detect`函数创建了一个线程`t`，这个线程会等待`std::promise`对象`p`的状态被设置。当`detect`函数调用`p.set_value()`时，`p`的状态被设置，`t`中的等待操作完成，`react`函数随后被执行。这种方法避免了忙等待，且只适用于一次性通信，但需要注意的是，它可能涉及到堆内存的使用。

总的来说，这段文本强调了在设计多线程程序时，应该避免使用忙等待策略，而应该考虑使用更高级的同步机制，如`std::promise`，来高效地进行线程间的单次事件通信。

#### 8. 如何实现一个互斥锁？互斥锁的实现原理？如何使用信号量制作出一个互斥锁？

#### 9. 容器线程安全

#### 10. 有哪些同步手段

#### 11. 计数如何保证线程安全?

#### 12. CAS，非阻塞同步（乐观锁）
随着硬件指令集的发展，出现了基于冲突检测的乐观并发策略。通俗地说，**乐观锁**的思想是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采用其他的补偿措施（最常见的补偿措施是不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为**非阻塞同步**。

* **CAS 指令**
  - **定义**：
    - CAS 指令需要有 3 个操作数，分别是内存地址（在 Java 中理解为变量的内存地址，用 V 表示）、旧的预期值（用 A 表示）和新值（用 B 表示）。
    - CAS 指令执行时，当且仅当 V 处的值符合旧预期值 A 时，处理器用 B 更新 V 处的值，否则它就不执行更新。
    - 无论是否更新了 V 处的值，都会返回 V 的旧值。上述的 CAS 指令是一个原子操作。

* **CAS 的 ABA 问题**
  - **定义**：
    - 因为 CAS 需要在操作值的时候检查值有没有发生变化，如果没有发生变化则更新。但是一个值原来是 A，变成了 B，又变成了 A，那么使用 CAS 进行检查时会发现它的值没有发生变化，但实际上却变化了。
    - CAS 只关注了比较前后的值是否改变，而无法清楚在此过程中变量的变更明细，这就是所谓的 ABA 问题。

  - **解决思路**：
    - 使用版本号（如 MySQL 的 MVCC）。在变量前面追加版本号，每次变量更新的时候把版本号加一，那么 A-B-A 就变成了 1A-2B-3A，从而解决 ABA 问题。

#### 13. 什么是析构竞态？
* **可能出现的竞态条件**
  1. **对象即将析构时**：
    - 如何确定是否有其他线程正在执行该对象的成员函数？
    - 如果在析构对象时，另一个线程正在调用该对象的成员函数，可能会导致未定义行为。
  2. **执行成员函数期间**：
    - 如何保证在执行成员函数期间，对象不会在另一个线程被析构？
    - 如果对象在执行成员函数期间被析构，可能会导致程序崩溃或数据损坏。
  3. **调用成员函数之前**：
    - 如何得知对象在调用成员函数之前还活着？
    - 如果对象的析构函数正在执行，调用成员函数可能会导致未定义行为。

* **解决方法**
为了避免析构竞态，可以使用以下方法：
  1. **智能指针**：
    - 使用 `std::shared_ptr` 和 `std::weak_ptr` 来管理对象的生命周期。
    - `std::shared_ptr` 会自动管理对象的引用计数，当引用计数为零时，自动销毁对象。
    - `std::weak_ptr` 可以安全地访问 `std::shared_ptr` 管理的对象，而不会影响对象的生命周期。
  2. **互斥锁**：
    - 使用互斥锁（如 `std::mutex`）来保护对象的访问和析构操作。
    - 在访问对象的成员函数时，先获取锁，确保对象在访问期间不会被析构。


#### 14. 如何从构造函数，实现线程安全？
要确保对象构造期间的线程安全，关键在于避免在构造函数中泄露 `this` 指针。具体来说：
  1. **不要在构造函数中注册任何回调**：
    - 在构造函数中注册回调可能会导致 `this` 指针泄露，从而使得其他线程在对象尚未完全构造完成时访问它。
  2. **不要在构造函数中把 `this` 传给跨线程的对象**：
    - 在构造函数中将 `this` 传递给其他线程的对象可能会导致这些线程在对象尚未完全构造完成时访问它。
  3. **即便在构造函数的最后一行也不行**：
    - 即使在构造函数的最后一行将 `this` 传递给其他线程的对象也可能导致竞态条件，因为对象的构造尚未完全完成。

#### 15. 为什么线程安全的，析构函数这么麻烦？
线程安全的析构函数复杂的原因主要在于析构过程中需要销毁互斥锁，同时确保没有其他线程在使用该对象。具体来说：
  1. **确保所有线程都已经停止使用对象**：
    - 在销毁对象之前，必须确保没有任何线程还在使用或可能会使用该对象。这通常需要使用同步机制（如条件变量或 `std::future`）来等待所有线程完成。
  2. **使用智能指针管理资源**：
    - 在 C++ 中，可以使用智能指针（如 `std::unique_ptr` 或 `std::shared_ptr`）来管理对象。当没有任何指针指向对象时，对象会被自动销毁。这可以避免手动管理内存和资源的复杂性。

  你将从本书中获得从进程与线程的关系，再到常用的线程同步原语的区别与使用场景，再到线程池以及基于生产者消费者模型的消息队
列，以及对协程思想介绍的相关知识。

掌握了常见的多线程同步原语之后，接下来可以找一些带多线程的项目去学习一下，不管是否带 UI的都行。
我推荐的一种方式是，使用 gdb 或者 Visual Studio 调试器将你需要学习的多线程程序中断下来，在多线程面板，看看这个进程一共有多少个正在运行的线程，分析每个线程的作用，然后研究下这些线程在何时何地创建的，为什么需要创建新的线程。
