## 数据语义

### 2. 程序的内存布局
1. 代码段（Text Segment/Code Segment）:
   存放程序的机器代码，即编译后的可执行指令。这部分内存是只读的，以防止程序在运行时修改自己的代码。
   1. 常量存储区：常量数据（如字符串字面量、编译时常量表达式的结果）被存储在代码段中，这部分内存是只读的，用于存放程序执行过程中不会改变的数据。因此，当我们讨论常量存储区时，它实质上指的是存放程序中固定不变数据的区域，这部分内容在程序加载到内存时被放置在代码段里，与程序的机器代码存放在一起。

2. 数据段（Data Segment）:
   分为初始化数据段和未初始化数据段（BSS段）。
   1. 初始化数据段：存储程序中已初始化的全局变量和静态变量的值。
   2. BSS段（Block Started by Symbol）：存储未初始化的全局变量和静态变量，通常会被自动初始化为0或空指针。
   3. 全局区/静态区:
   这个术语有时与数据段的概念混用，但主要是强调存储全局变量和静态变量的地方。

3. 堆区（Heap）:
   动态内存分配区域，程序在运行时通过如malloc、calloc、new等函数申请的空间就位于此处。程序员需要手动管理这块区域的内存分配和释放，否则可能导致内存泄漏。

4. 栈区（Stack）:
   用于存储函数调用时的局部变量、函数参数、返回地址等。每当函数调用发生时，一个新的栈帧会被压入栈中，函数返回时相应的栈帧会被弹出。栈的分配和释放由编译器自动管理。

5. 动态库加载区域:
   如果程序使用动态链接库（DLL或.so文件），这些库的代码和数据会被加载到此区域。操作系统负责管理这些共享库的加载和卸载。

6. 程序计数器（PC Register）:
   不是内存区域，但与程序执行密切相关，用于存储下一条待执行指令的地址。

7. 寄存器:
   CPU内部的高速存储单元，用于快速存储和访问数据。编译器会尽可能利用寄存器来提高程序性能。

8. 内存映射区域:
   包括文件映射、共享内存等，操作系统可以将磁盘上的文件或其他资源映射到内存中，使得程序可以直接访问这些资源如同访问内存一样。

9. 栈顶指针（Stack Pointer, SP）和基指针（Base Pointer, BP/EBP）:
   这些不是内存区域，但对理解栈的工作原理很重要。SP指向栈顶，BP通常指向当前函数的栈帧底部，用于维护函数调用栈的结构。

### 3. 数据成员布局
C++中的数据成员布局决定了类实例在内存中的存储方式，涉及到数据成员的排列顺序、对齐、以及如何与其他类特性（如虚函数表）集成。
1. 声明顺序与排列：非静态数据成员在对象中的排列顺序与其在类定义中声明的顺序一致。这意味着编译器会按照声明的顺序来分配内存。在同一个访问控制段（如private、protected、public）中，较晚声明的数据成员会分配在较高的内存地址上。
   1. 比较晚出现的成员变量在内存中有更高的地址；
      1. 从低地址向高地址分配/存储
      2. 大端存储和小端存储
         1. 大端：数据的低位保存在内存中的高地址中，数据的高位保存在内存中的低地址中；
         2. 小端：数据的低位保存在内存中的低地址中，数据的高位保存在内存中的高地址中；

2. 内存对齐：为了优化访问速度，数据成员会被对齐到它们自然对齐边界上。例如，一个四字节的整型通常会被对齐到四字节边界。这种对齐可能会导致额外的填充字节插入到数据成员之间，以满足对齐要求。
```cpp
#pragma pack(1) //对齐方式设置为1字节对齐（不对齐）

#pragma pack() //取消指定对齐，恢复缺省对齐；
```

3. 静态数据成员：静态数据成员不在对象实例中存储，而是在程序的全局数据区域或静态区分配。这意味着所有类实例共享相同的静态数据成员实例。

4. 虚函数表：如果类中包含虚函数，编译器会为该类生成一个虚函数表（vtable），它是一个函数指针数组，存储了类中所有虚函数的地址。每个含有虚函数的类实例会包含一个指向这个vtable的指针（称为vptr），通常位于对象的开始位置，但这也依赖于编译器实现。

5. 多重继承：在多重继承的情况下，派生类可能有多个虚函数表指针，分别指向其基类的虚函数表，以支持正确的动态调度。此外，为了确保正确的基类子对象布局，可能还需要额外的偏移量调整。

6. 空对象：即使一个类没有数据成员，编译器也可能为其分配一个字节的空间，以确保每个对象实例都有唯一的地址，这有助于识别空对象。

7. 访问控制：不同的访问控制段（public、protected、private）不会影响数据成员在内存中的物理布局，但会影响成员的访问权限。

8. 位域成员：如果类定义中包含位域，这些成员的布局将根据位域的定义紧密打包，这可能导致非直观的内存布局。

## 多重继承数据布局
1. 基类子对象：每个基类的子对象都会被嵌入到派生类对象中，保持各自基类的布局。这些基类子对象的排列顺序可能依据编译器的具体实现，但一些编译器倾向于按照继承列表中基类出现的顺序来安排。每个基类子对象内包含其自身的非静态数据成员，以及如果有的话，一个指向该基类虚函数表的指针（vptr）。

2. 内存对齐：每个基类子对象的起始位置需要满足其内部数据成员的对齐要求。此外，派生类的开始部分以及各个基类子对象间的布局也会考虑对齐，以确保最佳访问性能。

3. 虚函数表指针（vptr）：在多重继承情况下，可能存在多个虚函数表指针。如果基类中存在虚函数，派生类对象通常需要包含一个或多个指向虚函数表的指针。对于有相同虚函数的基类，编译器可能采用虚基类机制或优化策略（如共享虚函数表指针）来避免重复。

4. 虚基类：如果基类本身也是多重继承的产物，且被继承为虚基类，派生类对象中只会包含一个虚基类的实例，而不是每个直接或间接继承路径上的一个。虚基类表指针（vbptr）可能被用来定位这个共享的虚基类实例，确保正确地访问虚基类的数据成员。

5. 派生类特有的数据成员：在所有基类子对象之后，是派生类自己定义的非静态数据成员，按照声明顺序排列并满足对齐要求。

6. 内存填充：为了确保对齐，编译器可能会在基类子对象之间、基类子对象与派生类数据成员之间插入填充字节。

7. 菱形继承问题：菱形继承是最典型的多重继承问题，即一个类直接继承自两个或更多个类，而这些类又共同继承自同一个基类。C++通过引入虚基类来解决这一问题，确保基类的子对象只被继承一次，避免了数据的重复。
