## 深入理解C++对象模型


### 1. 关于指针

#### 1.1 指针的种类有哪些
1. 基本对象指针：
    - 基本数据类型的指针。
    - 如：int* p; 定义了一个指向整型数据的指针。
2. void指针：
    - void* 是一种特殊的指针类型，可以指向任何类型的数据，通常用于需要存储任意类型地址的场合，如通用函数的参数。但使用时通常需要类型转换。
3. 常量指针与指向常量的指针：
    1. 指向常量的指针：如 const int* p;，指针可以指向一个整型常量，但不能通过指针修改所指向的值。
    2. 常量指针：如 int* const p;，指针本身是一个常量，一旦初始化后就不能改变它指向的地址，但可以通过指针修改所指向的值。
    3. 指向常量的常量指针：如 const int* const p;，指针和它指向的值都是不可变的。
4. 函数指针：
    - 指向函数的指针可以存储一个函数的地址，并通过该指针调用函数。如 void (*func_ptr)(int); 定义了一个指向接受一个整型参数且无返回值的函数的指针。
5. 数组指针与指向数组的指针：
    - 数组名本身就可以视为指向其首元素的指针，如 int arr[10]; int* ptr = arr;。
    - 可以声明指向整个数组的指针，如 int (*ptr_to_array)[10];。
6. 多级指针：
    - 如 int **ptr; 是一个二级指针，可以指向一个指针，该指针又指向一个整型数据。多级指针可以扩展到更多级别。
7. 成员指针：
    - 成员指针指向类的非静态成员变量。如 int MyClass::*ptr; 指向 MyClass 中的某个整型成员。

#### 1.2 指针的大小
在给定的系统架构下，所有类型的指针所占用的内存大小是相同的。这是因为指针存储的是地址，而地址空间的大小是由硬件和操作系统决定的，不是由指针所指向的数据类型决定的。
- 在32位系统上，无论指针指向何种类型的数据（如 int*, char*, double* 等），指针本身的大小通常是4字节（32位）。
- 在64位系统上，同样几乎不论指针指向的数据类型如何，指针的大小通常是8字节（64位）。

注意：使用特殊编译器选项或在某些特定的虚拟化环境中，即使是在32位系统上，也有可能配置指针为64位。但这种情况较为少见。

#### 1.99 总结
- 一个指针, 不管它指向那种数据类型, 其本身所需内存大小是固定的, 与计算机的位数一致.
- 指针类型会教导编译器如何解释某个特定地址中的内存内容及其大小.
- void*指针能够持有一个地址, 但不能通过它来操作所指对象, 因为不知道其覆盖怎样的地址空间.


### 2. 关于对象
#### 2.1 三种程序设计范式
- 程序模型：
    - 像C一样，普通的程序
- 抽象数据类型模型（ADT）：
    - 如string类，所谓的抽象由public接口提供。
- 面向对象模型（OO）：
    - C++通过class的pointers和references来支持多态，这种程序设计风格被称为“面向对象”。
    - 在此模型中有一些彼此相关的类型，通过抽象的base class封装起来。

#### 2.2 类对象所占的空间
1. 非静态成员变量跟着对象走，占用类对象的空间。
2. 静态成员变量跟着类走，不占用对象的空间。
3. 成员函数无论是静态还是非静态，都不占用对象空间。
4. 虚函数，无论有几个，都只占用一个函数指针大小的对象空间。
5. 虚函数表是基于类的。
6. 如果类中有多个数据成员，编译器为了提高访问速度和性能，会字节对齐。

一个类只要有虚函数，类对象就会有虚函数表指针(vptr)，虚函数表指针指向虚函数表(vtbl)。

#### 2.3 类对象所占空间的组成
1. 非静态的数据成员
2. 字节对齐额外需要的空间。
3. 为了支持多态(virtual机制)，内部产生的额外空间。

### 4. 关于继承

#### 4.1 this调整与切割

##### 4.1.1 指针和引用实现多态
1. 动态绑定：当使用基类的指针或引用指向派生类对象时，通过这些指针或引用调用虚函数时，实际执行的是派生类中重写的函数。这是因为编译器在运行时根据对象的实际类型（而不是引用或指针的类型）来决定调用哪个函数，这就是所谓的动态绑定或晚期绑定。
```c++
    void playSound(const Animal& animal) {
        animal.makeSound(); // 动态绑定，调用实际对象的 makeSound 方法
    }

    Animal* animalPtr1 = new Dog();
    animalPtr1->makeSound(); // 动态绑定，调用 Dog::makeSound
    playSound(*animalPtr1); // 动态绑定，调用 Dog::makeSound

    Animal* animalPtr2 = new Cat();
    animalPtr2->makeSound(); // 动态绑定，调用 Cat::makeSound
    playSound(*animalPtr2); // 动态绑定，调用 Cat::makeSound
```

2. 灵活性与扩展性：使用指针或引用，可以在不修改现有代码的基础上，轻松地替换为指向不同派生类的对象，提高了代码的灵活性和可维护性。

##### 4.1.2  直接用对象的限制
1. 静态类型绑定：如果直接创建和使用对象（而非通过指针或引用），那么对象的类型在编译时期就已经确定，调用成员函数时将遵循静态绑定规则，即总是调用该对象类型所定义的函数版本。这意味着即便存在虚函数，也无法在运行时根据对象的实际类型来调整行为，失去了多态性。

2. “切割”（Object Slicing）问题：当将一个派生类对象赋值给基类对象或以基类对象的方式传递时，派生类特有的部分（即超出基类的部分）将会被“切掉”，因为基类对象没有足够的空间来容纳派生类的额外数据成员。这种现象称为“对象切片”。

##### 4.1.3 示例说明
假设有一个基类Animal和派生类Dog，且Animal类中有一个虚函数makeSound()。

如果定义一个Animal类型的对象并尝试让它指向一个Dog对象，例如 Animal animal = Dog();，则animal只能访问到Animal类的成员，Dog类特有的行为将被“切掉”。
但如果使用指针或引用，如 Animal* animalPtr = new Dog(); 或 Animal& animalRef = Dog();（注意，这里的构造方式需要修正，实际应为 Animal& animalRef = *new Dog(); 或通过已存在的Dog对象引用），则通过animalPtr或animalRef调用makeSound()时，会执行Dog类中的实现，体现了多态性。


### 3. 关于多态
C++ 实现多态主要有两种途径：静态多态（编译时多态）和动态多态（运行时多态）。

#### 3.1 静态多态的形式
静态多态在编译期间就能确定调用哪个函数，主要包括以下形式：

1. 函数重载（Function Overloading）：允许在同一作用域内使用相同的函数名，但参数列表必须不同（类型、数量或顺序）。编译器根据传入参数的类型和数量来决定调用哪个版本的函数。

2. 运算符重载（Operator Overloading）：为运算符提供不同的实现，使得运算符可以根据操作数的类型表现出不同的行为。

3. 模板（Templates）：泛型编程的一种形式，允许编写与类型无关的代码。编译器根据传递给模板的具体类型生成具体的函数或类实例，实现了编译时的多态性。

#### 3.2 动态多态的形式
动态多态则是在程序运行时决定调用哪个函数，主要依赖于虚函数机制：

1. 虚函数（Virtual Functions）：在基类中声明函数为虚函数（使用 virtual 关键字），并在派生类中重写（Override）这些函数。通过基类的指针或引用指向派生类对象，调用虚函数时，会根据对象的实际类型动态地调用相应的函数实现。

2. 抽象类（Abstract Classes）：包含至少一个纯虚函数（在声明时加上= 0）的类不能被实例化，但可以作为基类被继承，强制要求派生类实现这些纯虚函数，这是实现动态多态的基础结构。

3. RTTI（Run-Time Type Information）：虽然不直接属于多态实现的一部分，但RTTI机制（如 typeid 操作符和 dynamic_cast）可以在运行时查询对象的确切类型，辅助动态多态的实现。

#### 3.3 静态多态是如何实现的？
* *函数和运算符的静态多态*

对于函数和运算符来说，静态多态指的是同名的函数或相同的运算符能够自动选择合适的函数进行调用。一般来说，静态多态强调的是同一个作用域中函数名相同的情况。如果在两个独立的类 A 和 B 中都有 `Foo()` 方法，那么 `A::Foo()` 和 `B::Foo()` 不属于静态多态的概念，因为这两个 `Foo()` 函数在不同的作用域下，只需要在各自的作用域中进行符号解析即可匹配。

编译器处理函数调用的流程如下：

1. **符号解析**：编译器在解析函数调用时，会根据函数名和参数列表查找所有可能的函数定义。
2. **重载决议**：编译器根据参数类型和数量选择最匹配的函数。如果有多个匹配，编译器会根据重载决议规则选择最佳匹配。
3. **生成代码**：编译器生成调用选定函数的代码。

函数和运算符的静态多态主要指的是第二阶段的操作，这部分实现只需要编译器会根据参数类型和数量选择最匹配的函数即可。

* **模板的多态**

模板的静态多态性体现在编译时通过模板实例化生成具体类型的代码。这种多态性在编译时确定，而不是在运行时，因此被称为静态多态。与函数和运算符的静态多态不完全是同一个概念。函数和运算符的静态多态指的是在同一个作用域下，在编译期间就能找到合适的函数进行调用；而模板的静态多态则是在实例化后，在编译期间就能找到合适的函数进行调用。

编译器处理模板函数调用的流程如下：

1. **模板定义**：编译器首先解析模板定义，但不生成代码。
2. **模板实例化**：当模板被具体类型使用时，编译器根据具体类型实例化模板，生成相应的代码。
3. **类型检查**：编译器在实例化模板时进行类型检查，确保模板代码对具体类型有效。
4. **生成代码**：编译器生成实例化后的模板代码。

模板的多态主要指的是第二阶段的过程，只需要知道实现是依赖于编译器对模板实例化即可。

#### 3.4 动态多态是如何实现的？

1. 声明虚函数：首先，在基类中声明一个或多个函数为虚函数。这通常通过在函数声明前加上 virtual 关键字完成。例如：
```cpp
class Base {
public:
    virtual void display() = 0; // 纯虚函数
    virtual void showMessage() { cout << "Base Message" << endl; }
};
```
其中，display() 是一个纯虚函数，要求任何派生类都必须重写它；而 showMessage() 是一个普通的虚函数，派生类可以选择是否重写。

2. 继承与重写：派生类继承自基类，并可以选择性地重写（override）虚函数。重写意味着在派生类中提供了一个具有相同签名的新版本函数。例如：
```cpp
class Derived : public Base {
public:
    void display() override { cout << "Derived Display" << endl; } // 重写 display()
    void showMessage() override { cout << "Derived Message" << endl; } // 重写 showMessage()
};
```

3. 虚表与虚指针：编译器为含有虚函数的每个类自动生成一个虚函数表（vtable），这个表是一个函数指针数组，包含了该类及其基类的所有虚函数地址。同时，每个含有虚函数的对象都会有一个隐藏的指针（称为虚指针，vptr），指向该对象所属类的虚函数表。虚表的构造和虚指针的初始化通常发生在对象构造时。

4. 动态绑定（Late Binding）：当通过基类指针或引用调用一个虚函数时，实际调用哪个版本的函数是在运行时决定的。这称为动态绑定或迟后绑定。编译器通过对象的虚指针查找虚函数表，然后根据虚函数在表中的位置调用正确的函数实现。即使是指向派生类对象的基类指针，也能正确地调用派生类的虚函数实现，实现了动态多态性。

#### 3.5 动态多态导致类对象的内存布局改变
* **无动态多态时的内存布局（即当一个类不包含虚函数时）**
- 对象头部：通常只包含直接的数据成员。对象的大小直接由其数据成员的总大小决定，加上可能的padding（用于对齐）。
- 访问速度：因为函数调用是静态绑定的，编译器在编译时期就能确定调用哪个函数，因此访问速度快。

* **含有动态多态时的内存布局**
当一个类包含虚函数或继承自含有虚函数的基类时：
- 虚函数表指针（vptr）：对象内存布局中会额外包含一个指向虚函数表（vtbl）的指针。这个vptr通常位于对象的最开始位置，但这也取决于具体的编译器实现。
- 虚函数表（vtbl）：不在对象实例内，而是在类的内存区域。它存储了该类及其基类中所有虚函数的地址。
- 对象大小：由于增加了vptr，对象的总大小会比无多态时增加（通常是一个指针大小，如4字节或8字节）。
- 访问速度：虚函数调用需要通过vptr间接访问虚函数表，再根据表中地址调用实际函数，因此相对于静态绑定，动态调用会有一定的性能开销。
- 多态行为：通过基类指针或引用来调用虚函数时，能够根据对象的实际类型执行相应的派生类函数，实现了运行时的多态性。

### 5. 总结
1. 只有通过指针(pointer)或引用(reference)的间接处理基类对象, 才支持面向对象程序设计所需的多态性质.
2. C++中, 多态只存在与public 类体系中, nonpublic的派生行为和void*的指针的多态性, 必须由程序员来显式管理.
3. 多态的主要用途是经由一个共同的接口来影响类型的封装, 这个接口一般定义在一个抽象的基类中.
4. 派生类不会新添加虚表指针(vptr, 继续使用基类的指针), 只是覆盖的地址会有所不同.
5. 类型信息的封装并不是维护于指针之中, 而是维护于链接(link)之中, 此链接存在于对象的虚表指针(vptr), 和vptr所指的虚表(virtual table)之间.
6. 编译器必须确保每个对象有一个或一个以上的vptr, 这些vptr的内容不会被基类对象初始化或改变.
7. 一个指针或引用之所以支持多态, 是因为它们并不引发内存中任何与内存相关的内存委托操作, 会改变的只有他们所指内存的"大小和内容解释方式"而已.
8. 将派生类直接用于初始化基类对象时, 派生类对象会被切割以塞入较小的基类类型内存中.

### 99 quiz 
#### 1. OO（Object-Oriented，面向对象）和ADT（Abstract Data Type，抽象数据类型）区别：

* **ADT（抽象数据类型）**
1. 定义：ADT是对数据结构的一种抽象描述，它关注的是数据类型的逻辑定义，包括数据的存储结构和在此结构上可以执行的操作，而不关心这些操作的具体实现细节。ADT提供了一种封装机制，隐藏了数据的内部表示，只暴露必要的接口给用户。

2. 特点：
- 抽象性：ADT强调的是数据类型的逻辑特性，而不是物理实现。
- 封装性：隐藏数据结构和实现细节，只暴露接口。
- 通用性：ADT的定义独立于任何编程语言，可以用任何支持相应数据结构的语言实现。

3. 示例：栈、队列、列表等都是典型的ADT，它们定义了数据的添加、删除、查看等操作，而不关心这些操作是如何具体实现的。

* **OO（面向对象）**
1. 定义：面向对象编程是一种编程范式，它使用“对象”来设计软件，这些对象包含了数据（属性）和操作这些数据的方法（行为）。OO不仅仅是关于数据类型，更是一种软件设计思想，强调通过对象的组合、继承和多态来构建复杂系统。

2. 特点：
- 封装：与ADT相似，但更全面，不仅限于数据，还包括方法的封装。
- 继承：允许创建分层的类结构，子类可以继承父类的属性和方法，并可进行扩展或覆盖。
- 多态：同一种消息可以被不同的对象以不同的方式响应，增加了代码的灵活性和可复用性。

3. 示例：在面向对象的语言如Java或C++中，定义一个“动物”类，可以有“名字”和“年龄”属性，以及“叫”这样的方法。然后，可以创建“狗”和“猫”这样的子类，它们继承自“动物”类，并可以重写或添加新的方法。

#### 2. class 和 struct的区别
struct的默认访问修饰符是public；而class的默认访问修饰符是private。
struct的默认继承方式是public，而class的默认继承方式是private。除此之外使用时没有区别。
- 某种意义上, 在C++中struct和class这两个关键字是可以互换的。

又因为struct没有访问修饰符，因此struct中的成员变量是按声明顺序出现的内存中的，而在C++中，class/struct有访问修饰符，因此成员变量未必是按照声明顺序出现在内存中的。

除了实现上，class和struct有区别外。
他们背后直接承载的设计意义也有一定区别，class不仅是一个关键字, 它还会引入它所支持的封装和继承的哲学。
而struct作为c语言的关键字，更多时候是作为纯粹数据类型集合而存在的。

--- 
#### 3. 空类对象所占的空间是多少，为什么？
这是为了确保每个空类对象都有一个唯一的地址，从而使得不同的空类对象在内存中是可区分的。

#### 4. 下面这个调用什么方法？
```c++
#include <iostream>

// 基类
class Animal {
   public:
    Animal() { std::cout << "Animal constructor called" << std::endl; }

    Animal(const Animal& other) {
        std::cout << "Animal copy constructor called" << std::endl;
    }

    virtual void makeSound() const {
        std::cout << "Animal makes a sound" << std::endl;
    }
};

// 派生类
class Dog : public Animal {
   public:
    Dog() { std::cout << "Dog constructor called" << std::endl; }

    void makeSound() const override { std::cout << "Dog barks" << std::endl; }
};

class Cat : public Animal {
   public:
    Cat() { std::cout << "Cat constructor called" << std::endl; }

    void makeSound() const override { std::cout << "Cat meows" << std::endl; }
};

int main() {
    // 这是通过拷贝构造过去的。因此animal的vptr就是animal的。
    // 后面转成指针再调用也找不到dog::makeSound.
    // 静态类型绑定，animal 的类型在编译时确定为 Animal
    Animal animal = Dog();
    animal.makeSound();      // 调用 Animal::makeSound，因为静态绑定
    (&animal)->makeSound();  // 调用 Animal::makeSound，因为静态绑定

    // 使用指针避免对象切片
    Animal* animalPtr = new Dog();
    animalPtr->makeSound();  // 动态绑定，调用 Dog::makeSound

    // 使用引用避免对象切片
    Animal& animalRef = *animalPtr;
    animalRef.makeSound();  // 动态绑定，调用 Dog::makeSound

    delete animalPtr;  // 释放动态分配的内存

    return 0;
}
```