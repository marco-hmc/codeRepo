## 深入理解C++对象模型

### 1. 关于指针
指针=内存地址+类型信息

#### 1.1 指针的种类有哪些
1. 基本对象指针：
    - 基本数据类型的指针。
    - 如：int* p; 定义了一个指向整型数据的指针。
2. void指针：
    - void* 是一种特殊的指针类型，可以指向任何类型的数据，通常用于需要存储任意类型地址的场合，如通用函数的参数。但使用时通常需要类型转换。
3. 常量指针与指向常量的指针：
    1. 指向常量的指针：如 const int* p;，指针可以指向一个整型常量，但不能通过指针修改所指向的值。
    2. 常量指针：如 int* const p;，指针本身是一个常量，一旦初始化后就不能改变它指向的地址，但可以通过指针修改所指向的值。
    3. 指向常量的常量指针：如 const int* const p;，指针和它指向的值都是不可变的。
4. 函数指针：
    - 指向函数的指针可以存储一个函数的地址，并通过该指针调用函数。如 void (*func_ptr)(int); 定义了一个指向接受一个整型参数且无返回值的函数的指针。
5. 数组指针与指向数组的指针：
    - 数组名本身就可以视为指向其首元素的指针，如 int arr[10]; int* ptr = arr;。
    - 可以声明指向整个数组的指针，如 int (*ptr_to_array)[10];。
6. 多级指针：
    - 如 int **ptr; 是一个二级指针，可以指向一个指针，该指针又指向一个整型数据。多级指针可以扩展到更多级别。
7. 成员指针：
    - 成员指针指向类的非静态成员变量。如 int MyClass::*ptr; 指向 MyClass 中的某个整型成员。

#### 1.2 指针的大小
在给定的系统架构下，所有类型的指针所占用的内存大小是相同的。这是因为指针存储的是地址，而地址空间的大小是由硬件和操作系统决定的，不是由指针所指向的数据类型决定的。
- 在32位系统上，无论指针指向何种类型的数据（如 int*, char*, double* 等），指针本身的大小通常是4字节（32位）。
- 在64位系统上，同样几乎不论指针指向的数据类型如何，指针的大小通常是8字节（64位）。

注意：使用特殊编译器选项或在某些特定的虚拟化环境中，即使是在32位系统上，也有可能配置指针为64位。但这种情况较为少见。

#### 1.99 总结
- 一个指针, 不管它指向那种数据类型, 其本身所需内存大小是固定的, 与计算机的位数一致.
- 指针类型会教导编译器如何解释某个特定地址中的内存内容及其大小.
- void*指针能够持有一个地址, 但不能通过它来操作所指对象, 因为不知道其覆盖怎样的地址空间.


### 2. 关于对象
#### 2.1 三种程序设计范式
- 程序模型：
    - 像C一样，普通的程序
- 抽象数据类型模型（ADT）：
    - 如string类，所谓的抽象由public接口提供。
- 面向对象模型（OO）：
    - C++通过class的pointers和references来支持多态，这种程序设计风格被称为“面向对象”。
    - 在此模型中有一些彼此相关的类型，通过抽象的base class封装起来。

#### 2.2 类对象所占的空间
1. 非静态成员变量跟着对象走，占用类对象的空间。
2. 静态成员变量跟着类走，不占用对象的空间。
3. 成员函数无论是静态还是非静态，都不占用对象空间。
4. 虚函数，无论有几个，都只占用一个函数指针大小的对象空间。
5. 虚函数表是基于类的。
6. 如果类中有多个数据成员，编译器为了提高访问速度和性能，会字节对齐。

一个类只要有虚函数，类对象就会有虚函数表指针(vptr)，虚函数表指针指向虚函数表(vtbl)。

#### 2.3 类对象所占空间的组成
1. 非静态的数据成员
2. 字节对齐额外需要的空间。
3. 为了支持多态(virtual机制)，内部产生的额外空间。

### 3. 关于多态
多态是面向对象编程的一个重要特性，它允许我们使用一个接口来表示多种形态的对象。多态的主要优点是它可以提高代码的可重用性和可扩展性。通过使用多态，我们可以编写出更加通用的代码，这些代码可以处理任何符合特定接口的对象，而不需要关心对象的具体类型。这使得我们可以更容易地添加新的类型，而不需要修改已有的代码。
C++ 实现多态主要有两种途径：静态多态（编译时多态）和动态多态（运行时多态）。

#### 3.1 静态多态的形式
静态多态在编译期间就能确定调用哪个函数，主要包括以下形式：

1. 函数重载（Function Overloading）：允许在同一作用域内使用相同的函数名，但参数列表必须不同（类型、数量或顺序）。编译器根据传入参数的类型和数量来决定调用哪个版本的函数。
2. 运算符重载（Operator Overloading）：为运算符提供不同的实现，使得运算符可以根据操作数的类型表现出不同的行为。
3. 模板（Templates）：泛型编程的一种形式，允许编写与类型无关的代码。编译器根据传递给模板的具体类型生成具体的函数或类实例，实现了编译时的多态性。

#### 3.2 动态多态的形式
动态多态则是在程序运行时决定调用哪个函数，主要依赖于虚函数机制：

1. 虚函数（Virtual Functions）：在基类中声明函数为虚函数（使用 virtual 关键字），并在派生类中重写（Override）这些函数。通过基类的指针或引用指向派生类对象，调用虚函数时，会根据对象的实际类型动态地调用相应的函数实现。
2. 抽象类（Abstract Classes）：包含至少一个纯虚函数（在声明时加上= 0）的类不能被实例化，但可以作为基类被继承，强制要求派生类实现这些纯虚函数，这是实现动态多态的基础结构。
3. RTTI（Run-Time Type Information）：虽然不直接属于多态实现的一部分，但RTTI机制（如 typeid 操作符和 dynamic_cast）可以在运行时查询对象的确切类型，辅助动态多态的实现。

#### 3.3 静态多态是如何实现的？
##### 3.3.1 函数和运算符的静态多态

对于函数和运算符来说，静态多态指的是同名的函数或相同的运算符能够自动选择合适的函数进行调用。一般来说，静态多态强调的是同一个作用域中函数名相同的情况。如果在两个独立的类 A 和 B 中都有 `Foo()` 方法，那么 `A::Foo()` 和 `B::Foo()` 不属于静态多态的概念，因为这两个 `Foo()` 函数在不同的作用域下，只需要在各自的作用域中进行符号解析即可匹配。

编译器处理函数调用的流程如下：

1. **符号解析**：编译器在解析函数调用时，会根据函数名和参数列表查找所有可能的函数定义。
2. **重载决议**：编译器根据参数类型和数量选择最匹配的函数。如果有多个匹配，编译器会根据重载决议规则选择最佳匹配。
3. **生成代码**：编译器生成调用选定函数的代码。

函数和运算符的静态多态主要指的是第二阶段的操作，这部分实现只需要编译器会根据参数类型和数量选择最匹配的函数即可。

##### 3.3.2 模板的多态

模板的静态多态性体现在编译时通过模板实例化生成具体类型的代码。这种多态性在编译时确定，而不是在运行时，因此被称为静态多态。与函数和运算符的静态多态不完全是同一个概念。函数和运算符的静态多态指的是在同一个作用域下，在编译期间就能找到合适的函数进行调用；而模板的静态多态则是在实例化后，在编译期间就能找到合适的函数进行调用。

编译器处理模板函数调用的流程如下：

1. **模板定义**：编译器首先解析模板定义，但不生成代码。
2. **模板实例化**：当模板被具体类型使用时，编译器根据具体类型实例化模板，生成相应的代码。
3. **类型检查**：编译器在实例化模板时进行类型检查，确保模板代码对具体类型有效。
4. **生成代码**：编译器生成实例化后的模板代码。

模板的多态主要指的是第二阶段的过程，只需要知道实现是依赖于编译器对模板实例化即可。

#### 3.4 动态多态（虚函数）是如何实现的？

在 C++ 中，虚函数的实现主要依赖于虚函数表（也称为 vtable）。每一个有虚函数的类，编译器都会为其生成一个虚函数表，表是一个函数指针数组，表中包含了该类及其基类的所有虚函数地址。每一个该类的对象，都会有一个指向虚函数表的指针（通常称为 vptr）。

虚表的构造和虚指针的初始化通常发生在对象构造时。当一个对象被创建时，编译器会自动将该对象的 vptr 初始化为指向该类的虚函数表。

当我们通过基类指针调用虚函数时，实际上是通过这个指针找到虚函数表，然后在表中查找并调用对应的函数。实际调用哪个版本的函数是在运行时决定的。这是因为在编译时无法确定当前对象的实际类型，只有在运行时才能通过 vptr 确定实际类型并找到对应的虚函数表。

如果Foo类是父类，Bar1和Bar2是子类，而func()是Foo类虚函数的时候。那么就会有分别对应的三个虚函数表。对象实例化的时候就会有一个指针指向一个虚函数表，虚函数表里有一个Foo类函数地址。
这个时候不管静态解析类型是什么，比如说是Foo类，但调用func()方法的时候，因为编译器知道func()是虚函数方法。都是通过虚函数指针找到实际调用对象。

##### 3.4.1 虚函数调用例子
我们定义了一个基类`Shape`和一个派生类`Circle`。基类中定义了一个虚函数`draw`，派生类中重写了这个函数。在`main`函数中，我们创建了一个`Circle`对象，然后通过一个`Shape`类型的指针来调用`draw`函数。由于`draw`函数是虚函数，所以实际调用的是`Circle`类的`draw`函数，而不是`Shape`类的`draw`函数。

以下是一个简单的图示，展示了虚函数表的工作原理：
```
  Shape object:    Circle object:    Shape vtable:    Circle vtable:
+-------------+  +-------------+   +-------------+  +-------------+
| vptr        |  | vptr        |   | draw()      |  | draw()      |
| ...         |  | ...         |   | ...         |  | ...         |
+-------------+  +-------------+   +-------------+  +-------------+
  |                |                 |                |
  |                |                 v                v
  |                |               Shape::draw()    Circle::draw()
  |                |
  v                v
Shape::vtable    Circle::vtable
```

在这个图示中，`Shape`对象和`Circle`对象都有一个`vptr`，这是一个指向虚函数表的指针。`Shape`的`vptr`指向`Shape`的虚函数表，`Circle`的`vptr`指向`Circle`的虚函数表。虚函数表中存储了虚函数的地址，所以当我们通过`Shape`指针调用`draw`函数时，实际上是通过`vptr`找到虚函数表，然后在表中查找并调用对应的函数。

简单来说，
* 每一个有虚函数的对象下的都会有一个`vtable`,如上面的`Shape vtable`和`Circle vtable`.
* 每一个从有虚函数的对象下来的实例都会有一个`vptr`,`vptr`指向`vtable`, 如上面的`Shape object`和`Circle object`.
* 当我对某一个`Shape object`调用`draw()`函数时，查询方式都是通过`vptr`找到`vtable`的`draw()`。

#### 3.5 动态多态导致类对象的内存布局改变
* **无动态多态时的内存布局（即当一个类不包含虚函数时）**
- 对象头部：通常只包含直接的数据成员。对象的大小直接由其数据成员的总大小决定，加上可能的padding（用于对齐）。
- 访问速度：因为函数调用是静态绑定的，编译器在编译时期就能确定调用哪个函数，因此访问速度快。

* **含有动态多态时的内存布局**
当一个类包含虚函数或继承自含有虚函数的基类时：
- 虚函数表指针（vptr）：对象内存布局中会额外包含一个指向虚函数表（vtbl）的指针。这个vptr通常位于对象的最开始位置，但这也取决于具体的编译器实现。
- 虚函数表（vtbl）：不在对象实例内，而是在类的内存区域。它存储了该类及其基类中所有虚函数的地址。
- 对象大小：由于增加了vptr，对象的总大小会比无多态时增加（通常是一个指针大小，如4字节或8字节）。
- 访问速度：虚函数调用需要通过vptr间接访问虚函数表，再根据表中地址调用实际函数，因此相对于静态绑定，动态调用会有一定的性能开销。
- 多态行为：通过基类指针或引用来调用虚函数时，能够根据对象的实际类型执行相应的派生类函数，实现了运行时的多态性。

#### 3.6 多继承的时候，虚函数怎么处理的？

在C++的多继承中，每个基类都有自己的虚函数表。当一个类从多个基类继承时，它会有多个虚函数表指针，每个指针指向一个基类的虚函数表。当我们通过基类指针调用虚函数时，会根据指针的类型找到对应的虚函数表，然后在表中查找并调用对应的函数。

一般情况下，如果有多继承，且父类都是有虚函数的话，就会有多个`vptr`。编译器生成代码的时候也能够知道用哪个`vptr`，忽略编译器额外时间开销的话，多继承和单一继承的虚函数调用开销是一样的。

### 4. 关于继承

#### 4.1 虚继承

##### 4.2.1 虚继承是什么？有什么用？

虚继承是C++中的一种特殊的继承方式，主要用于解决多继承中的菱形继承问题。在菱形继承中，如果不使用虚继承，那么最底层的派生类会继承多份基类的数据和方法，这会导致资源的浪费和访问的歧义。
而解决菱形继承的，关键思想在于保证父类数据的唯一。 为了实现父类数据的唯一，派生类都不直接持有父类数据，而是通过一个指针找到父类数据。 这个指针就是vbptr，父类数据则存储在vbtable表中。当出现菱形继承的时候，则会有两个vbptr指针。编译器会发现这两个指针指向同一个表地址，就优化为一个指针。 这样子就可以保证数据唯一了。

以下是一个不使用虚继承的菱形继承例子，这将导致编译错误：

```cpp
class Base {
public:
    int x;
};

class Derived1 : public Base {
    // ...
};

class Derived2 : public Base {
    // ...
};

class MostDerived : public Derived1, public Derived2 {
    // ...
};

int main() {
    MostDerived md;
    md.x = 10;  // 编译错误：MostDerived中有两份Base::x，编译器无法确定应该访问哪一份
    return 0;
}
```

在这个例子中，`Derived1`和`Derived2`都继承了`Base`，所以在`MostDerived`中有两份`Base::x`。当我们试图访问`md.x`时，编译器无法确定我们应该访问哪一份`Base::x`，所以会报错。

这个问题可以通过使用虚继承来解决。虚继承会让从多个路径继承来的同一个基类，在派生类中只保留一份拷贝。这样，就不会出现上述的编译错误，因为在`MostDerived`中只有一份`Base::x`。

##### 4.2.2 虚继承的原理是什么？


### 5. 总结
1. 只有通过指针(pointer)或引用(reference)的间接处理基类对象, 才支持面向对象程序设计所需的多态性质.
2. C++中, 多态只存在与public 类体系中, nonpublic的派生行为和void*的指针的多态性, 必须由程序员来显式管理.
3. 多态的主要用途是经由一个共同的接口来影响类型的封装, 这个接口一般定义在一个抽象的基类中.
4. 派生类不会新添加虚表指针(vptr, 继续使用基类的指针), 只是覆盖的地址会有所不同.
5. 类型信息的封装并不是维护于指针之中, 而是维护于链接(link)之中, 此链接存在于对象的虚表指针(vptr), 和vptr所指的虚表(virtual table)之间.
6. 编译器必须确保每个对象有一个或一个以上的vptr, 这些vptr的内容不会被基类对象初始化或改变.
7. 一个指针或引用之所以支持多态, 是因为它们并不引发内存中任何与内存相关的内存委托操作, 会改变的只有他们所指内存的"大小和内容解释方式"而已.
8. 将派生类直接用于初始化基类对象时, 派生类对象会被切割以塞入较小的基类类型内存中.


### 99 quiz 

#### 1. 当对象调用一个普通成员函数，和调用一个虚函数，编译器是怎么区别对待的？
当对象调用一个普通成员函数和调用一个虚函数时，编译器的处理方式是不同的。
* 对于普通成员函数，编译器在编译时就能确定函数的地址，所以在生成的汇编代码中，函数调用会直接转换为对应的函数地址。
* 对于虚函数，编译器在编译时不能确定函数的地址，因为虚函数的调用需要在运行时通过虚函数表来确定。所以在生成的汇编代码中，函数调用会转换为通过虚函数表来查找函数地址。

#### 2. 调用虚函数的时候，是通过vptr找到对应的虚函数表，再调用实际函数。那么虚函数表很大的时候，开销会增加吗？
虽然说调用实际函数是在虚函数表找的，但是这个虚函数在表中的位置是固定的。编译器在编译时已经确定了每个虚函数在虚函数表中的索引。
因此运行的时候不需要遍历表找到方法，而是编译期间的时候就能确定确定了。
换句话说，同一继承体系下，不同类的相同虚函数在虚函数表的偏移地址都是一样的。

#### 3. 怎么理解调用虚函数的开销？什么时候需要考虑？
非内联函数的直接调用大概是45-90ns级别。如果是虚函数则大概是90-180ns级别。
除此之外，一般函数直接调用的时候分支预测和指令预取命中率会更高。虚函数的间接调用是不利于优化的。这部分的开销也需要考虑的。

但总的而言，这个开销是固定的，如果一个函数不考虑纳秒级别的优化，就不需要考虑虚函数带来的影响。如果是到了纳秒级别优化的时候，也建议实际测一下开销，测了才能知道虚函数的开销是否不可接受。


#### 4. 基类析构函数为什么要是虚函数？

如果不是虚函数的话,可能会有内存泄漏的问题
如果你有一个基类指针指向一个派生类对象:
```c++
Copy code
Base* ptr = new Derived();
delete ptr; // 这里会首先调用Derived的析构函数,然后调用Base的析构函数
```
如果基类的析构函数不是虚函数,那么只会调用基类的析构函数,而Derived的析构函数将不会被调用,可能导致资源泄漏.

#### 5. C++多继承的时候，如何处理同名成员变量？同名成员函数？

如果两个基类有同名的成员变量或成员函数，那么在派生类中需要通过作用域解析运算符（::）来指定要访问哪个基类的成员。

如果是对派生类访问两个基类同名的成员变量，就会报错。

#### 5. 对于非多态类型和多态类型，如何获取类型信息（type_info）？

- 对于**非多态类型**（即没有虚函数的类），类型信息（type_info）通常可以通过编译时的类型信息直接获取，不需要通过虚拟表（vtable）来访问。

- 对于**多态类型**（即包含至少一个虚函数的类），每个对象会有一个虚拟表（vtable），其中包含了指向该类型type_info对象的指针。这样，可以通过对象的虚拟表在运行时动态地访问到其类型信息。

#### 6. 如何防止不同类型的之间进行赋值操作，同时允许同类型的之间进行赋值
这段代码的主要目标是防止不同类型的动物之间进行赋值操作，同时允许同类型的动物之间进行赋值。为了实现这个目标，它引入了一个抽象基类`AbstractAnimal`，并将赋值操作符`operator=`设为`protected`，这样只有`AbstractAnimal`的子类可以访问它。

然后，每个具体的动物类（如`Lizard`和`Chicken`）都提供了自己的赋值操作符，这样就可以在同类型的动物之间进行赋值。

以下是一个完整的例子：

```cpp
class AbstractAnimal {
protected:
    AbstractAnimal& operator=(const AbstractAnimal& rhs) {
        // 假设这里进行了一些通用的赋值操作
        return *this;
    }
public:
    virtual ~AbstractAnimal() = 0; // 纯虚析构函数
};

AbstractAnimal::~AbstractAnimal() {} // 纯虚析构函数的定义

class Lizard : public AbstractAnimal {
public:
    Lizard& operator=(const Lizard& rhs) {
        AbstractAnimal::operator=(rhs); // 调用基类的赋值操作符
        // 这里可以添加一些针对Lizard的赋值操作
        return *this;
    }
};

class Chicken : public AbstractAnimal {
public:
    Chicken& operator=(const Chicken& rhs) {
        AbstractAnimal::operator=(rhs); // 调用基类的赋值操作符
        // 这里可以添加一些针对Chicken的赋值操作
        return *this;
    }
};

int main() {
    Lizard liz1, liz2;
    liz1 = liz2; // 正确，把一个lizard赋值给了一个lizard

    Chicken chick;
    // liz1 = chick; // 错误，不能把一个chicken赋值给一个lizard

    return 0;
}
```

在这个例子中，我们不能把一个`Chicken`赋值给一个`Lizard`，因为`Lizard::operator=`只接受`Lizard`类型的参数。但我们可以在两个`Lizard`之间进行赋值，因为`Lizard::operator=`接受`Lizard`类型的参数。


#### 7. 为什么虚函数指针不能被拷贝？

```c++
#include <iostream>

class Animal {
   public:
    Animal() { std::cout << "Animal constructor" << std::endl; }

    Animal(const Animal& other) {
        std::cout << "Animal copy constructor" << std::endl;
    }

    virtual void eat() { std::cout << "Animal eats" << std::endl; }
};

class Dog : public Animal {
   public:
    Dog() { std::cout << "Dog constructor" << std::endl; }

    void eat() override { std::cout << "Dog eats" << std::endl; }
};

int main() {
    Animal dog = Dog();  // 对象切片，调用 Animal 的拷贝构造函数
    dog.eat();           // 调用 Animal::eat()
    return 0;
}

/*
1. 为什么调用的是animal::eat()方法？

2. Animal dog = Dog();这个过程发生了什么？
    抛开Dog的构造过程，Animal dog = Dog()，这个过程是拷贝构造，调用了Animal的拷贝构造函数。
    由于 `Animal` 类的拷贝构造函数的形参是 `const Animal&`，因此需要将 `Dog` 对象转换为 `Animal` 对象。
    也就是说dog首先会发生一次隐式转换。
    在这个过程中Dog()的部分会被切掉，只剩下Animal的部分，被拷贝到dog中，
    因为dog在栈上申请内存的时候是按照Animal的大小申请的，dog的内存布局是按照Animal来的。
    所以切掉Dog()的部分，只剩下Animal的部分是显然的。
    这个过程就是对象切片。

    根据结果我们知道，虚函数指针也被切掉了。那为什么虚函数指针也被切掉了呢？

    如果派生类有虚函数指针的时候，父类没有虚函数指针，因此Dog的虚函数指针被切掉了。是很好理解的。
    可如果父类有虚函数指针，为什么不能直接拷贝子类的虚函数指针呢？
    这是为了安全考虑，编译器禁止了这种行为。
    如果子类的虚函数指针被拷贝到父类的对象中，那么在这个对象就可以调用子类的虚函数。
    这个时候子类的虚函数有可能是使用了子类特有的类成员变量的，但是父类的对象中并没有这个成员变量，因此会出现问题的。
    因此编译器在设计的时候，为了避免这个问题，直接将子类的虚函数指针给切掉了。
  
3. 派生类构造的时候发生了什么？

*/
```