## 构造函数语义学

### 0. concepts

#### 0.1 基本类的实现
```c++
class Example {
public:
    int value;
};

public:
Example::Example() : value(0) {}
Example::~Example() {}

// 拷贝构造
Example::Example(const Example& other) : value(other.value) {}

// 拷贝赋值
Example& Example::operator=(const Example& other) {
    if (this != &other) {
        value = other.value;
    }
    return *this;
}

// 移动构造
Example::Example(Example&& other) noexcept : value(other.value) {
    other.value = 0;
}

// 移动赋值
Example& Example::operator=(Example&& other) noexcept {
    if (this != &other) {
        value = other.value;
        other.value = 0;
    }
    return *this;
}
```

#### 0.2 编译器会为C++的类自动生成以下六种特殊的成员函数：

1. 默认构造函数（如果没有定义任何构造函数）
    `T()`
2. 析构函数（如果没有定义）
    `~T()`
3. 拷贝构造函数（如果没有定义并且某些条件满足）
    `T(const T& other)`
4. 拷贝赋值运算符（如果没有定义并且某些条件满足）
    `T& operator=(const T& other)`
5. 移动构造函数（如果没有定义并且某些条件满足，C++11及以后）
    `T(T&& other)`
6. 移动赋值运算符（如果没有定义并且某些条件满足，C++11及以后）
    `T& operator=(T&& other)`

这些函数被称为特殊成员函数。它们是编译器为了支持一些基本操作（如初始化、拷贝、移动、销毁对象）而自动为类生成的。但是，如果你为类定义了自己的版本，编译器就不会再生成这些函数。除此不同函数，在不同特定条件下也不会自动生成。

### 1. 构造函数

#### 1.1 默认构造函数
编译器大部分情况下，都能生成默认构造函数，只有以下情形不可以。
1. 类中有一个没有默认构造函数的成员对象。
2. 基类没有默认构造函数。
3. 类中有一个 `const` 或 `引用` 类型的成员。
4. 类中有一个 `delete` 的默认构造函数。
5. 类中有一个私有的默认构造函数。
简单来说，就是父类，成员变量没有默认构造，或者成员变量必须初始化的时候没办法生成合法的默认构造函数。其他时候都可以。

#### 1.2 对象的构造顺序

```cpp
C cObj;
    C::C()   
        B::B()
            A::A()  
                vptr = A::vftable; 
                cout << "A::A()" << endl; 
            vptr = B::vftable;   
            cout << "B::B()" << endl;  
        vptr = C::vftable;   
        m_c = 11; 
        cout << "C::C()" << endl; 
```

#### 1.3 构造函数中对虚函数的调用
某个类的构造函数 中 调用一个虚函数，那么走的不是虚函数表，而是通过地址直接调用。
如果当前类没有此虚函数，会向上寻找父类的同名虚函数，如果找到也是通过函数地址直接调用。

### 2. 析构函数语义
当类没有自定义析构函数时，编译器会自动生成一个合成析构函数。

#### 2.1 合成析构函数行为

- **空函数**：如果类中没有自定义的资源管理（如动态分配的内存），合成的析构函数不会执行任何特定的操作，它仅仅是一个空函数。这意味着它不负责清理任何类成员的资源。
- **成员变量的析构**：如果类中有非静态成员变量，并且这些成员变量有自己的析构函数（无论是用户定义的还是合成的），合成的析构函数会按照这些成员在类声明中的逆序调用它们的析构函数。这样做确保了每个成员的资源被适当地释放。
- **基类析构函数的调用**：在继承层次中，如果基类有合成的析构函数，派生类的合成析构函数会在调用自己的析构函数之后自动调用基类的析构函数，同样保持逆序的原则。

#### 2.2 自定义析构函数的扩展行为
当我们自定义析构函数时，编译器会在适当的情况下扩展我们的析构函数代码，以确保所有资源都被正确释放。

- **成员变量的析构**：如果类成员 `m_j` 是一个类类型成员，并且这个成员 `m_j` 带有析构函数 `~JI()`，编译器会扩展类 `A` 的析构函数 `~A()` 代码，先执行类 `A` 的析构函数代码，再执行 `JI` 的析构函数代码。
- **基类析构函数的调用**：如果类 `A` 继承了一个基类，并且基类中带有析构函数，那么编译器会扩展类 `A` 的析构函数来调用基类的析构函数。这确保了基类的资源也能被正确释放。


### 2. 拷贝构造函数语义
如果一个Class没有声明一个copy constructor，编译器就会隐式声明一个copy constructor，只有编译器需要的时候，编译器才会定义一个copy constructor实例，并合成于程序之中，而编译器需要的时候是指Class不展现出bitwise copy semantics（位逐次拷贝）。即“如果一个Class未定义出copy constructor，编译器就会自动为它产生出一个”这句话是不对的，只有当Class不展现出bitwise copy semantics时编译器才会产生一个。

#### 2.1 什么时候不会生成默认拷贝构造函数？
1. 类中显式声明/删除拷贝构造函数。
2. 类成员变量/基类有一个没有拷贝构造函数的成员对象。
3. 类中有一个 `const` 或 `引用` 类型的成员。

简单来说，如果你没有显式定义拷贝函数，且类中的所有成员都可以被拷贝，编译器就会为你生成这两个函数。
反过来说，如果类中有不能被拷贝的成员（例如，`std::unique_ptr`或者定义了删除的拷贝构造函数的类型的成员），编译器就不会生成这两个函数。

#### 2.1 什么情况下一个类不展现"浅拷贝语意"？
什么情况下一个类不展现"浅拷贝语意":
1. 当类内含有一个成员类而后者的类声明中有一个拷贝构造函数(例如内含有string成员变量)
2. 当类继承自一个基类而基类中存在拷贝构造函数
    这两个编译器都会合成拷贝构造函数并且安插进那个成员和基类的拷贝构造函数
3. 当类声明了一个或多个虚函数
    编译器会显式的设定新类的虚函数表,而不是直接拷贝过来指向同一个
4. 当类派生自一个继承串链,其中有一个或多个虚基类
编译器会合成一个拷贝构造函数,安插一些代码用来设定虚基类指针和偏移的初值,对每个成员执行必要的深拷贝初始化操作,以及执行其他的内存相关工作

#### 2.2 默认的拷贝构造函数行为是什么？
* 位逐次拷贝
* 调用父类子类的拷贝构造函数，再调用自己的。

#### 2.3 什么时候会调用拷贝构造函数？
```c++
Foo func(Foo foo){  // foo was passed by copy
    return Foo{};
}

Foo foo;
Foo copiedFoo = foo; // assignment was done by copy
auto newFoo = func(foo);  // return val was copied to newFoo
```

#### 2.4 为什么拷贝的形参是`const T&`？？

1. **性能**:当参数是值时,会创建该对象的一个新的副本,这涉及到对象的复制操作,可能会消耗大量的时间和内存.特别是当对象较大时,复制的代价会非常高.而当参数是常量引用时,只需要传递引用,不需要复制对象,因此性能更高.

2. **避免无限递归**:如果拷贝构造函数的参数是值,那么在调用拷贝构造函数时,需要先创建一个新的对象,这又需要调用拷贝构造函数,从而形成无限递归,导致程序崩溃.而当参数是常量引用时,不会触发拷贝构造函数,因此可以避免无限递归.

所以,拷贝构造函数的参数通常是常量引用,而不是值.


### 3. 移动构造函数语义
#### 3.1 什么时候会生成移动构造函数/移动赋值函数？
* 没有析构、拷贝构造、拷贝赋值的时候
* 所有成员变量都可以移动。

简单来说，从C++11开始，如果你没有显式定义它们，且类中的所有成员都可以被移动，编译器就会为你生成这两个函数。
反过来说，如果类中有不能被移动的成员（例如，定义了删除的移动构造函数的类型的成员）；或者你已经定义了拷贝构造函数、拷贝赋值运算符或析构函数，编译器就不会生成这两个函数。

#### 3.2 为什么移动的形参是`T&&`？？

#### 3.3 移动的时候如果不将原来的置空会怎样？
在编程中，"移动"通常指的是移动语义，这是C++11引入的一个新特性。移动语义允许资源（如动态分配的内存）从一个对象转移到另一个对象，这样可以避免不必要的临时对象的复制。

如果在移动操作后不将原对象置空，可能会导致一些问题。例如，如果原对象是一个拥有动态分配内存的对象，那么当原对象和新对象都试图释放同一块内存时，就会发生双重删除，这会导致程序崩溃。

因此，通常在执行移动操作后，我们会将原对象置空或设置为一个安全的状态，以防止这种问题的发生。


#### 3.4 为什么移动构造函数一般情况下会比拷贝构造函数快？

#### 3.5 为什么移动的构造赋值用noexcept，但是拷贝的没有？

#### 3.6 为什么拷贝赋值、移动复制要判断this指针不相同？

### 4. 成员初始化列表
#### 4.1 何时需要初始化列表
1. 成员变量是引用类型，引用必须在构造时(初始化时)就需要绑定对象。
2. 成员变量是const
3. 类继承自一个基类，基类中有构造函数，构造函数里还有参数。
4. 类中成员变量的类型是某个类类型，类类型的构造函数有参数。

#### 4.2 初始化列表的优势
- 提升程序运行效率
- 主要是类类型放在初始化列表中效率较高，其他简单类型效率基本一致。
  1. 对于类类型的提升明显，因为生成临时对象再析构开销较大。
  2. 内置类型不明显。
  3. 尽可能使用初始化成员列表。

#### 4.3 初始化列表细节探究
1. 初始化列表中的代码可以看作是编译器安插在构造函数之中的。
2. 初始化列表中的代码是在构造函数的函数体代码执行前被执行的。
3. 初始化列表中成员变量的初始化顺序看的是成员变量在类中定义的顺序，而不是在初始化列表中出现的顺序。
    - 如果有类类型成员类型，在进入函数体前，类类型成员类型就已经被调用默认构造函数生成了。
  - 如果函数体内初始化，则会产生一个临时对象进行拷贝赋值运算符，效率很低。因此最好使用初始化列表进行调用该类类型的构造函数。
  - 当使用初始化列表时，则会直接调用构造函数，提高了效率。
  - 可以把初始化列表理解为函数体内的正常语句。只是在所有的代码前执行。

### 5. 成员函数
#### 5.1 成员函数的调用方式
* 对于非静态成员函数：
    1. **非静态成员函数:C++会保证至少和一般的普通的函数有相同的效率,经过三个步骤的转换**
    - 非静态成员函数是指那些需要通过对象实例来调用的成员函数。
    - C++ 保证非静态成员函数的调用效率至少与普通函数相同。为了实现这一点，编译器会对非静态成员函数进行一些转换。

    2. **改写函数,安插一个额外的参数到该函数中,用来提供一个存取管道------即this指针**
    - 编译器会将非静态成员函数改写为一个普通函数，并插入一个额外的参数，这个参数就是 `this` 指针。
    - `this` 指针指向调用该成员函数的对象实例，提供了对对象成员变量和其他成员函数的访问。

    3. **对每一个非静态成员的存取操作改成使用this指针来调用**
    - 在改写后的函数中，所有对非静态成员变量和成员函数的访问都会通过 `this` 指针来进行。
    - 例如，访问成员变量 `x` 会被改写为 `this->x`。

    4. **将成员函数改写成一个外部函数,并且名称改为独一无二的**
    - 编译器会将成员函数改写为一个外部函数，并为其生成一个独一无二的名称，以避免与其他函数冲突。
    - 这个独一无二的名称通常包含类名和成员函数名。

#### 5.2 虚函数成员函数的调用？？？


### 6. 全局变量

#### 6.1 全局对象的存储位置/地址分配

- **数据段**：全局变量和全局对象存储在数据段中。数据段是程序的一个部分，用于存储静态分配的变量，包括全局变量和静态变量。
- **内存清零**：在不给全局对象初值的情况下，编译器默认会将全局对象所在的内存全部清零。这意味着全局对象的所有成员变量在初始化时都会被设置为零值。
- **编译阶段分配**：全局变量在编译阶段就会分配空间，并且它们的地址在编译期间就确定好了。这意味着全局对象的地址在程序运行期间是固定的，内存也是在编译时分配好的，并且在程序运行期间一直存在。
- **构造**：全局对象的构造在 `main()` 函数之前进行。全局对象存储在数据段中，默认值为零。编译器会在程序开始执行之前调用全局对象的构造函数，确保它们被正确初始化。
- **析构**：全局对象的析构在 `main()` 函数执行完毕之后进行。编译器会在程序结束时调用全局对象的析构函数，确保它们被正确清理，释放资源。

#### 6.2 全局对象的构造和析构步骤

1. **地址分配**：
   - 全局对象 `g_aobj` 的地址在编译时确定，并且内存也是在编译时分配好的。这意味着在程序运行期间，`g_aobj` 的地址是固定的，内存也是预先分配好的。
2. **静态初始化**：
   - 在程序开始执行之前，编译器会将全局对象 `g_aobj` 的内存内容清零。这一步称为静态初始化，确保全局对象的所有成员变量在初始化时都被设置为零值。
3. **调用构造函数**：
   - 在程序的 `main()` 函数执行之前，编译器会调用全局对象 `g_aobj` 所对应的类 `A` 的构造函数。这一步确保全局对象在 `main()` 函数执行之前被正确初始化。
4. **执行 `main()` 函数**：
   - 程序的 `main()` 函数开始执行。在 `main()` 函数中，可以使用全局对象 `g_aobj`，因为它已经被初始化。
5. **调用析构函数**：
   - 在 `main()` 函数执行完毕之后，编译器会调用全局对象 `g_aobj` 所对应类 `A` 的析构函数。这一步确保全局对象在程序结束时被正确清理，释放资源。

#### 6.3 局部静态对象的构造和析构
- **构造**：局部静态对象的构造函数只会在第一次调用包含它的函数时被调用一次。之后再次调用该函数时，不会再次构造该对象。
- **地址**：局部静态对象的内存地址在编译期间就确定好了，每次调用函数时，该对象的地址是相同的。
- **初始化**：局部静态对象在程序开始时会被初始化为零值（如果没有显式初始化）。在第一次调用包含它的函数时，才会调用其构造函数进行初始化。
- **析构**：局部静态对象的析构函数会在 `main()` 函数执行结束后被调用，确保在程序结束时正确释放资源。

### 99. quiz

#### 1. 为什么析构函数要声明 `virtual`?
因为存在多态情况，取到一个父类型指针的时候，其实际类型也许是某一个派生类的。
另外注意，派生类的析构函数是一定会父类析构的。
因此父类的资源由父类管理，子类不需要管理。
> 简单回忆构造析构顺序：父构-子构-子析-父析
> 拷贝的时候也是：父拷--子拷的顺序

#### 2. 如果父类声明了虚析构，那么同样地，拷贝，移动也需要是虚的吗？
不需要。
父类声明虚析构函数是为了确保析构方法被正确调用。对于多态类型来说，析构方法通常会在某个 RAII（资源获取即初始化）管理器中调用，或者在对象自身被销毁时调用。如果此时的类型是基类类型，就无法正确释放派生类的资源。例如，在一个 `std::vector<Animal*>` 的容器中，释放这些资源时，虚析构函数是必要的。

然而，拷贝构造函数和移动构造函数本质上属于构造方法，在构造过程中不能使用虚函数。这是因为，在对象的构造过程中，首先调用基类的构造函数，然后调用派生类的构造函数。在基类的构造函数执行时，派生类的部分尚未构造完成。

如果我们希望编译器支持构造函数调用虚方法，
   - 在父类的构造函数的时候，虚函数指针指向的也是基类虚函数表。
   - 因为子类的虚函数可能依赖子类成员变量，不应该被调用。
   - 出于安全考虑，父虚函数指针只能指向父类方法。
   - 在子类的时候，虚函数指针才能指向子类虚函数表
如此一来，父类走父类方法，子类走子类方法，多态特性无从体现了。
还非常容易出现混淆，因此构造函数不可以调用虚方法。
对于拷贝、移动情况也是类型的。因为也是先完成父类拷贝，才执行子类拷贝。


#### 3. 为什么要声明 `override`?
对于开发人员来说：可以明确意图，提高可读性和维护性；
对于编译器来说：让编译器检查函数签名是否匹配。

虽然使用 `override` 和不使用 `override` 生成的代码是一样的，去掉已有代码中的所有 `override` 关键字也不会改变程序的运行时行为，但为了提高代码的可读性和可维护性，并避免潜在的错误，建议在重写基类虚函数时使用 `override` 关键字。
> 题外话：面对一个新的类型时，主要观察的就是 `public` 方法、`virtual` 方法和 `override` 方法。

#### 4. 成员函数模板可以为虚函数吗？
如果允许存在虚函数模板，那么每次以不同的模板类型调用虚函数模板时，都会生成一个新的虚函数实例。这意味着虚函数表的内容只能在程序链接阶段才能确定，而无法在编译阶段确定。

如果虚函数表的内容只能在链接阶段确定，链接器需要重新解析和调整所有涉及虚函数调用的代码，这会增加链接器的复杂性和工作量。

#### 5. 类的构造、析构出现异常会怎么样？怎么处理？
当构造函数中使用 `new` 操作符分配内存时，如果分配成功，资源会被分配给指针变量。如果在构造函数的某个 `new` 操作之后抛出异常，构造函数会立即退出，且不会调用析构函数，因为对象还没有完全构造出来。
然而，已经成功构造的成员变量会被自动销毁，这意味着它们的析构函数会被调用，从而释放已经分配的资源。
可如果成员变量是堆上的资源，则会出现资源泄露问题。因此最好是使用智能指针去管理。因为智能指针对于这个类来说，是栈上的资源。栈上的资源即使抛出异常也会正常释放。

类的析构函数也是类似的。
类的构造和析构一般是和资源相关的，资源通过智能指针可以保证异常安全的。

#### 6. return this和return *this的区别是什么
`return this` 和 `return *this` 的主要区别在于它们返回的类型:

- `return this` 返回的是一个指向当前对象的指针.这意味着,如果你有一个对象 `obj`,并且你有一个函数 `func` 返回 `this`,那么 `obj.func()` 将返回一个指向 `obj` 的指针.

- `return *this` 一般是`T&`修饰返回搭配使用的。即返回的是当前对象的一个引用.这意味着，如果你有一个对象 `obj`,并且你有一个函数 `func` 返回 `*this`,那么 `obj.func()` 将返回一个引用到 `obj`。

**10. 令operator= 返回一个reference to *this （Have assignment operators return a reference to *this)**

主要是为了支持连读和连写，例如：
    
    class Widget{
    public:
        Widget& operator=(int rhs){return *this;}
    }
    a = b = c;

**11. 在operator= 中处理“自我赋值” （Handle assignment to self in operator=)**

主要是要处理 a[i] = a[j] 或者 *px = *py这样的自我赋值。有可能会出现一场安全性问题，或者在使用之前就销毁了原来的对象

#### 7. 如果我的拷贝被构造函数用`T& other`会怎么样？
简单来说，以拷贝构造函数为例，即使不使用`const T& other`作为形参，而是使用`T& other`也是可以声明拷贝构造函数的。但一般来说，我们需要`override`编译器默认生成的拷贝构造函数，而且`const T& other`会比`T& other`好，因为使用`const T& other`作为参数，可以从任何对象（包括const对象和临时对象）中拷贝。
> 临时对象（也称为右值）是不能绑定到非const的左值引用上的，但可以绑定到const的左值引用上。这是C++语言规则的一部分，主要是为了保护临时对象不被意外修改。


#### 7. 一个类B,它有一个A*类型的成员变量.并写出它的拷贝构造函数.

```cpp
class A {
    // A的定义
};

class B {
public:
    B() : ptr(new A()) {}  // 默认构造函数
    B(const B& other) : ptr(new A(*(other.ptr))) {}  // 拷贝构造函数
    ~B() { delete ptr; }  // 析构函数

private:
    A* ptr;  // A*类型的成员变量
};
```

#### 9. 定义一个static成员变量。该怎么写？

在C++中，你可以在类内部声明一个static成员变量，然后在类外部定义和初始化它。以下是一个例子：

```cpp
class B {
public:
    // 静态成员变量的声明
    static int s_value;
};

// 静态成员变量的定义和初始化
int B::s_value = 0;
```

在这个例子中，`s_value`是类B的一个静态成员变量。所有的B对象都共享同一个`s_value`变量。

好的，以下是对这两个问题的逐点解释：

#### 10. 为什么要声明 `virtual`?

1. **实现多态**
   - `virtual` 关键字用于声明虚函数，允许派生类重写基类中的函数，从而实现多态。
   - 通过基类指针或引用调用虚函数时，会根据实际对象的类型调用相应的派生类函数，而不是基类函数。

2. **确保正确的析构**
   - 当基类的析构函数被声明为虚函数时，通过基类指针删除派生类对象时，会正确调用派生类的析构函数，避免资源泄漏。
   - 示例：
     ```cpp
     class Base {
     public:
         virtual ~Base() {}
     };

     class Derived : public Base {
     public:
         ~Derived() {}
     };

     Base* obj = new Derived();
     delete obj; // 正确调用 Derived 和 Base 的析构函数
     ```

3. **动态绑定**
   - `virtual` 关键字使得函数调用在运行时进行动态绑定，而不是在编译时进行静态绑定。
   - 这允许程序在运行时决定调用哪个函数，实现更灵活的设计。

4. **接口设计**
   - 在设计接口或抽象基类时，通常将函数声明为虚函数，以便派生类提供具体实现。
   - 示例：
     ```cpp
     class Shape {
     public:
         virtual void draw() = 0; // 纯虚函数，必须在派生类中实现
     };

     class Circle : public Shape {
     public:
         void draw() override {
             // Circle 的具体实现
         }
     };
     ```

#### 11. 如果父类声明了虚析构，那么拷贝，移动也需要是虚的吗？
不需要。

#### 12. 为什么要声明 `override`?

1. **明确意图**
   - `override` 关键字明确表示派生类中的函数是重写基类中的虚函数。
   - 这有助于代码的可读性和可维护性，使得代码意图更加清晰。
   - `override` 关键字本身不会改变程序的运行时行为，它的主要作用是提升代码的可读性和可维护性，并且提供编译器检查功能。
    以下是详细解释：

2. **编译器检查**
   - 使用 `override` 关键字可以让编译器检查函数签名是否正确匹配基类中的虚函数。
   - 如果函数签名不匹配，编译器会报错，避免潜在的错误。
   - 示例：
     ```cpp
     class Base {
     public:
         virtual void func(int) {}
     };

     class Derived : public Base {
     public:
         void func(int) override { // 正确匹配基类函数
             // Derived 的具体实现
         }
     };
     ```

3. **防止意外重载**
   - 如果派生类中的函数签名与基类中的虚函数不匹配，编译器会将其视为新的函数，而不是重写基类函数。
   - 使用 `override` 可以防止这种意外重载的情况。
   - 示例：
     ```cpp
     class Base {
     public:
         virtual void func(int) {}
     };

     class Derived : public Base {
     public:
         void func(double) override { // 编译错误，签名不匹配
             // Derived 的具体实现
         }
     };
     ```

4. **提高代码质量**
   - 使用 `override` 关键字可以提高代码质量，减少错误，提高代码的健壮性和可维护性。


#### 13. 成员函数模板可以为虚函数吗？
成员函数模板不能为虚函数，因为虚函数表的大小是固定的，而成员函数模板的实例化个数要编译完成后才能确定

* 虚函数可以是模板的吗？

不，虚函数不能是模板函数。虚函数依赖于虚函数表（vtable）来实现运行时多态，而模板函数在编译时根据模板参数的不同实例化为不同的函数。因为模板实例化发生在编译时，而虚函数的动态绑定发生在运行时，所以二者的机制不兼容。

简而言之，虚函数的多态性是在运行时通过虚函数表解析的，而模板函数的多态性是在编译时通过生成不同的函数实例来实现的。因此，虚函数不能是模板函数。


#### 14. 类的构造出现异常会怎么样？怎么处理？
构造函数中的异常处理：

当构造函数中使用 new 操作符分配内存时，如果分配成功，资源会被分配给指针变量。
如果在构造函数的某个 new 操作之后抛出异常，构造函数会立即退出，且不会调用析构函数，因为对象还没有完全构造出来。
但是，已经成功构造的成员变量会被自动销毁，这意味着它们的析构函数会被调用，从而释放已经分配的资源。
智能指针的作用：

使用智能指针（如 std::unique_ptr）可以确保资源在异常发生时自动释放。智能指针在其析构函数中会自动释放所管理的资源，即使在异常情况下也不例外。

#### 15. 类的析构出现异常会怎么样？怎么处理


#### 16. 继承的析构函数一般要怎么处理？继承的特殊成员函数怎么处理？
如果有基类，这个类的析构函数一般就得是虚的。
对于默认构造函数（无参构造）不管是override还是使用默认的，派生类都会自动调用父类的构造方法，不需要额外操作。
但是如果是有参的构造方法，基类不会知道要传入什么参数，因此都得手动调用父类的构造方法。
很多时候会出现的情况是，父类同时支持默认构造和有参构造，派生类使用有参构造的时候，没有显式调用父类的构造方法，因此默认走的是父类的无参构造。
注意，为了避免重复调用父类的构造方法，必须是通过初始化列表去调用。

而对于拷贝构造、拷贝赋值、移动构造、移动赋值而言，也是一样首先在初始化列表调用父类的方法，再实现派生类逻辑。
注意，对于移动来说，不需要担心资源安全问题。因为初始化列表，看上去是`std::move(other)`整个对象都被移动走了，但是父类只会处理父类资源，子类资源还是可以放心继续使用。可以说初始化列表的move只是部分移动，因此派生类继续使用other对象完成子类资源的移动是安全的。

总结如下：
* 基类的析构函数应声明为虚函数，以确保正确调用派生类的析构函数。
* 派生类的构造函数应显式调用基类的构造函数，尤其是带参数的构造函数。
* 派生类的复制构造函数、复制赋值运算符、移动构造函数和移动赋值运算符应显式调用基类的相应函数，以确保基类部分正确复制或移动。

---
二/构造函数语意学
2.1 默认构造函数的构造操作
以下四种情况下,会合成有用的构造函数:
带有默认构造函数的成员函数对象,不过这个合成操作只有在构造函数真正需要被调用时才发生,但只是调用其成员的默认构造函数,其他则不会初始化
如果一个派生类的父类带有默认构造函数,那么子类如果没有定义构造函数,则会合成默认构造函数,如果有的话但是没有调用父类的,则编译器会插入一些代码调用父类的默认构造函数
带有一个虚函数的类
类声明(或继承)一个虚函数
类派生自一个继承串链,其中有一个或更多的虚基类

3/Data语意学

3.2 数据成员的布局

3.4 继承下的数据成员
在下面给定的两个类中依次讨论不同情况:

在单一继承没有虚函数的情况下布局图

这种情况下常见错误:
可能会重复设计一些操作相同的函数,我们可以把某些函数写成inline,这样就可以在子类中调用父类的某些函数来实现简化
把数据放在同一个类中和继承起来的内存布局可能不同,因为每个类需要内存对齐

叠在一起的内存布局


可见内存大了100%
容易出现的不易发现的问题:

当加上多态之后,对空间上增加的额外负担包括:
导入一个虚函数表,表中的个数是声明的虚函数的个数加上一个或两个slots(用来支持运行类型识别)
在每个对象中加入vptr,提供执行期的链接,使每一个类能找到相应的虚函数表
加强构造函数,使它能够为vptr设定初值,让它指向对应的虚函数表,这可能意味着在派生类和每一个基类的构造函数中,重新设定vptr的值
加强析构函数,使它能够消抹"指向类的相关虚函数表"的vptr,vptr很可能以及在子类析构函数中被设定为子类的虚表地址.
析构函数的调用顺序是反向的,从子类到父类


**以下是三种情况:**不同的继承下会有不同的布局


多重继承
**单一继承特点:**派生类和父类对象都是从相同的地址开始,区别只是派生类比较大能容纳自己的非静态成员变量
多重继承下会比较复杂

一个派生对象,把它的地址指定给最左边的基类,和单一继承一样,因为起始地址是一样的,但是后面的需要更改,因为需要加上前面基类的大小,才能得到后面基类的地址

虚继承
STL标准库中使用的虚继承:

虚继承关系:

虚继数据在内存中的分布


四/Function 语意学

虚函数成员函数:也会经过类似的转化
例如: ptr->normalize()会被转化为
( * ptr->vptr[1] )( ptr )
vptr是编译器产生的指针,指向虚函数表,其名称也会被改为独一无二
1 是该函数在虚函数表中的索引
ptr 则是this指针
静态成员函数:它没有this指针,因此会有以下限制:
它不能直接存取类中的非成员变量
它不能够被声明为const/volatile 和 virtual
它不需要经过类的对象才能被调用----虽然很多事情况是这样调用的

4.2 详解虚成员函数
虚函数一般实现模型:每一个类都有一个虚函数表,内含该类中有作用的虚函数地址,然后每个对象有一个虚函数指针,指向虚表位置
多态含义:以一个基类的指针(或引用),寻址出一个子类对象
什么是积极多态?
当被指出的对象真正使用时,多态就变成积极的了
单一继承虚函数布局图

一个类派生自Point会发生什么事? 三种可能的情况
它可以继承基类所声明的虚函数的函数实例,该函数实例的地址会被拷贝进子类的虚表的相对应的slot之中
它可以使用自己的虚函数实例----它自己的函数实例地址必须放在对应的slot之中
它可以加入一个新的虚函数,这时候虚函数表的尺寸会增加一个slot,而新加入的函数实例地址也会被放进该slot之中


多重继承下的虚函数

虚拟继承下的虚函数

4.4指向成员函数的指针
对于普通的成员函数,编译器会将其转化为一个函数指针,然后使用成员函数的地址去初始化
例如 double (Point :: *pmf ) ( );
转化为double ( Point :: coord )( ) = &Point :: x;
这样调用(coord) (& origin)或 (coord)(ptr)


对一个虚函数取地址,在vc编译器下,要么得到vacll thunk地址(虚函数时候),要么得到的是函数地址(普通函数)
4.5 内联函数


对于局部变量,会采用:
使用临时变量
五/构造/析构/拷贝语意学
应注意的一些问题:
构造函数不要写为纯虚函数,因为当抽象类中有数据的时候,将无法初始化
把所有函数设计成虚函数,再由编译器去除虚函数是错误的,不应该成为虚函数的函数不要设计成虚函数
当你无法抉择一个函数是否需要为const时,尤其是抽象类,最好不设置成const
5.1 "无继承" 情况下的对象构造
对于没有初始化的全局变量,C语言中会将其放在一个未初始化全局区,而C++会将所有全局对象初始化
对于不需要构造函数/析构函数/赋值操作的类或结构体,C++会将其打上POD标签,赋值时按照c那样的位搬运
对于含有虚函数的类,编译器会在构造函数的开始放入一些初始化虚表和虚指针的操作
面对函数以值方式返回,编译器会将其优化为加入一个参数的引用方式,避免多次构造函数
5.2 继承体系下的对象构造
构造函数会含有大量的隐藏嘛,因为编译器会进行扩充:
记录在成员初始化列表中的成员数据初始化会被放进构造函数的本体,并以成员在类中声明的顺序为顺序
如果有一个成员并没有出现在成员初始化列表中,但是它由一个默认构造函数,那么也会被调用
在那之前,如果类对象由虚表指针,它必须被设定初值,指向适当的虚表
在那之前,所有上一层的基类构造函数必须被调用,以基类声明的顺序(不是成员初始化列表出现的顺序)
如果基类被列于成员初始化列表中,那么任何显式指定的参数应该传递过去
如果基类没有被列于基类初始化列表中,而它有默认的构造函数,那么就调用
如果基类是多重继承下的第二个或后继的基类,那么this指针必须有所调整


在那之前,所有虚基类构造函数必须被调用,从左到右,从最深到最浅
如果类被列于成员初始化列表中,那么如果有任何显式指定的参数,都应该传递过去.若没有列于list中,而类中有一个默认构造,亦应该调用
此外,类中的每一个虚基类的偏移位置必须在执行期可被存取
如果类对象是最底层的类,其构造函数可能被调用,某些用以支持这一行为的机制必须被放进来
不要忘记在赋值函数中,检查自我赋值的情况
5.3 对象复制语意学
当一个类复制给另一个类时,能采用的有三种方式:
什么都不做,会实施默认行为
如果有需要,会自动生成一个浅拷贝,至于什么时候需要深拷贝(见第二章讲)


提供一个拷贝复制运算符
显式地拒绝把一个类拷贝给另一个
虚基类会使其复制操作调用一次以上,因此我们应该避免在徐杰类中声明数据成员
5.5 析构语意学
什么时候会合成析构函数?
在类内含的成员函数有析构函数
基类含有析构函数


析构的正确顺序:
析构函数的本体首先被执行,vptr会在程序员的代码执行前被重设.
如果类拥有成员类对象,而后者拥有析构函数,那么他们会以其声明顺序的相反顺序被调用
如果类内涵一个vptr,现在被重新设定,指向适当的积累的虚表
如果有任何直接的非虚基类拥有析构函数,它们会以其声明顺序的相反顺序被调用
如果有任何虚基类拥有析构函数,而且目前讨论的这个类是最尾端的类,那么它们会以其原来的构造顺序的相反顺序被调用
六/执行期语意学
C++难以从程序源码看出表达式的复杂过程,因为你并不知道编译器会在其中添加多少代码
编译器对不同的对象会做不同的操作:
对于全局对象:编译器会在添加__main函数和_exit函数(和C库中的不同),并且在这两个函数中对所有全局对象进行静态初始化和析构

使用被静态初始化的对象,有一些缺点:
如果异常处理被支持,那么那些对象将不能被放置到try区段之内
增加了程序的复杂度


因此,不建议用那些需要静态初始化的全局对象
对于局部静态对象:
会增加临时的对象用来判断其是否被构造,用来保证在第一次进入含有该静态对象的起始处调用一次构造函数,并且在离开文件的时候利用临时对象判断是否已经被构造来决定是否析构
对于对象数组:(例如Point knots[10])
如果对象没有定义构造函数和析构函数,那么编译器只需要分配需要存储10个连续空间即可
如果有构造函数,且如果有名字,则会分为是否含有虚基类调用不同的函数来构造,如果没有名字,例如没有knots,则会使用new来分配在堆中
当声明结束时会有类似构造的析构过程
我们无法在程序中取出一个构造函数的地址
6.2 new 和 delete 运算符
对于普通类型变量:
例如 int *pi = new int(5)
调用函数库中的new运算符if(int *pi = _new (sizeof(int) ))
再配置初值 *pi = 5


对于delete来说 delete pi;
则先进行保护 if( pi != 0)
再调用delete _delete(pi)
对于成员对象:
对于Point3d* origin = new Point3d
实际调用operator new,其代码如下
extern void* operator new (size_t size){
if(size == 0)
size = 1;
void * last_alloc;
while(!(last_alloc = malloc(size))){
if(_new_handler)
( *_new_handler)();
else
return 0;
}
return last_alloc;
}

语言要求每一次对new的调用都必须传回一个独一无二的指针,为了解决这个问题,传回一个指向默认为1Byte的内存区块,允许程序员自己定义_new_handler函数,并且循环调用
至于delete也相同
extern void operator delete (void *ptr){
if(ptr)
free( (char*)ptr)
}

对于对象数组,会在分配的内存上方放上cookies,来存储数组个数,方便delete调用来析构
程序员最好避免以一个基类指向一个子类所组成的数组---如果子类对象比其基类大的话
解决方式:
for(int ix = 0; ix < elem_count; ++ix){
Point3d *p = &((Point3d*)ptr)[ix];
delete p;
}

程序员必须迭代走过整个数组,把delete运算符实施与每一个元素身上.以此方式,调用操作将是virtual.因此,Point3d和Point的析构函数都会实施与每一个对象上


Placement Operator new的语意
有一个预先定义好的重载的new运算符,称为placement operator new.它需要第二个参数,类型为void*
形如 Point2w *ptw = new (arena) Point2w,其中arena指向内存中的一个区块,用以放置新产生出来的Point2w 对象
void* operator new(size_t , void* p){
return p;
}

如果我们在已有对象的基础上调用placement new的话,原来的析构函数并不会被调用,而是直接删除原来的指针,但是不能使用delete 原来的指针
正确的方法应该是 :
//错误:
delete p2w;
p2w = new(arwna) Point2w;
//正确:
p2w->Point2w;
p2w = new(arena) Point2w;

6.3 临时性对象
临时对象在类的表达式并赋值,函数以值方式传参等都会产生临时对象-----而临时对象会构造和析构,所以会拖慢程序的效率,我们应该尽量避免
七/站在对象模型的顶端
三个著名的C++语言扩充性质:模板/异常(EH)/RTTI(runtime type identification)

7.1 Template

即使是静态类型的变量,也需要与具体的实例版本关联,不同版本有不同的一份
如果声明一个模板类的指针,那么不会进行实例化,但是如果是引用,那么会进行实例化
对于模板类中的成员函数,只有在函数使用的时候才会进行实例化

模板名称决议的方法-----即如果非成员函数在类中调用,那么会调用名称相同的哪个版本:
会根据该函数是否与模板有关来判断,如果是已知类型,那么会在定义的范围内直接查找,如果以来模板的具体类型,那么会在实例化的范围查找

7.2 异常处理
C++异常处理由三个主要的语汇组件:
一个throw子语.它在程序某处发出一个exception,exception可以说内建类型也可以是自定义类型
一个或多个catch子句.每一个catch子句都是一个exceotion hander,它用来表示说,这个子句准备处理某种类型exception,并且在封闭的大括号区段中提供实际的处理程序
一个try区段.它被围绕一系列的叙述句,这些叙述句可能会引发catch子句起作用


如果都没有吻合者,那么默认的处理例程 terminate()会被调用,当控制权被放弃后,堆栈中的每一个函数调用也就被推离.这个程序被称为 unwingding the stack .
因此一个解决办法就是将类封装在一个类中,这样变成局部类,如果抛出异常也会被自动析构
当一个异常抛出,编译系统必须:
1. 检查发生throw操作的函数
2. 决定throw操作是否发生在try区段
3. 若是,编译系统必须把异常类型拿来和每一个catch子句进行比较
4. 如果比较后吻合,流程控制应该交到catch子句中
5. 如果throw的发生并不在try区段中,或没有一个catch子句吻合,那么系统必须:
    * 摧毁所有活跃局部类
    * 从堆栈中将目前的函数(unwind)释放掉
进行到程序堆栈的下一个函数中去,然后重复上述步骤2_5


7.3 执行期类型识别
当两个类有继承关系的时候,我们有转换需求时,可以进行向下转型,但是很多时候是不安全的
C++的RTTI (执行期类型识别)提供了一个安全的向下转型设备,但是只对多态(继承和动态绑定)的类型有效,其用来支持RTTI的策略就是,在C++的虚函数表的第一个slot处,放一个指针,指向保存该类的一些信息----即type_info类(在编译器文件中可以找到其定义)
dynamic_cast运算符可以在执行期决定真正的类型
对于指针来说:
如果转型成功,则会返回一个转换后的指针
如果是不安全的,会传回0
放在程序中通过 if 来判断是否成功,采取不同措施
对于引用来说:
如果引用真正转换到适当的子类,则可以继续
如果不能转换的化,会抛出 bad_cast 异常
通常使用 try 和 catch 来进行判断是否成功


Typeid运算符:
可以传入一个引用,typeid运算符会传回一个const reference,类型为type_info.其内部已经重载了 == 运算符,可以直接判断两个是否相等,回传一个bool值
例如 if( typeid( rt ) == typeid( fct ) )
RTTI虽然只适用于多态类,但是事实上type_info object也适用于内建类,以及非多态的使用者自定类型,只不过内建类型 得到的type_info类是静态取得,而不是执行期取得



**25. 使构造函数和非成员函数具有虚函数的行为**
```c++
    class NewsLetter{
    private:
        static NLComponent *readComponent(istream& str);
        virtual NLComponent *clone() const = 0;
    };
    NewsLetter::NewsLetter(istream& str){
        while(str){
            components.push_back(readComponent(str));
        }
    }
    class TextBlock: public NLComponent{
    public:
        virtual TextBlock*clone()const{
            return new TextBlock(*this);
        }
    }
```
在上面那段代码当中，readComponent就是一个具有构造函数行为（因为能够创建出新的对象）的函数，我们叫做虚拟构造函数

clone() 叫做虚拟拷贝构造函数,相当于拷贝一个新的对象

通过这种方法，我们上面的NewsLetter构造函数就可以这样：
```c++
    NewsLetter::NewsLetter(const NewsLetter& rhs){
        while(str){
            for(list<NLComponent*>::const_iterator it=rhs.component.begin(); it!=rhs.component.end();it++){
                components.push_back((*it)->clone());
            }
        }
    }
```
这样每一个TextBlock都可以调用他自己的clone，其他的子类也可以调用他们自己对应的clone()
