## 严格别名

### 1. concepts
严格别名规则（strict aliasing rules）优化通过假设不同类型的指针不会指向相同的内存位置，从而允许编译器进行更激进的优化。这种假设使得编译器可以安全地认为某些内存访问不会相互干扰，从而进行一系列优化操作。

```c++
int void (Foo* ptr1, Bar* ptr2){
    // register1: ptr1,
    // register2: ptr2,
    // register3: ptr1Value,
    // register4: ptr2Value,
}
```
比如说在上面这个例子中，编译器会默认不同类型的指针不会指向同一个内存地址，因此有可能把`ptr1Value`和`ptr2Value`写在寄存器中，而不是立马写回到内存地址。如果这两个指针实际上是同一个地址的时候就很有可能会出现问题了，特别是两个操作都是自增处理的时候，就会变成实际上只进行了一次自增。

上面这个例子是体现了开启严格别名规则时候，减少内存访问次数这个优化。
上面这个例子对于L1和L2缓存也同样使用。
寄存器不大，一般也就十几个寄存器，一个寄存器一个指针长度大小。
L1缓存可以到64kb，L2缓存可以到1mb。
对于一个对象的值存在缓存里面是很常见的。

除此之外，编译器执行命令的时候大都是乱序的，明确不会是同一个内存地址，有利于执行一些乱序操作。

还有利于常量传播。

#### 1.2 什么是类型双关？
类型双关（Type Punning）是指在编程中通过不同类型的指针或引用访问相同的内存位置。这种做法通常用于在低级别操作中重新解释数据的类型。

如果是底层编程的时候，经常有指针强转需要的时候常会出现类型双关，或者`union`的时候。
```c++
union Data {
    int i;
    float f;
} data;
```
像这个例子中`data.i`和`data.f`就是同一个内存地址，访问`.i`还是`.f`只是决定用什么类型而已。

#### 1.3 题外话
o2级别开始的优化就是会开启严禁别名优化，即认为不同类型的指针不会是同一个地址，并基于这个假设，去做优化。
linux底层代码中似乎有很多类型双关的代码，因此linux内核实际上是关闭了`-fno-strict-aliasing`这一个优化的。
开启了这一个优化的时候，编译器也会有别名优化警告的，只是不一定能够检测出所有情况。

#### 1.4 禁止别名优化的影响
```c++
int func1() { // may-alias
    struct {
        int a;
        int b = 42;
    } s;
    outer(&s.a);
    return s.b;
}

int func2() { // may-alias
    union {
        int a;
        int b = 42;
    } u;
    outer(&u.a);
    return u.b;
}

int func3() { // may-alias
    int a[2];
    a[1] = 42;
    outer(&a[0]);
    return a[1];
}

int func4(int *pa, int *pb) { // may-alias
    *pb = 42;
    *pa = 37;
    return *pb;
}

```

这些例子中，*pb都不会直接跳过函数体内的无用操作，而是逐步执行，因为此操作相邻指针的时候，有可能会影响到当前指针，从而出现ub问题。
比如说func1中，操作s.a的时候，难保不会影响到s.b，因此编译器都会执行。
