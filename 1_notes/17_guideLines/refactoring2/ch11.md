# 第 11 章 重构 API

在函数间传递时，数据结构常会毫无必要地被拆开，我更愿意用保持对象完整（319）将其聚拢。
函数需要的一份信息，究竟何时应该作为参数传入、何时应该调用一个函数获得，这是一个需要反复推敲的决定，推敲的过程中常常要用到以查询取代参数（324）和以参数取代查询（327）。

有时你会遇到一个特别复杂的函数，围绕着它传入传出一大堆数据。
最后两个重构手法专门用于破解这个难题。我可以用以命令取代函数（337）将这个函数变成对象，这样对函数体使用提炼函数（106）时会更容易。如果稍后我对该函数做了简化，不再需要将其作为命令对象了，可以用以函数取代命令（344）再把它变回函数。

## 11.1 将查询函数和修改函数分离（Separate Query from Modifier）

```js
function getTotalOutstandingAndSendBill() {
  const result = customer.invoices.reduce((total, each) => each.amount + total, 0);
  sendBill();
  return result;
}


function totalOutstanding() {
  return customer.invoices.reduce((total, each) => each.amount + total, 0);
}
function sendBill() {
  emailGateway.send(formatBill(customer));
}
```

## 11.2 函数参数化（Parameterize Function）

曾用名：令函数携带参数（Parameterize Method）

```js
function tenPercentRaise(aPerson) {
  aPerson.salary = aPerson.salary.multiply(1.1);
}
function fivePercentRaise(aPerson) {
  aPerson.salary = aPerson.salary.multiply(1.05);
}

function raise(aPerson, factor) {
  aPerson.salary = aPerson.salary.multiply(1 + factor);
}
```

## 11.3 移除标记参数（Remove Flag Argument）

曾用名：以明确函数取代参数（Replace Parameter with Explicit Methods）

```js
function setDimension(name, value) {
  if (name === "height") {
    this._height = value;
    return;
  }
  if (name === "width") {
    this._width = value;
    return;
  }
}

function setHeight(value) {
  this._height = value;
}
function setWidth(value) {
  this._width = value;
}
```

### 动机

如果一个函数有多个标记参数，可能就不得不将其保留，否则我就得针对各个参数的各种取值的所有组合情况提供明确函数。
不过这也是一个信号，说明这个函数可能做得太多，应该考虑是否能用更简单的函数来组合出完整的逻辑。

### 做法

针对参数的每一种可能值，新建一个明确函数。

如果主函数有清晰的条件分发逻辑，可以用分解条件表达式（260）创建明确函数；否则，可以在原函数之上创建包装函数。

对于“用字面量值作为参数”的函数调用者，将其改为调用新建的明确函数。

## 11.4 保持对象完整（Preserve Whole Object）

```js
const low = aRoom.daysTempRange.low;
const high = aRoom.daysTempRange.high;
if (aPlan.withinRange(low, high))


if (aPlan.withinRange(aRoom.daysTempRange))
```

### 动机

从一个对象中抽取出几个值，单独对这几个值做某些逻辑操作，这是一种代码坏味道（依恋情结），通常标志着这段逻辑应该被搬移到对象中。保持对象完整经常发生在引入参数对象（140）之后，我会搜寻使用原来的数据泥团的代码，代之以使用新的对象。

如果几处代码都在使用对象的一部分功能，可能意味着应该用提炼类（182）把这一部分功能单独提炼出来。

还有一种常被忽视的情况：调用者将自己的若干数据作为参数，传递给被调用函数。这种情况下，我可以将调用者的自我引用（在 JavaScript 中就是 this）作为参数，直接传递给目标函数。

## 11.5 以查询取代参数（Replace Parameter with Query）

曾用名：以函数取代参数（Replace Parameter with Method）

反向重构：以参数取代查询（327）

## 11.6 以参数取代查询（Replace Query with Parameter）

反向重构：以查询取代参数（324）

```js
  targetTemperature(aPlan)

function targetTemperature(aPlan) {
  currentTemperature = thermostat.currentTemperature;
  // rest of function...


  targetTemperature(aPlan, thermostat.currentTemperature)

function targetTemperature(aPlan, currentTemperature) {
  // rest of function...
```

### 动机

在浏览函数实现时，我有时会发现一些令人不快的引用关系，例如，引用一个全局变量，或者引用另一个我想要移除的元素。为了解决这些令人不快的引用，我需要将其替换为函数参数，从而将处理引用关系的责任转交给函数的调用者。

需要使用本重构的情况大多源于我想要改变代码的依赖关系——为了让目标函数不再依赖于某个元素，我把这个元素的值以参数形式传递给该函数。这里需要注意权衡：如果把所有依赖关系都变成参数，会导致参数列表冗长重复；如果作用域之间的共享太多，又会导致函数间依赖过度。我一向不善于微妙的权衡，所以“能够可靠地改变决定”就显得尤为重要，这样随着我的理解加深，程序也能从中受益。

如果一个函数用同样的参数调用总是给出同样的结果，我们就说这个函数具有“引用透明性”（referential transparency），这样的函数理解起来更容易。如果一个函数使用了另一个元素，而后者不具引用透明性，那么包含该元素的函数也就失去了引用透明性。只要把“不具引用透明性的元素”变成参数传入，函数就能重获引用透明性。虽然这样就把责任转移给了函数的调用者，但是具有引用透明性的模块能带来很多益处。有一个常见的模式：在负责逻辑处理的模块中只有纯函数，其外再包裹处理 I/O 和其他可变元素的逻辑代码。借助以参数取代查询，我可以提纯程序的某些组成部分，使其更容易测试、更容易理解。

不过以参数取代查询并非只有好处。把查询变成参数以后，就迫使调用者必须弄清如何提供正确的参数值，这会增加函数调用者的复杂度，而我在设计接口时通常更愿意让接口的消费者更容易使用。归根到底，这是关于程序中责任分配的问题，而这方面的决策既不容易，也不会一劳永逸——这就是我需要非常熟悉本重构（及其反向重构）的原因。

### 做法

对执行查询操作的代码使用提炼变量（119），将其从函数体中分离出来。

现在函数体代码已经不再执行查询操作（而是使用前一步提炼出的变量），对这部分代码使用提炼函数（106）。

给提炼出的新函数起一个容易搜索的名字，以便稍后改名。

使用内联变量（123），消除刚才提炼出来的变量。

对原来的函数使用内联函数（115）。

对新函数改名，改回原来函数的名字。

### 范例

我们想象一个简单却又烦人的温度控制系统。用户可以从一个温控终端（thermostat）指定温度，但指定的目标温度必须在温度控制计划（heating plan）允许的范围内。

#### class HeatingPlan...

```js
get targetTemperature() {
  if (thermostat.selectedTemperature > this._max) return this._max;
  else if (thermostat.selectedTemperature < this._min) return this._min;
  else return thermostat.selectedTemperature;
}
```

#### 调用方...

```js
if (thePlan.targetTemperature > thermostat.currentTemperature) setToHeat();
else if (thePlan.targetTemperature<thermostat.currentTemperature)setToCool();
else setOff();
```

系统的温控计划规则抑制了我的要求，作为这样一个系统的用户，我可能会感到很烦恼。不过作为程序员，我更担心的是 targetTemperature 函数依赖于全局的 thermostat 对象。我可以把需要这个对象提供的信息作为参数传入，从而打破对该对象的依赖。

首先，我要用提炼变量（119）把“希望作为参数传入的信息”提炼出来。

#### class HeatingPlan...

```js
get targetTemperature() {
 const selectedTemperature = thermostat.selectedTemperature;
 if      (selectedTemperature > this._max) return this._max;
 else if (selectedTemperature < this._min) return this._min;
 else return selectedTemperature;
}
```

这样可以比较容易地用提炼函数（106）把整个函数体提炼出来，只剩“计算参数值”的逻辑还在原地。

#### class HeatingPlan...

```js
get targetTemperature() {
 const selectedTemperature = thermostat.selectedTemperature;
 return this.xxNEWtargetTemperature(selectedTemperature);
}

xxNEWtargetTemperature(selectedTemperature) {
 if      (selectedTemperature > this._max) return this._max;
 else if (selectedTemperature < this._min) return this._min;
 else return selectedTemperature;
}
```

然后把刚才提炼出来的变量内联回去，于是旧函数就只剩一个简单的调用。

#### class HeatingPlan...

```js
get targetTemperature() {
  return this.xxNEWtargetTemperature(thermostat.selectedTemperature);
}
```

现在可以对其使用内联函数（115）。

#### 调用方...

```js
if (thePlan.xxNEWtargetTemperature(thermostat.selectedTemperature) >
   thermostat.currentTemperature)
 setToHeat();
else if (thePlan.xxNEWtargetTemperature(thermostat.selectedTemperature) <
     thermostat.currentTemperature)
 setToCool();
else
 setOff();
```

再把新函数改名，用回旧函数的名字。得益于之前给它起了一个容易搜索的名字，现在只要把前缀去掉就行。

#### 调用方...

```js
if (thePlan.targetTemperature(thermostat.selectedTemperature) >
   thermostat.currentTemperature)
 setToHeat();
else if (thePlan.targetTemperature(thermostat.selectedTemperature) <
     thermostat.currentTemperature)
 setToCool();
else
 setOff();
```

#### class HeatingPlan...

```js
targetTemperature(selectedTemperature) {
 if (selectedTemperature > this._max) return this._max;
 else if (selectedTemperature < this._min) return this._min;
 else return selectedTemperature;
}
```

调用方的代码看起来比重构之前更笨重了，这是使用本重构手法的常见情况。将一个依赖关系从一个模块中移出，就意味着将处理这个依赖关系的责任推回给调用者。这是为了降低耦合度而付出的代价。

但是，去除对 thermostat 对象的耦合，并不是本重构带来的唯一收益。HeatingPlan 类本身是不可变的——字段的值都在构造函数中设置，任何函数都不会修改它们。（不用费心去查看整个类的代码，相信我就好。）在不可变的 HeatingPlan 基础上，把对 thermostat 的依赖移出函数体之后，我又使 targetTemperature 函数具备了引用透明性。从此以后，只要在同一个 HeatingPlan 对象上用同样的参数调用 targetTemperature 函数，我会始终得到同样的结果。如果 HeatingPlan 的所有函数都具有引用透明性，这个类会更容易测试，其行为也更容易理解。

JavaScript 的类模型有一个问题：无法强制要求类的不可变性——始终有办法修改对象的内部数据。尽管如此，在编写一个类的时候明确说明并鼓励不可变性，通常也就足够了。尽量让类保持不可变通常是一个好的策略，以参数取代查询则是达成这一策略的利器。

## 11.7 移除设值函数（Remove Setting Method）

## 11.8 以工厂函数取代构造函数（Replace Constructor with Factory Function）


## 11.9 以命令取代函数（Replace Function with Command）

曾用名：以函数对象取代函数（Replace Method with Method Object）

反向重构：以函数取代命令（344）

```js
function score(candidate, medicalExam, scoringGuide) {
  let result = 0;
  let healthLevel = 0;
  // long body code
}

class Scorer {
  constructor(candidate, medicalExam, scoringGuide) {
    this._candidate = candidate;
    this._medicalExam = medicalExam;
    this._scoringGuide = scoringGuide;
  }

  execute() {
    this._result = 0;
    this._healthLevel = 0;
    // long body code
  }
}
```

### 动机

函数，不管是独立函数，还是以方法（method）形式附着在对象上的函数，是程序设计的基本构造块。不过，将函数封装成自己的对象，有时也是一种有用的办法。这样的对象我称之为“命令对象”（command object），或者简称“命令”（command）。这种对象大多只服务于单一函数，获得对该函数的请求，执行该函数，就是这种对象存在的意义。

与普通的函数相比，命令对象提供了更大的控制灵活性和更强的表达能力。除了函数调用本身，命令对象还可以支持附加的操作，例如撤销操作。我可以通过命令对象提供的方法来设值命令的参数值，从而支持更丰富的生命周期管理能力。我可以借助继承和钩子对函数行为加以定制。如果我所使用的编程语言支持对象但不支持函数作为一等公民，通过命令对象就可以给函数提供大部分相当于一等公民的能力。同样，即便编程语言本身并不支持嵌套函数，我也可以借助命令对象的方法和字段把复杂的函数拆解开，而且在测试和调试过程中可以直接调用这些方法。

所有这些都是使用命令对象的好理由，所以我要做好准备，一旦有需要，就能把函数重构成命令。不过我们不能忘记，命令对象的灵活性也是以复杂性作为代价的。所以，如果要在作为一等公民的函数和命令对象之间做个选择，95%的时候我都会选函数。只有当我特别需要命令对象提供的某种能力而普通的函数无法提供这种能力时，我才会考虑使用命令对象。

跟软件开发中的很多词汇一样，“命令”这个词承载了太多含义。在这里，“命令”是指一个对象，其中封装了一个函数调用请求。这是遵循《设计模式》[gof]一书中的命令模式（command pattern）。在这个意义上，使用“命令”一词时，我会先用完整的“命令对象”一词设定上下文，然后视情况使用简略的“命令”一词。在命令与查询分离原则（command-query separation principle）中也用到了“命令”一词，此时“命令”是一个对象所拥有的函数，调用该函数可以改变对象可观察的状态。我尽量避免使用这个意义上的“命令”一词，而更愿意称其为“修改函数”（modifier）或者“改变函数”（mutator）。

### 做法

为想要包装的函数创建一个空的类，根据该函数的名字为其命名。

使用搬移函数（198）把函数移到空的类里。

保持原来的函数作为转发函数，至少保留到重构结束之前才删除。

遵循编程语言的命名规范来给命令对象起名。如果没有合适的命名规范，就给命令对象中负责实际执行命令的函数起一个通用的名字，例如“execute”或者“call”。

可以考虑给每个参数创建一个字段，并在构造函数中添加对应的参数。

### 范例

在不具备这种能力的编程语言中，我经常要费力为很常见的任务创建命令对象，JavaScript 则省去了这些麻烦。不过，即便在 JavaScript 中，有时也需要用到命令对象。

一个典型的应用场景就是拆解复杂的函数，以便我理解和修改。要想真正展示这个重构手法的价值，
我需要一个长而复杂的函数，但这写起来太费事，你读起来也麻烦。所以我在这里展示的函数其实很短，并不真的需要本重构手法，还望读者权且包涵。下面的函数用于给一份保险申请评分。

```js
function score(candidate, medicalExam, scoringGuide) {
  let result = 0;
  let healthLevel = 0;
  let highMedicalRiskFlag = false;

  if (medicalExam.isSmoker) {
    healthLevel += 10;
    highMedicalRiskFlag = true;
  }
  let certificationGrade = "regular";
  if (scoringGuide.stateWithLowCertification(candidate.originState)) {
    certificationGrade = "low";
    result -= 5;
  } // lots more code like this
  result -= Math.max(healthLevel - 5, 0);
  return result;
}
```

我首先创建一个空的类，用搬移函数（198）把上述函数搬到这个类里去。

```js
function score(candidate, medicalExam, scoringGuide) {
  return new Scorer().execute(candidate, medicalExam, scoringGuide);
}

class Scorer {
  execute(candidate, medicalExam, scoringGuide) {
    let result = 0;
    let healthLevel = 0;
    let highMedicalRiskFlag = false;

    if (medicalExam.isSmoker) {
      healthLevel += 10;
      highMedicalRiskFlag = true;
    }
    let certificationGrade = "regular";
    if (scoringGuide.stateWithLowCertification(candidate.originState)) {
      certificationGrade = "low";
      result -= 5;
    } // lots more code like this
    result -= Math.max(healthLevel - 5, 0);
    return result;
  }
}
```

大多数时候，我更愿意在命令对象的构造函数中传入参数，而不让 execute 函数接收参数。在这样一个简单的拆解场景中，这一点带来的影响不大；但如果我要处理的命令需要更复杂的参数设置周期或者大量定制，上述做法就会带来很多便利：多个命令类可以分别从各自的构造函数中获得各自不同的参数，然后又可以排成队列挨个执行，因为它们的 execute 函数签名都一样。

我可以每次搬移一个参数到构造函数。

```js
function score(candidate, medicalExam, scoringGuide) {
  return new Scorer(candidate).execute(candidate, medicalExam, scoringGuide);
}
```

#### class Scorer...

```js
constructor(candidate){
 this._candidate = candidate;
}

execute (candidate, medicalExam, scoringGuide) {
 let result = 0;
 let healthLevel = 0;
 let highMedicalRiskFlag = false;

 if (medicalExam.isSmoker) {
  healthLevel += 10;
  highMedicalRiskFlag = true;
 }
 let certificationGrade = "regular";
 if (scoringGuide.stateWithLowCertification(this._candidate.originState)) {
  certificationGrade = "low";
  result -= 5;
 }
 // lots more code like this
 result -= Math.max(healthLevel - 5, 0);
 return result;
}
```

继续处理其他参数：

```js
function score(candidate, medicalExam, scoringGuide) {
  return new Scorer(candidate, medicalExam, scoringGuide).execute();
}
```

#### class Scorer...

```js
constructor(candidate, medicalExam, scoringGuide){
 this._candidate = candidate;
 this._medicalExam = medicalExam;
 this._scoringGuide = scoringGuide;
}
execute () {
 let result = 0;
 let healthLevel = 0;
 let highMedicalRiskFlag = false;

 if (this._medicalExam.isSmoker) {
  healthLevel += 10;
  highMedicalRiskFlag = true;
 }
 let certificationGrade = "regular";
 if (this._scoringGuide.stateWithLowCertification(this._candidate.originState)) {
  certificationGrade = "low";
  result -= 5;
 }
 // lots more code like this
 result -= Math.max(healthLevel - 5, 0);
 return result;
}
```

以命令取代函数的重构到此就结束了，不过之所以要做这个重构，是为了拆解复杂的函数，所以我还是大致展示一下如何拆解。下一步是把所有局部变量都变成字段，我还是每次修改一处。

#### class Scorer...

```js
constructor(candidate, medicalExam, scoringGuide){
 this._candidate = candidate;
 this._medicalExam = medicalExam;
 this._scoringGuide = scoringGuide;
}

execute () {
 this._result = 0;
 let healthLevel = 0;
 let highMedicalRiskFlag = false;

 if (this._medicalExam.isSmoker) {
  healthLevel += 10;
  highMedicalRiskFlag = true;
 }
 let certificationGrade = "regular";
 if (this._scoringGuide.stateWithLowCertification(this._candidate.originState)) {
  certificationGrade = "low";
  this._result -= 5;
 }
 // lots more code like this
 this._result -= Math.max(healthLevel - 5, 0);
 return this._result;
}
```

重复上述过程，直到所有局部变量都变成字段。（“把局部变量变成字段”这个重构手法是如此简单，以至于我都没有在重构名录中给它一席之地。对此我略感愧疚。）

#### class Scorer...

```js
constructor(candidate, medicalExam, scoringGuide){
 this._candidate = candidate;
 this._medicalExam = medicalExam;
 this._scoringGuide = scoringGuide;
}

execute () {
 this._result = 0;
 this._healthLevel = 0;
 this._highMedicalRiskFlag = false;

 if (this._medicalExam.isSmoker) {
  this._healthLevel += 10;
  this._highMedicalRiskFlag = true;
 }
 this._certificationGrade = "regular";
 if (this._scoringGuide.stateWithLowCertification(this._candidate.originState)) {
  this._certificationGrade = "low";
  this._result -= 5;
 }
 // lots more code like this
 this._result -= Math.max(this._healthLevel - 5, 0);
 return this._result;
}
```

现在函数的所有状态都已经移到了命令对象中，我可以放心使用提炼函数（106）等重构手法，而不用纠结于局部变量的作用域之类问题。

#### class Scorer...

```js
execute () {
 this._result = 0;
 this._healthLevel = 0;
 this._highMedicalRiskFlag = false;

 this.scoreSmoking();
 this._certificationGrade = "regular";
 if (this._scoringGuide.stateWithLowCertification(this._candidate.originState)) {
  this._certificationGrade = "low";
  this._result -= 5;
 }
 // lots more code like this
 this._result -= Math.max(this._healthLevel - 5, 0);
 return this._result;
 }
scoreSmoking() {
 if (this._medicalExam.isSmoker) {
  this._healthLevel += 10;
  this._highMedicalRiskFlag = true;
 }
}
```

这样我就可以像处理嵌套函数一样处理命令对象。实际上，在 JavaScript 中运用此重构手法时，的确可以考虑用嵌套函数来代替命令对象。不过我还是会使用命令对象，不仅因为我对命令对象更熟悉，而且还因为我可以针对命令对象中任何一个函数进行测试和调试。

## 11.10 以函数取代命令（Replace Command with Function）

反向重构：以命令取代函数（337）

```js
class ChargeCalculator {
  constructor(customer, usage) {
    this._customer = customer;
    this._usage = usage;
  }
  execute() {
    return this._customer.rate * this._usage;
  }
}

function charge(customer, usage) {
  return customer.rate * usage;
}
```

### 动机

命令对象为处理复杂计算提供了强大的机制。借助命令对象，可以轻松地将原本复杂的函数拆解为多个方法，彼此之间通过字段共享状态；拆解后的方法可以分别调用；开始调用之前的数据状态也可以逐步构建。但这种强大是有代价的。大多数时候，我只是想调用一个函数，让它完成自己的工作就好。如果这个函数不是太复杂，那么命令对象可能显得费而不惠，我就应该考虑将其变回普通的函数。

### 做法

运用提炼函数（106），把“创建并执行命令对象”的代码单独提炼到一个函数中。

这一步会新建一个函数，最终这个函数会取代现在的命令对象。

对命令对象在执行阶段用到的函数，逐一使用内联函数（115）。

如果被调用的函数有返回值，请先对调用处使用提炼变量（119），然后再使用内联函数（115）。

使用改变函数声明（124），把构造函数的参数转移到执行函数。

对于所有的字段，在执行函数中找到引用它们的地方，并改为使用参数。每次修改后都要测试。

把“调用构造函数”和“调用执行函数”两步都内联到调用方（也就是最终要替换命令对象的那个函数）。

测试。

用移除死代码（237）把命令类消去。

### 范例

假设我有一个很小的命令对象。

```js
class ChargeCalculator {
  constructor(customer, usage, provider) {
    this._customer = customer;
    this._usage = usage;
    this._provider = provider;
  }
  get baseCharge() {
    return this._customer.baseRate * this._usage;
  }
  get charge() {
    return this.baseCharge + this._provider.connectionCharge;
  }
}
```

使用方的代码如下。

#### 调用方...

```js
monthCharge = new ChargeCalculator(customer, usage, provider).charge;
```

命令类足够小、足够简单，变成函数更合适。

首先，我用提炼函数（106）把命令对象的创建与调用过程包装到一个函数中。

#### 调用方...

```js
monthCharge = charge(customer, usage, provider);
```

#### 顶层作用域...

```js
function charge(customer, usage, provider) {
  return new ChargeCalculator(customer, usage, provider).charge;
}
```

接下来要考虑如何处理支持函数（也就是这里的 baseCharge 函数）。对于有返回值的函数，我一般会先用提炼变量（119）把返回值提炼出来。

#### class ChargeCalculator...

```js
get baseCharge() {
  return this._customer.baseRate * this._usage;
}
get charge() {
  const baseCharge = this.baseCharge;
  return baseCharge + this._provider.connectionCharge;
}
```

然后对支持函数使用内联函数（115）。

#### class ChargeCalculator...

```js
get charge() {
  const baseCharge = this._customer.baseRate * this._usage;
  return baseCharge + this._provider.connectionCharge;
}
```

现在所有逻辑处理都集中到一个函数了，下一步是把构造函数传入的数据移到主函数。首先用改变函数声明（124）把构造函数的参数逐一添加到 charge 函数上。

#### class ChargeCalculator...

```js
constructor (customer, usage, provider){
 this._customer = customer;
 this._usage = usage;
 this._provider = provider;
}

charge(customer, usage, provider) {
 const baseCharge = this._customer.baseRate * this._usage;
 return baseCharge + this._provider.connectionCharge;
}
```

#### 顶层作用域...

```js
function charge(customer, usage, provider) {
  return new ChargeCalculator(customer, usage, provider).charge(
    customer,
    usage,
    provider
  );
}
```

然后修改 charge 函数的实现，改为使用传入的参数。这个修改可以小步进行，每次使用一个参数。

#### class ChargeCalculator...

```js
constructor (customer, usage, provider){
 this._customer = customer;
 this._usage = usage;
 this._provider = provider;
}

charge(customer, usage, provider) {
 const baseCharge = customer.baseRate * this._usage;
 return baseCharge + this._provider.connectionCharge;
}
```

构造函数中对 `this._customer` 字段的赋值不删除也没关系，因为反正没人使用这个字段。但我更愿意去掉这条赋值语句，因为去掉它以后，如果在函数实现中漏掉了一处对字段的使用没有修改，测试就会失败。（如果我真的犯了这个错误而测试没有失败，我就应该考虑增加测试了。）

其他参数也如法炮制，直到 charge 函数不再使用任何字段：

#### class ChargeCalculator...

```js
charge(customer, usage, provider) {
  const baseCharge = customer.baseRate * usage;
  return baseCharge + provider.connectionCharge;
}
```

现在我就可以把所有逻辑都内联到顶层的 charge 函数中。这是内联函数（115）的一种特殊情况，我需要把构造函数和执行函数一并内联。

#### 顶层作用域...

```js
function charge(customer, usage, provider) {
  const baseCharge = customer.baseRate * usage;
  return baseCharge + provider.connectionCharge;
}
```

现在命令类已经是死代码了，可以用移除死代码（237）给它一个体面的葬礼。
