# 第 2 章 重构的原则

## 2.5 重构的挑战

### 分支

我们采用的方法叫作持续集成(Continuous Integration,CI),也叫"基于主干开发"(Trunk-Based Development).

在使用 CI 时,每个团队成员每天至少向主线集成一次.这个实践避免了任何分支彼此差异太大,从而极大地降低了合并的难度.不过 CI 也有其代价:你必须使用相关的实践以确保主线随时处于健康状态,必须学会将大功能拆分成小块,还必须使用特性开关(feature toggle,也叫特性旗标,feature flag)将尚未完成又无法拆小的功能隐藏掉.

### 遗留代码

这个问题没有简单的解决办法,我能给出的最好建议就是买一本<修改代码的艺术>[Feathers],照书里的指导来做.别担心那本书太老,尽管已经出版十多年,其中的建议仍然管用.一言以蔽之,它建议你先找到程序的接缝,在接缝处插入测试,如此将系统置于测试覆盖之下.你需要运用重构手法创造出接缝__这样的重构很危险,因为没有测试覆盖,但这是为了取得进展必要的风险.在这种情况下,安全的自动化重构简直就是天赐福音.如果这一切听起来很困难,因为它确实很困难.很遗憾,一旦跌进这个深坑,没有爬出来的捷径,这也是我强烈倡导从一开始就写能自测试的代码的原因.

### 数据库

我的同事 Pramod Sadalage 发展出一套渐进式数据库设计[mf-evodb]和数据库重构[Ambler &amp; Sadalage]的办法,如今已经被广泛使用.这项技术的精要在于:借助数据迁移脚本,将数据库结构的修改与代码相结合,使大规模的/涉及数据库的修改可以比较容易地开展.

假设我们要对一个数据库字段(列)改名.和改变函数声明(124)一样,我要找出结构的声明处和所有调用处,然后一次完成所有修改.但这里的复杂之处在于,原来基于旧字段的数据,也要转为使用新字段.我会写一小段代码来执行数据转化的逻辑,并把这段代码放进版本控制,跟数据结构声明与使用代码的修改一并提交.此后如果我想把数据库迁移到某个版本,只要执行当前数据库版本与目标版本之间的所有迁移脚本即可.

跟通常的重构一样,数据库重构的关键也是小步修改并且每次修改都应该完整,这样每次迁移之后系统仍然能运行.由于每次迁移涉及的修改都很小,写起来应该容易;将多个迁移串联起来,就能对数据库结构及其中存储的数据做很大的调整.

与常规的重构不同,很多时候,数据库重构最好是分散到多次生产发布来完成,这样即便某次修改在生产数据库上造成了问题,也比较容易回滚.比如,要改名一个字段,我的第一次提交会新添一个字段,但暂时不使用它.然后我会修改数据写入的逻辑,使其同时写入新旧两个字段.随后我就可以修改读取数据的地方,将它们逐个改为使用新字段.这步修改完成之后,我会暂停一小段时间,看看是否有 bug 冒出来.确定没有 bug 之后,我再删除已经没人使用的旧字段.这种修改数据库的方式是并行修改(Parallel Change,也叫扩展协议/expand-contract)[mf-pc]的一个实例.

