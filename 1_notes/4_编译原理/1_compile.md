* LTCG: incremental

内建函数是和机器指令直接相关的，不会产生函数调用。

C++ 本身并没有内建函数,但是一些编译器(如 GCC 和 Clang)提供了一些内建函数,用于实现一些特殊的功能或优化.以下是一些常用的 GCC 和 Clang 的内建函数:

__builtin_expect(long exp, long c):这个函数用于提供分支预测信息给编译器,以优化生成的代码.exp 是你预计的值,c 是你期望的值.如果 exp == c,那么这个表达式的结果更有可能为真.

__builtin_popcount(unsigned int x):这个函数返回 x 的二进制表示中 1 的数量.

__builtin_clz(unsigned int x) 和 __builtin_ctz(unsigned int x):这两个函数分别返回 x 的二进制表示中从最高位开始和最低位开始的连续 0 的数量.

__builtin_ffs(int x):这个函数返回 x 的二进制表示中第一个 1 的位置,如果 x 为 0,则返回 0.

__builtin_prefetch(const void *addr, ...):这个函数用于预取 addr 指向的内存区域,以减少以后访问这个内存区域的延迟.

以上这些函数在 GCC 和 Clang 中都可用,但在其他编译器(如 MSVC)中可能不可用.在使用这些函数时,你需要确保你的代码能在目标编译器上正确编译和运行.

此外,这些函数都是编译器扩展,不是 C++ 标准的一部分,因此在使用这些函数时,你需要考虑到代码的可移植性问题.如果可能,你应该优先使用标准库提供的功能,只有在必要的时候才使用这些内建函数.

如果是使用了模板，每一个编译单元都会有一个自己的实例代码。如果不是通过模板实现，函数的定义只会在自己对应的编译单元，其他编译单元通过链接的方式找到。

编译器之所以能够实现所谓的“开洞”行为，主要是因为它在编译过程中对源代码有深入的理解和控制。编译器的工作流程大致可以分为以下几个阶段：

1. **预处理（Preprocessing）**：
   - 处理预处理指令，如宏定义的展开、条件编译指令、头文件的包含等。这一阶段，编译器会根据预处理指令修改源代码。

2. **词法分析（Lexical Analysis）**：
   - 将源代码分解成一系列的标记（Tokens），如关键字、标识符、字面量等。

3. **语法分析（Syntax Analysis）**：
   - 根据语言的语法规则，将标记序列组织成抽象语法树（Abstract Syntax Tree, AST）。

4. **语义分析（Semantic Analysis）**：
   - 检查 AST 中的语义错误，如类型不匹配、未定义的标识符等，并生成中间表示（Intermediate Representation, IR）。

5. **优化（Optimization）**：
   - 对 IR 进行优化，以提高程序的性能或减少资源消耗。这一阶段，编译器会利用其对程序结构和语义的深入理解来执行各种优化。

6. **代码生成（Code Generation）**：
   - 将优化后的 IR 转换成目标代码，可能是汇编代码或直接的机器代码。

7. **链接（Linking）**：
   - 将编译生成的目标代码与库文件和其他模块链接在一起，生成可执行文件。

编译器能够实现“开洞”行为的关键因素包括：

- **全局视角**：编译器可以看到整个源代码，因此可以进行全局优化和分析，而用户代码只能看到局部。

- **语言和平台特性**：编译器了解目标编程语言的规范和特性，以及目标平台的硬件特性，因此可以利用这些信息进行优化。

- **控制编译过程**：编译器控制着从源代码到目标代码的整个转换过程，可以在任何阶段插入特殊的处理逻辑。

- **访问底层信息**：编译器可以访问底层的硬件和操作系统信息，这使得它能够生成针对特定平台优化的代码。

- **编译器扩展和内置函数**：编译器通常提供一些特殊的内置函数和扩展，这些是专门为编译器设计的，用户代码无法直接使用。

通过这些能力，编译器能够在编译过程中实现那些用户代码难以或无法实现的特殊功能。

## 编译过程与原理

### 1. 编译过程 - 编译器在做什么？

如果想要机器按照我们的设想执行我们的命令，我们需要一个能够跟机器沟通的方式，而这种方式也就是==机器语言(第一代计算机语言)==，一堆`01`构成的指令。我们需要事先设计好指令集到机器上，比如说规定好从某寄存器阅读值的指令为什么。

可这种方式面临的第一个问题就是，不同机器之间指令集不一致，比如说DSP和ARM在实现加法上，可能就会出现不同寄存器的调用方法。那很显然就会设想出一种统一的语言，即==汇编语言(第二代计算机语言)==。而汇编实现的只是将`01`等机器码指令使用一个统一的命名，如`ADD`而已。令所有机器指令集可与汇编语言转换即可。

汇编语言仍存在很多问题，主要表现为阅读性极差、开发难度大、开发周期长、移植问题没有彻底解决。因此也就出现了==高级语言(第三代语言)==，在汇编语言的基础上实现了抽象，避免了繁琐寄存器的操作。

那源代码(高级语言)是如何让计算机理解的呢？其步骤是？

* 如果源代码在操作系统上：源代码生成汇编代码，再通过汇编和链接方式形成可执行文件，然后通过加载器加载到操作系统执行。
* 如果源代码在虚拟机(解释器)上：源代码生成中间代码(人可以直接理解的，而汇编则认为人无法理解)，如字节码等。

在Linux系统下，可用以下指令完成源程序到目标程序的转化：

> gcc -o hello hello.c main.c

gcc 编译器驱动程序读取源文件hello.c和main.c，经过预处理、编译、汇编、链接（分别使用预处理器、编译器、汇编器、链接器，这四个程序构成了编译系统）四个步骤，将其翻译成可执行目标程序hello。如下图所示： 

![alt text](_imgs/1_编译过程与原理_image.png)

#### 1.1 预处理

预处理器(CPP)根据源程序中以字符”#”开头的命令，修改源程序，得到另一个源程序，常以.i作为文件扩展名。修改主要包括#include、#define和条件编译三个方面。

> gcc -o main.i -E main.c

预处理只是对源文件进行了扩展，得到的仍然是C语言源程序。

#### 1.2 编译

编译程序所要作得工作就是通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。

编译器(CCL)将经过预处理器处理得到的文本文件hello.i和main.i翻译成hello.s与main.s，其中包含了汇编语言程序，汇编语言程序以一种标准的文本格式确切描述一条低级机器语言指令。 
 运行以下命令进行编译：

> gcc -S main.i hello.i

##### 1.2.1 编译过程


#### 1.3 汇编

汇编器(AS)将hello.s和main.s翻译成机器语言指令，并打包成可重定位目标程序，一般以.o为文件扩展名。可重定位目标程序是二进制文件，它的字节编码是机器语言指令而不是字符。 
 运行以下指令可得到重定位目标程序main.o和hello.o：

> gcc -c main.s hello.s

用文本编辑器打开main.o和hello.o发现文件是乱码，因为此时已经是二进制文件。

#### 1.4 链接

链接程序(LD）将main.o和hello.o以及一些其他必要的目标文件组合起来，创建可执行目标文件。

> gcc -o hello main.o hello.o

得到可执行程序hello. 
 在终端运行./hello，程序加载并运行.

根据开发人员指定的同库函数的链接方式的不同，链接处理可分为两种： 

* 静态链接 
  在这种链接方式下，函数的代码将从其所在的静态链接库中被拷贝到最终的可执行程序中。这样该程序在被执行时这些代码将被装入到该进程的虚拟地址空间中。静态链接库实际上是一个目标文件的集合，其中的每个文件含有库中的一个或者一组相关函数的代码。 
* 动态链接 
  在此种方式下，函数的代码被放到称作是动态链接库或共享对象的某个目标文件中。链接程序此时所作的只是在最终的可执行程序中记录下共享对象的名字以及其它少量的登记信息。在此可执行文件被执行时，动态链接库的全部内容将被映射到运行时相应进程的虚地址空间。动态链接程序将根据可执行程序中记录的信息找到相应的函数代码。 
   对于可执行文件中的函数调用，可分别采用动态链接或静态链接的方法。使用动态链接能够使最终的可执行文件比较短小，并且当共享对象被多个进程使用时能节约一些内存，因为在内存中只需要保存一份此共享对象的代码。但并不是使用动态链接就一定比使用静态链接要优越。在某些情况下动态链接可能带来一些性能上损害。

[动态链接](https://kshttps0.wiz.cn/ks/note/view/2336be1c-7b66-490d-91e0-240081977c3d/e730f0ac-0a19-4994-8f7f-1355d3c86eec/#动态链接)
[动态库的编译](https://kshttps0.wiz.cn/ks/note/view/2336be1c-7b66-490d-91e0-240081977c3d/e730f0ac-0a19-4994-8f7f-1355d3c86eec/#动态库的编译)



#### 编译链接和载入

* 编译：将预处理生成的文件，经过**语法分析、词法分析、语义分析、以及优化后编译成若干个目标模块**。可以理解为将高级语言翻译为计算机可以理解的二进制代码，即机器语言
* 链接：由链接程序将编译后形成的**一组目标模块**以及他们所需要的**库函数**链接在一起，形成一个完整的**载入模型**。链接主要解决**模块间的相互引用问题**，分为**地址和空间分配**，**符号解析**和**重定位**几个步骤。**在编译阶段生成目标文件时，会暂时搁置这些外部引用**，而这些外部引用就是在链接时确定的，链接器在链接时，会**根据符号名称去相应模块中寻找对应的符号**，**待符号确定后，链接器会重写之前哪些未确定的符号的地址**，这个过程就是重定位
* 载入：由载入程序将载入模块载入内存

#### 动态链接和静态链接的区别

* 静态链接以一组可重定位目标文件为输入，文件由各种不同的代码和数据节组成，通过符号解析和重定位生成一个完全链接的可以加载和运行的可执行文件
* 静态链接有一些明显的缺点，**一是如果需要更新一个库，需要重新编译和链接库文件**。二是对于一些标准的函数，**如果将这些代码复制到每个程序运行的文本段中，会对存储器的资源造成很大的浪费**
* 共享库就是为解决静态链接问题而生，共享库是一个目标模块。在运行时，可以加载到任意存储器地址，并和一个在存储器中的程序链接起来。这个过程称为动态链接。共享库在unix下通常使用.so后缀，window下为dll
* 共享库使用两种方式共享，一是一个库只有一个so文件，**所有引用该库的执行程序共享这个文件的代码和数据**。**二是一个共享库的.text节的一个副本可以被不同的进程共享**
* 注意在整个程序的链接过程中，**链接器只是拷贝了一些重定位和符号信息**。**在程序加载（execve）时才会解析so文件中代码和数据的引用**

#### 动态库和静态库的创建与使用

* 库的名字由 lib+name+后缀，静态库的后缀为.a 动态库的后缀为.so 

* 动态库的创建步骤

  * 将.c文件全部编译为.o文件

  * 在Shell下输入命令，创建动态库：

    ```shell
    gcc -shared –fPIC –o libname.so sourcefile.c
    -shared 该选项指定生成动态连接库（让连接器生成T类型的导出符号表，有时候也生成弱连接W类型的导出符号），不用该标志外部程序无法连接。相当于一个可执行文件
    -fPIC：表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时是通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的
    ```

  * 使用动态库

    ```shell
    gcc -o file file.c -L. -lname
    -L.：表示要链接的库在当前目录中
    ```

  * **动态链接时、执行时搜索路径顺序**

    * 编译目标代码时，`-L`指定的动态库搜索路径
    * 环境变量`LD_LIBRARY_PATH`指定的动态库搜索路径
    * 配置文件`/etc/ld.so.conf`中指定的动态库搜索路径
    * 默认的动态库搜索路径`/lib`，`/usr/lib`

* 静态库的创建步骤

  * 将.c文件全部编译为.o文件

  * 在Shell下输入命令，创建静态库： 

    ```shell
    ar rcs libname.a 目标文件1 目标文件2...
    ```

* 使用静态库

  ```shell
   gcc  -o file file.c –L. -lname 
   # -L 为静态库路径 
   # -l 为是链接到库的名字（可以简写库的名字）
  ```

* **静态库链接时搜索路径顺序**

  * ld会去找GCC命令中的参数`-L`

  * 再找gcc的环境变量`LIBRARY_PATH`
  * 再找内定目录 `/lib`，`/usr/lib`， `/usr/local/lib` 这是当初compile gcc时写在程序内的

#### gcc和g++的异同

* 均属于the GNU Compiler Collection，gcc是鼻祖，后来才有了g++

  ```c++
  g++ == gcc -xc++ -lstdc++ -shared-libgcc	// gcc后面两项都是链接选项，表示g++要相比gcc链接其他库函数
  ```

* 不同

  * **g++会自动链接C++标准库**，比如algorithm，string，vector等

  * gcc会根据文件后缀(.c,.cpp)自动识别是C文件还是C++文件，g++均认为是C++文件

  * gcc编译C文件少很多宏定义，gcc编译C++会多一些宏定义

    ```c
    #define __GXX_WEAK__ 1
    #define __cplusplus 1
    #define __DEPRECATED 1
    #define __GNUG__ 4
    #define __EXCEPTIONS 1
    #define __private_extern__ extern
    ```



### 2. 编译原理 - 编译器是如何实现的？

![image-20220126215910369](https://s2.loli.net/2022/01/26/xVbeED8TKaYIG2w.png)

[编译原理入门篇|一篇文章理解编译全过程](https://www.cnblogs.com/fisherss/p/13905395.html)

[手把手教你构建C语言编译器](https://lotabout.me/2015/write-a-C-interpreter-0/)


### 3. c++的符号导入导出

* **C++中符号是什么意思?导入和导出又是什么?**
  * 符号: 
    在C++中，"符号"通常指的是程序中的函数名、变量名等标识符。在编译和链接过程中，这些符号被用来标识和引用代码中的特定部分。
  
  * 导入导出:
    "导入"和"导出"是动态链接库（DLL）或共享对象（SO）中的概念。当你创建一个动态链接库时，你可能会有一些函数或变量想要让其他程序或库使用，这时你就需要将这些函数或变量"导出"。"导出"就是将这些符号（函数或变量的名字）添加到库的公开符号表中，这样其他程序就可以在运行时链接到这些函数或变量。

    相反，当你的程序或库想要使用动态链接库中的函数或变量时，你需要"导入"这些符号。"导入"就是在你的程序中引用这些公开的符号，然后在运行时，动态链接器会负责找到这些符号对应的实际函数或变量。

    总的来说，"导入"和"导出"是动态链接的基础，它们允许程序在运行时共享和使用代码。

  * 符号表:
    在C++中,符号表是编译器在编译过程中创建的一种数据结构,用于存储程序中定义的各种符号(如函数名/变量名等)及其相关信息(如类型/作用域/内存位置等).

    可以使用nm命令来查看一个编译后的二进制文件(如可执行文件或库文件)的符号表.例如:
    ```c++
      nm my_program
    ```

    这将列出my_program中的所有符号,以及它们在程序中的地址.

    需要注意的是,只有在编译时开启了调试信息(如使用-g选项)时,才能在编译后的二进制文件中看到完整的符号表.否则,可能只能看到部分或没有符号信息.
    
* **linux和windows的符号导入导出的行为差异？**

  * 在Windows中,符号的导入和导出通常需要明确指定.例如,当你创建一个DLL时,你需要使用__declspec(dllexport)关键字来明确标记哪些函数或变量需要导出.同样,当你使用一个DLL时,你需要使用__declspec(dllimport)来明确标记哪些函数或变量需要导入.

    ```c++
    // 在DLL中
    __declspec(dllexport) void MyFunction();

    // 在使用DLL的程序中
    __declspec(dllimport) void MyFunction();
    ```
  * 在Linux中,情况则不同.默认情况下,所有的函数和全局变量都会被导出,除非你明确地隐藏它们.你可以使用__attribute__((visibility("default")))和__attribute__((visibility("hidden")))来控制符号的可见性.

    ```c++
    // 这个函数会被导出
    void MyFunction1();

    // 这个函数不会被导出
    __attribute__((visibility("hidden"))) void MyFunction2();
    ```
