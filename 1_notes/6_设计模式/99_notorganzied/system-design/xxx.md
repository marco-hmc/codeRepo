# 规范化和反规范化

## 术语

在进一步讨论之前，让我们看看规范化和反规范化中一些常用的术语。

### 键

**主键**：可以用来唯一标识表中每一行的列或列组。

**复合键**：由多个列组成的主键。

**超键**：能够唯一标识表中所有行的所有键的集合。

**候选键**：在表中唯一标识行的属性。

**外键**：引用另一个表的主键。

**备用键**：不是主键的键称为备用键。

**代理键**：当没有其他列能够满足主键属性时，系统生成的唯一标识表中每个条目的值。

### 依赖关系

**部分依赖**：当主键决定其他一些属性时发生。

**函数依赖**：在表中，通常是主键和非键属性之间存在的关系。

**传递函数依赖**：当某些非键属性决定其他属性时发生。

### 异常

数据库异常是由于不正确的规划或将所有内容存储在一个平面数据库中而导致的数据库缺陷。通常通过规范化过程来解决这些问题。

有三种类型的数据库异常：

**插入异常**：当我们无法在没有其他属性的情况下插入某些属性时发生。

**更新异常**：在数据冗余和部分更新的情况下发生。换句话说，正确更新数据库需要其他操作，如添加、删除或两者兼有。

**删除异常**：当删除某些数据需要删除其他数据时发生。

**示例**

让我们考虑以下未规范化的表：

| ID  | 名字   | 角色              | 团队 |
| --- | ------ | ----------------- | ---- |
| 1   | 彼得  | 软件工程师         | A    |
| 2   | 布莱恩 | DevOps 工程师      | B    |
| 3   | 海莉  | 产品经理           | C    |
| 4   | 海莉  | 产品经理           | C    |
| 5   | 史蒂夫 | 前端工程师         | D    |

假设我们雇佣了一个新员工“约翰”，但他可能不会立即被分配到团队。这将导致插入异常，因为团队属性尚不存在。

接下来，假设来自团队 C 的海莉被提升了，为了在数据库中反映这一变化，我们需要更新两行以保持一致性，这可能导致更新异常。

最后，我们想要删除团队 B，但要做到这一点，我们还需要删除其他信息，如名字和角色，这是删除异常的一个例子。

## 规范化

规范化是组织数据库中数据的过程。这包括创建表并根据设计规则在这些表之间建立关系，以保护数据并通过消除冗余和不一致的依赖关系使数据库更加灵活。

### 为什么需要规范化？

规范化的目标是消除冗余数据并确保数据一致性。一个完全规范化的数据库允许其结构扩展以容纳新类型的数据，而无需过多更改现有结构。因此，与数据库交互的应用程序受到的影响最小。

### 规范形式

规范形式是一系列确保数据库规范化的指南。让我们讨论一些基本的规范形式：

**第一范式 (1NF)**

一个表要满足第一范式 (1NF)，应遵循以下规则：

- 不允许重复组。
- 使用主键标识每组相关数据。
- 相关数据集应有一个单独的表。
- 不允许在同一列中混合数据类型。

**第二范式 (2NF)**

一个表要满足第二范式 (2NF)，应遵循以下规则：

- 满足第一范式 (1NF)。
- 不应有任何部分依赖。

**第三范式 (3NF)**

一个表要满足第三范式 (3NF)，应遵循以下规则：

- 满足第二范式 (2NF)。
- 不允许传递函数依赖。

**BCNF**

Boyce-Codd 规范形式 (BCNF) 是第三范式 (3NF) 的稍强版本，用于解决 3NF 原始定义未处理的某些类型的异常。有时也称为 3.5 范式 (3.5NF)。

一个表要满足 Boyce-Codd 规范形式 (BCNF)，应遵循以下规则：

- 满足第三范式 (3NF)。
- 对于每个函数依赖 X → Y，X 应该是超键。

_还有更多的规范形式，如 4NF、5NF 和 6NF，但我们在这里不讨论它们。请查看这个 [精彩视频](https://www.youtube.com/watch?v=GFQaEYEc8_8)，了解详细信息。_

在关系数据库中，如果一个关系满足第三范式，通常被描述为“规范化”。大多数 3NF 关系都没有插入、更新和删除异常。

与许多正式规则和规范一样，现实世界的场景并不总是允许完全遵守。如果你决定违反前三条规范化规则之一，请确保你的应用程序预见到可能发生的任何问题，如数据冗余和不一致的依赖关系。

### 优点

以下是规范化的一些优点：

- 减少数据冗余。
- 更好的数据设计。
- 增加数据一致性。
- 强制执行参照完整性。

### 缺点

让我们看看规范化的一些缺点：

- 数据设计复杂。
- 性能较慢。
- 维护开销。
- 需要更多的连接。

## 反规范化

反规范化是一种数据库优化技术，我们在一个或多个表中添加冗余数据。这可以帮助我们避免在关系数据库中进行昂贵的连接。它试图在牺牲一些写性能的情况下提高读取性能。为了避免昂贵的连接，冗余数据的副本被写入多个表中。

一旦数据通过分片和分区等技术分布，跨网络管理连接会进一步增加复杂性。反规范化可能会避免这种复杂连接的需求。

_注意：反规范化并不意味着逆转规范化。_

### 优点

让我们看看反规范化的一些优点：

- 检索数据更快。
- 编写查询更容易。
- 减少表的数量。
- 方便管理。

### 缺点

以下是反规范化的一些缺点：

- 插入和更新昂贵。
- 增加数据库设计的复杂性。
- 增加数据冗余。
- 数据不一致的可能性更大。

# ACID 和 BASE 一致性模型

让我们讨论 ACID 和 BASE 一致性模型。

## ACID

ACID 代表原子性、一致性、隔离性和持久性。ACID 属性用于在事务处理期间维护数据完整性。

为了在事务前后保持一致性，关系数据库遵循 ACID 属性。让我们理解这些术语：

### 原子性

事务中的所有操作成功或所有操作回滚。

### 一致性

事务完成后，数据库结构完整。

### 隔离性

事务之间不相互竞争。数据库通过调节数据的竞争访问，使事务看起来是顺序运行的。

### 持久性

一旦事务完成，写入和更新被写入磁盘，即使发生系统故障，它们也会保留在系统中。

## BASE

随着数据量的增加和高可用性要求，数据库设计的方法也发生了巨大变化。为了提高可扩展性并同时保持高可用性，我们将逻辑从数据库移到单独的服务器上。这样，数据库变得更加独立，专注于实际的数据存储过程。

在 NoSQL 数据库世界中，ACID 事务较少见，因为一些数据库放宽了对即时一致性、数据新鲜度和准确性的要求，以获得其他好处，如可扩展性和弹性。

BASE 属性比 ACID 保证要宽松得多，但两者之间没有一一对应的映射。让我们理解这些术语：

### 基本可用性

数据库大部分时间看起来都在工作。

### 软状态

存储不必是写一致的，不同副本也不必一直相互一致。

### 最终一致性

数据可能不会立即一致，但最终会变得一致。即使系统中的读取可能不会立即给出正确的响应，但它们仍然是可能的。

## ACID vs BASE 权衡

我们的应用程序是否需要 ACID 或 BASE 一致性模型没有正确答案。这两种模型都是为了满足不同的需求而设计的。在选择数据库时，我们需要牢记两种模型的属性和应用程序的需求。

鉴于 BASE 的宽松一致性，如果选择 BASE 存储，开发人员需要对一致数据更加了解和严格。熟悉所选数据库的 BASE 行为并在这些约束内工作是至关重要的。

另一方面，与 ACID 事务的简单性相比，围绕 BASE 限制进行规划有时可能是一个主要缺点。对于数据可靠性和一致性至关重要的用例，完全 ACID 数据库是完美的选择。

# CAP 定理

CAP 定理指出，分布式系统只能提供一致性、可用性和分区容忍性（CAP）中的两个特性。

![cap-theorem](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/cap-theorem/cap-theorem.png)

让我们详细看看 CAP 定理所指的三个分布式系统特性。

### 一致性

一致性意味着所有客户端在同一时间看到相同的数据，无论它们连接到哪个节点。为了实现这一点，每当数据写入一个节点时，必须立即转发或复制到系统中的所有节点，然后写操作才被视为“成功”。

### 可用性

可用性意味着任何请求数据的客户端都会得到响应，即使一个或多个节点宕机。

### 分区容忍性

分区容忍性意味着系统在消息丢失或部分故障的情况下继续工作。一个分区容忍的系统可以承受任何不导致整个网络故障的网络故障。数据在节点和网络的组合中充分复制，以便在间歇性中断期间保持系统运行。

## 一致性-可用性权衡

我们生活在一个物理世界中，无法保证网络的稳定性，因此分布式数据库必须选择分区容忍性 (P)。这意味着在一致性 (C) 和可用性 (A) 之间进行权衡。

### CA 数据库

CA 数据库在所有节点上提供一致性和可用性。如果系统中任何两个节点之间存在分区，它就无法做到这一点，因此无法提供容错。

**示例**：[PostgreSQL](https://www.postgresql.org)、[MariaDB](https://mariadb.org)。

### CP 数据库

CP 数据库在牺牲可用性的情况下提供一致性和分区容忍性。当任何两个节点之间发生分区时，系统必须关闭不一致的节点，直到分区解决。

**示例**：[MongoDB](https://www.mongodb.com)、[Apache HBase](https://hbase.apache.org)。

### AP 数据库

AP 数据库在牺牲一致性的情况下提供可用性和分区容忍性。当发生分区时，所有节点仍然可用，但位于分区错误一端的节点可能会返回比其他节点更旧版本的数据。当分区解决后，AP 数据库通常会重新同步节点以修复系统中的所有不一致。

**示例**：[Apache Cassandra](https://cassandra.apache.org)，[CouchDB](https://couchdb.apache.org)。

# PACELC 定理

PACELC 定理是 CAP 定理的扩展。CAP 定理指出，在分布式系统中发生网络分区 (P) 的情况下，必须在可用性 (A) 和一致性 (C) 之间做出选择。

PACELC 通过引入延迟 (L) 作为分布式系统的一个附加属性扩展了 CAP 定理。该定理指出，即使在系统正常运行且没有分区的情况下 (E)，也必须在延迟 (L) 和一致性 (C) 之间做出选择。

_PACELC 定理最早由 [Daniel J. Abadi](https://scholar.google.com/citations?user=zxeEF2gAAAAJ) 描述。_

![pacelc-theorem](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/pacelc-theorem/pacelc-theorem.png)

PACELC 定理的提出是为了应对 CAP 定理的一个关键限制，因为 CAP 定理没有考虑性能或延迟。

例如，根据 CAP 定理，如果查询在 30 天后返回响应，数据库可以被认为是可用的。显然，这样的延迟对于任何现实世界的应用程序都是不可接受的。

# 事务

事务是一系列被视为_“单一工作单元”_的数据库操作。事务中的操作要么全部成功，要么全部失败。通过这种方式，事务的概念在系统的一部分发生故障时支持数据完整性。并非所有数据库都选择支持 ACID 事务，通常是因为它们优先考虑其他难以或理论上不可能一起实现的优化。

_通常，关系数据库支持 ACID 事务，而非关系数据库则不支持（有例外情况）。_

## 状态

数据库中的事务可以处于以下状态之一：

![transaction-states](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/transactions/transaction-states.png)

### 活动

在此状态下，事务正在执行。这是每个事务的初始状态。

### 部分提交

当事务执行其最后一个操作时，称其处于部分提交状态。

### 提交

如果事务成功执行了所有操作，则称其为提交状态。其所有影响现在都永久地建立在数据库系统上。

### 失败

如果数据库恢复系统进行的任何检查失败，则称事务处于失败状态。失败的事务不能再继续进行。

### 中止

如果任何检查失败且事务已达到失败状态，则恢复管理器会回滚数据库上的所有写操作，将数据库恢复到事务执行前的原始状态。处于此状态的事务被中止。

事务中止后，数据库恢复模块可以选择以下两种操作之一：

- 重新启动事务
- 终止事务

### 终止

如果没有回滚或事务来自_提交状态_，则系统一致并准备好进行新事务，旧事务被终止。

# 分布式事务

分布式事务是一组在两个或多个数据库上执行的数据操作。它通常在通过网络连接的独立节点之间协调，但也可能跨越单个服务器上的多个数据库。

## 为什么需要分布式事务？

与单个数据库上的 ACID 事务不同，分布式事务涉及更改多个数据库上的数据。因此，分布式事务处理更加复杂，因为数据库必须协调事务中更改的提交或回滚，作为一个自包含的单元。

换句话说，所有节点必须提交，或者所有节点必须中止并回滚整个事务。这就是为什么我们需要分布式事务。

现在，让我们看看一些流行的分布式事务解决方案：

## 两阶段提交

![two-phase-commit](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/distributed-transactions/two-phase-commit.png)

两阶段提交 (2PC) 协议是一种分布式算法，用于协调参与分布式事务的所有进程是否提交或中止（回滚）事务。

该协议在许多临时系统故障情况下实现了其目标，因此被广泛使用。然而，它并不能抵御所有可能的故障配置，在极少数情况下需要手动干预以纠正结果。

该协议需要一个协调节点，基本上协调和监督不同节点之间的事务。协调器尝试在两个阶段中建立进程集之间的共识，因此得名。

### 阶段

两阶段提交包括以下阶段：

**准备阶段**

准备阶段涉及协调节点从每个参与节点收集共识。除非每个节点都响应_准备好_，否则事务将被中止。

**提交阶段**

如果所有参与者都向协调器响应_准备好_，则协调器要求所有节点提交事务。如果发生故障，事务将被回滚。

### 问题

两阶段提交协议可能出现以下问题：

- 如果其中一个节点崩溃怎么办？
- 如果协调器本身崩溃怎么办？
- 它是一个阻塞协议。

## 三阶段提交

![three-phase-commit](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/distributed-transactions/three-phase-commit.png)

三阶段提交 (3PC) 是两阶段提交的扩展，其中提交阶段分为两个阶段。这有助于解决两阶段提交协议中出现的阻塞问题。

### 阶段

三阶段提交包括以下阶段：

**准备阶段**

此阶段与两阶段提交相同。

**预提交阶段**

协调器发出预提交消息，所有参与节点必须确认。如果参与者未能及时收到此消息，则事务将被中止。

**提交阶段**

此步骤也类似于两阶段提交协议。

### 预提交阶段为何有用？

预提交阶段实现了以下目标：

- 如果在此阶段找到参与节点，则意味着_每个_参与者都已完成第一阶段。准备阶段的完成得到保证。
- 现在每个阶段都可以超时，避免无限期等待。

## Sagas

![sagas](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/distributed-transactions/sagas.png)

Saga 是一系列本地事务。每个本地事务更新数据库并发布消息或事件以触发 Saga 中的下一个本地事务。如果本地事务因违反业务规则而失败，则 Saga 执行一系列补偿事务，撤销前面本地事务所做的更改。

### 协调

有两种常见的实现方法：

- **编排**：每个本地事务发布域事件，触发其他服务中的本地事务。
- **协调**：协调者告诉参与者要执行哪些本地事务。

### 问题

- Saga 模式特别难以调试。
- 存在 Saga 参与者之间循环依赖的风险。
- 缺乏参与者数据隔离带来了持久性挑战。
- 测试困难，因为所有服务必须运行以模拟事务。

# 分片

在讨论分片之前，让我们谈谈数据分区：

## 数据分区

数据分区是一种将数据库拆分成许多更小部分的技术。它是将数据库或表拆分到多个机器上的过程，以提高数据库的可管理性、性能和可用性。

### 方法

有许多不同的方法可以用来决定如何将应用程序数据库拆分成多个更小的数据库。以下是一些大型应用程序使用的最流行的方法：

**水平分区（或分片）**

在这种策略中，我们根据_分区键_定义的值范围水平拆分表数据。这也称为**_数据库分片_**。

**垂直分区**

在垂直分区中，我们根据列垂直分区数据。我们将表拆分成相对较小的表，每个部分存在于单独的分区中。

在本教程中，我们将特别关注分片。

## 什么是分片？

分片是一种与_水平分区_相关的数据库架构模式，它将一个表的行分离到多个不同的表中，称为_分区_或_分片_。每个分区具有相同的模式和列，但也包含共享数据的子集。同样，每个分区中的数据是唯一的，与其他分区中的数据独立。

![sharding](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/sharding/sharding.png)

数据分片的理由是，在某个点之后，水平扩展通过添加更多机器比通过添加强大的服务器进行垂直扩展更便宜和更可行。分片可以在应用程序级别或数据库级别实现。

## 分区标准

有许多可用于数据分区的标准。以下是一些最常用的标准：

### 基于哈希

这种策略基于哈希算法将行划分到不同的分区中，而不是基于连续索引对数据库行进行分组。

这种方法的缺点是动态添加/删除数据库服务器变得昂贵。

### 基于列表

在基于列表的分区中，每个分区是根据列上的值列表定义和选择的，而不是一组连续的值范围。

### 基于范围

范围分区根据分区键的值范围将数据映射到各个分区。换句话说，我们以每个分区包含给定范围内的行的方式对表进行分区。

范围应是连续的但不重叠，每个范围为分区指定一个非包含的下限和上限。任何等于或高于范围上限的分区键值都将添加到下一个分区。

### 复合

顾名思义，复合分区基于两种或多种分区技术对数据进行分区。在这里，我们首先使用一种技术对数据进行分区，然后每个分区进一步细分为子分区，使用相同或其他方法。

## 优点

但为什么我们需要分片？以下是一些优点：

- **可用性**：为分区数据库提供逻辑独立性，确保应用程序的高可用性。这里各个分区可以独立管理。
- **可扩展性**：通过将数据分布到多个分区来提高可扩展性。
- **安全性**：通过将敏感和非敏感数据存储在不同的分区中，有助于提高系统的安全性。这可以为敏感数据提供更好的可管理性和安全性。
- **查询性能**：提高系统性能。系统不再需要查询整个数据库，而只需查询较小的分区。
- **数据可管理性**：将表和索引划分为更小、更易管理的单元。

## 缺点

- **复杂性**：分片增加了系统的整体复杂性。
- **跨分片连接**：一旦数据库被分区并分布到多台机器上，通常无法执行跨多个数据库分片的连接。这样的连接不会高效，因为数据必须从多个服务器检索。
- **重新平衡**：如果数据分布不均匀或单个分片负载过大，在这种情况下，我们必须重新平衡分片，以便请求尽可能均匀地分布在分片之间。

## 何时使用分片？

以下是一些分片可能是正确选择的原因：

- 利用现有硬件而不是高端机器。
- 在不同地理区域维护数据。
- 通过添加更多分片快速扩展。
- 更好的性能，因为每台机器的负载较小。
- 当需要更多并发连接时。
