### 0. items

- 优化方法在没有数据支持的情况下是不可靠的。通过性能分析工具收集数据，确定性能瓶颈，然后再进行有针对性的优化。
- 很多人误认为使用锁会让程序变慢，但实际上影响性能的不是锁本身，而是锁争用（多个线程同时竞争同一个锁）。
- 需要学会在程序的复杂度和性能之间取得平衡，并考虑机器扩容的可能性。


### 内存安全

访问越界数组不一定会导致段错误（segmentation fault），但在某些情况下确实可能会发生。段错误通常发生在程序试图访问未分配或受保护的内存区域时。以下是一些可能导致段错误的情况，以及为什么访问越界数组不一定总是会导致段错误。

什么时候会有段错误？
1. **访问未分配的内存**：
   - 当程序试图访问未分配的内存区域时，操作系统会检测到并触发段错误。例如，访问一个指针指向的内存地址，但该地址未被分配。
2. **访问受保护的内存**：
   - 当程序试图访问受保护的内存区域（如只读内存或内核空间）时，操作系统会触发段错误。
3. **访问已经释放的内存**：
   - 当程序试图访问已经通过 `free` 或 `delete` 释放的内存时，可能会触发段错误。

访问越界数组不一定会有段错误的原因

1. **越界访问在已分配的内存范围内**：
   - 如果越界访问的内存地址仍然在程序已分配的内存范围内，可能不会立即触发段错误。例如，访问数组的越界元素，但该元素在同一个内存块中。
2. **未触发内存保护机制**：
   - 如果越界访问的内存地址未触发操作系统的内存保护机制，可能不会触发段错误。例如，访问堆上的越界元素，但该元素未超出堆的边界。

访问越界数组不一定会导致段错误，具体取决于越界访问的内存地址是否在已分配的内存范围内，以及是否触发了操作系统的内存保护机制。段错误通常发生在程序试图访问未分配或受保护的内存区域时。为了避免段错误和其他未定义行为，建议在访问数组时进行边界检查。


### 原始指针
最好不要用原始指针

1. 指针作为返回的时候
```cpp
Info* foo();
```
* 用户负责指针指向对象的析构
* foo()负责指针指向对象的析构
* 指针是能否为空？是不是外部用之前都得判断一下？
总是会有歧义。
因此如果是foo()内部管理声明周期，可以选择返回引用；
如果是用户负责生命周期，可以选择返回智能指针。
甚至乎其实不返回指针，返回对象实例的时候，因为rvo的存在。其实性能差不多的。
但是rvo在多返回路径的时候没办法支持，这个时候可以考虑使用移动语义。