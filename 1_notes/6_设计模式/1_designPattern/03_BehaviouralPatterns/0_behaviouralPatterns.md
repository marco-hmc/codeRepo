## 行为型设计模式

### 1. 行为型设计模式有几种方法

> 行为型设计模式关注对象之间职责的分配。与结构型模式不同的是，它们不仅仅指定结构，还概述了对象之间消息传递/通信的模式。换句话说，它们帮助回答“如何在软件组件中运行行为？”
> 在软件工程中，行为型设计模式是识别对象之间常见通信模式并实现这些模式的设计模式。通过这样做，这些模式增加了执行这种通信的灵活性。

### 2. 维基百科的解释

### 行为型设计模式

行为型设计模式关注对象之间职责的分配。与结构型模式不同的是，它们不仅仅指定结构，还概述了对象之间消息传递/通信的模式。
换句话说，它们帮助回答“如何在软件组件中运行行为？”

* **责任任链模式**
    * **使用场景**
    - 当多个对象可以处理一个请求时，具体处理者在运行时刻自动确定。
    - 当需要动态指定处理某个请求的对象时。
    * **介绍**
    责任链模式通过将请求沿着处理者链传递，直到有一个处理者处理它。每个处理者都有机会处理请求，或者将其传递给下一个处理者。
    * **优点**
    - 降低耦合度。一个对象无需知道是其他哪一个对象处理其请求。
    - 增强了系统的灵活性，可以动态地添加或删除处理者。
    * **缺点**
    - 可能会导致请求处理的延迟，因为请求可能会被多个处理者传递。
    - 如果链条过长，可能会影响性能。
    
// 假设我们有一个日志记录系统，需要根据日志级别（如 INFO、DEBUG、ERROR）来记录日志。
// 我们可以使用责任链模式来实现不同级别的日志记录器，每个记录器处理特定级别的日志，并将其他级别的日志传递给下一个记录器。
// 责任链（Chain of Responsibility）设计模式的本质是将请求沿着处理链传递，直到有一个处理器处理它。
// 每个处理器都包含对下一个处理器的引用，如果当前处理器不能处理请求，它会将请求传递给下一个处理器。

> 在面向对象设计中，责任链模式是一种设计模式，由一系列命令对象和一系列处理对象组成。
> 每个处理对象包含定义它可以处理的命令对象类型的逻辑；其余的传递给链中的下一个处理对象。

责任链模式通过将请求沿着处理者链传递，直到有一个处理者处理它。每个处理者都有机会处理请求，或者将其传递给下一个处理者。通过这种方式，可以动态地指定处理某个请求的对象，提高系统的灵活性和可维护性。这个示例展示了如何使用责任链模式实现一个简单的支付系统。


* **命令模式**
    * **使用场景**
    - 当需要对操作进行参数化时。
    - 当需要将操作放入队列中执行或记录日志时。
    - 当需要支持撤销和恢复操作时。
    * **介绍**
    命令模式将请求封装成对象，使得可以用不同的请求对客户进行参数化。命令模式还支持撤销操作。
    * **优点**
    - 将调用操作的对象与实现操作的对象解耦。
    - 容易扩展新的命令。
    * **缺点**
    - 可能会导致系统中类的数量增加。
    > 一个通用的例子是你在餐馆点餐。你（即 `Client`）要求服务员（即 `Invoker`）带来一些食物（即 `Command`），服务员只是将请求转发给厨师（即 `Receiver`），厨师知道如何烹饪。
    > 另一个例子是你（即 `Client`）使用遥控器（即 `Invoker`）打开（即 `Command`）电视（即 `Receiver`）。
    > 允许你将动作封装在对象中。这个模式的关键思想是提供一种手段，将客户端与接收者解耦。
    > 在面向对象编程中，命令模式是一种行为设计模式，其中一个对象用于封装执行操作或触发事件所需的所有信息。这些信息包括方法名称、拥有该方法的对象以及方法参数的值。

    首先，我们有一个接收者，它实现了可以执行的每个动作。

    命令模式将请求封装成对象，使得可以用不同的请求对客户进行参数化。通过这种方式，可以在不修改现有类的情况下，为对象添加新的功能，例如支持撤销操作。这个示例展示了如何使用命令模式控制灯的开关，并支持撤销操作。

* **迭代器模式**
    * **使用场景**
    - 当需要访问一个聚合对象的内容而无需暴露其内部表示时。
    - 当需要为聚合对象提供多种遍历方式时。
    * **介绍**
    迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而不暴露其内部表示。
    * **优点**
    - 支持以不同方式遍历一个聚合对象。
    - 迭代器简化了聚合类。
    * **缺点**
    - 增加了类的数量。

* **中介者模式**
    * **使用场景**
    - 当对象之间存在复杂的引用关系，导致它们之间的依赖关系结构混乱且难以复用时。
    - 当需要通过一个中介对象来封装多个对象之间的交互时。
    * **介绍**
    中介者模式定义一个中介对象来封装一系列对象之间的交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
    * **优点**
    - 降低了对象之间的耦合性，使得对象易于独立地被复用。
    - 将对象之间的交互抽象化，使得对象之间的交互更加灵活。
    * **缺点**
    - 中介者会膨胀得很大，变得复杂难以维护。

* **备忘录模式**
    * **使用场景**
    - 当需要保存对象的某个状态，以便在适当的时候恢复时。
    - 当使用命令模式实现撤销操作时。
    * **介绍**
    备忘录模式在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后恢复对象到原先保存的状态。
    * **优点**
    - 提供了一种恢复状态的机制，使得用户可以方便地恢复到某个历史状态。
    - 实现了信息的封装，使得用户不需要关心状态的保存细节。
    * **缺点**
    - 资源消耗较大，如果需要保存的状态过多，可能会占用较多的内存。

* **观察者模式**
    * **使用场景**
    - 当一个对象的改变需要同时改变其他对象时。
    - 当一个对象必须通知其他对象，而它又不能假定其他对象是谁时。
    * **介绍**
    观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。当主题对象发生变化时，它的所有依赖者（观察者）都会收到通知并更新。
    * **优点**
    - 观察者和被观察者之间是抽象耦合的。
    - 建立一套触发机制。
    * **缺点**
    - 如果一个被观察者对象有很多的直接和间接观察者，将所有的观察者都通知到会花费很多时间。
    - 如果在观察者和被观察者之间有循环依赖，可能会导致系统崩溃。

* **访问者模式**
    * **使用场景**
    - 当需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作“污染”这些对象的类时。
    - 当对象结构比较稳定，但经常需要在此对象结构上定义新的操作时。
    * **介绍**
    访问者模式表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。
    * **优点**
    - 增加新的操作很容易。
    - 访问者模式将有关行为集中到一个访问者对象中。
    * **缺点**
    - 增加新的元素类很困难。
    - 破坏了类的封装性。

* **策略模式**
    * **使用场景**
    - 当一个系统需要动态地在几种算法中选择一种时。
    - 当一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现时。
    * **介绍**
    策略模式定义了一系列算法，并将每一个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。
    * **优点**
    - 算法可以自由切换。
    - 避免使用多重条件判断。
    * **缺点**
    - 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。

* **状态模式**
    * **使用场景**
    - 当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时。
    - 当一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。
    * **介绍**
    状态模式允许一个对象在其内部状态改变时改变它的行为。对象看起来好像修改了它的类。
    * **优点**
    - 将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。
    - 使得状态转换显式化。
    * **缺点**
    - 状态模式的使用必然会增加系统类和对象的个数。
    - 状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。

* **模板方法模式**
    * **使用场景**
    - 当一个算法的整体结构已经确定，但某些步骤的具体实现可以由子类来完成时。
    - 当多个子类有公有的方法，并且逻辑基本相同时。
    * **介绍**
    模板方法模式定义了一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
    * **优点**
    - 提高代码复用性。
    - 提高了扩展性。
    * **缺点**
    - 每一个不同的实现都需要一个子类来实现，导致类的个数增加。
    - 增加了系统的复杂性。