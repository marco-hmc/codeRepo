# cpp设计模式-入门

> marco

[toc]

> 本文主要参考资料为[设计模式](https://github.com/me115/design_patterns)\ [uml类图](https://segmentfault.com/a/1190000039232402)
>
> 本文配套[仓库](https://github.com/marco-hmc/cpp_design_patterns_tutorial) (未完成)
>
> 估计阅读耗时: 10h+

## 1. UML类图和时序图

统一建模语言（Unified Modeling Language，缩写UML）是非专利的第三代建模和规约语言。UML是一种开放的方法，**用于说明、可视化、构建和编写**一个正在开发的、面向对象的、软件密集系统的制品的开放方法。

### 1.1 uml类图初认识

![image-20220212094512948](https://s2.loli.net/2022/02/12/V2ET5IMfirjdu4w.png)

* 车的类图结构为<<abstract>>，表示车是一个抽象类；
* 它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示；
* 小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；
* 小汽车与发动机之间是组合关系，使用带实心箭头的实线表示；
* 学生与班级之间是聚合关系，使用带空心箭头的实线表示；
* 学生与身份证之间为关联关系，使用一根实线表示；
* 学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示；

### 1.2 uml中类的关系

uml中类的关系总共可以分为6类, 其中`泛化关系-实现关系`\ `聚合关系- 组合关系`\ `关联关系-依赖关系` 两两相近, 相近关系之间的区别更多地在于实现方式而不是严格的逻辑定义. 

* 比如说在`泛化关系-实现关系`中, 以`车-卡车`为例子, 如果车是抽象类, 则是实现关系; 如果车不是抽象关系, 能独立存在, 则是泛化关系

* 比如说在`聚合关系-组合关系`中, 以`班级-学生`为例子, 如果学生在班级之外还有意义, 则是聚合关系; 如果学生在班级之外没有意义, 则为组合关系.

  > 其实更合适的例子为`班级-人`属于聚合关系; `班级-学生`为组合关系. 人聚起来就得到班级; 如果没有班级存在, 就没有了学生.
  >
  > ​	但是实际命名中, `班级-学生`有可能同时是聚合或者组合关系. 因为主体环境是在学校中, 用学生比用人命名更契合环境, 可学生除了班级之外, 也可能在学校类中存在意义. 因此`班级-学生`属于聚合关系还是组合关系, 取决于实际代码实现, 而非严格的逻辑定义.

* 比如说在`关联关系-依赖关系`中, 关联关系往往存在`一对一`或者`多对一`的映射关系, 如`乘车人-车票`和`学生-学校`; 而依赖关系则是一个对象在运行期间会用到另一个对象.

  > 以`A-B`为例子, 从代码的逻辑出发
  >
  > ​	在关联关系中, A一般以B的成员变量出现.
  >
  > ​	在依赖关系中, B在运行的时候需要调用A.

#### 1.2.1 泛化关系

* ***定义:*** is-a的关系; 概念与实例的关系
* ***例子:*** 自行车是车, 猫是动物
* ***uml中的表示:*** 
  * 一条空心箭头表示
  * ![image-20220212095740666](https://s2.loli.net/2022/02/12/QUntR6FrA53WqwO.png)
  * ![image-20220212100307127](https://s2.loli.net/2022/02/12/GlB5gzXRhY9pN72.png)

#### 1.2.2 实现关系

* ***定义:*** is-a的关系; 从抽象类到继承抽象的类; 也是概念到实例
* ***例子:*** 车-小汽车, 车-自行车
* ***备注:*** 与泛化关系的区别在于, 这里的概念一定是抽象类
* ***uml中的表示:*** 
  * ![image-20220212100604275](https://s2.loli.net/2022/02/12/ASKspC2wokh3dGF.png)

#### 1.2.3 聚合关系

* ***定义:*** B由A组成; 但A可独立于B存在.
* ***例子:*** 班级-人
* ***uml中的表示:*** 
  * 一条空心菱形箭头
  * ![image-20220212100805441](https://s2.loli.net/2022/02/12/IKz5YdfXMmxAaFg.png)

#### 1.2.4 组合关系

* ***定义:*** B由A组成; A不可独立于B存在
* ***例子:*** 班级-学生, 部门-员工
* ***备注:*** 与聚合
* ***uml中的表示:*** 
  * 一条实心菱形箭头
  * ![image-20220212101147900](https://s2.loli.net/2022/02/12/Nd39U6VfEl4HxzR.png)

#### 1.2.5 关联关系

* ***定义:*** A和B存在关系; 一种静态关系;  常以成员变量形式出现
* ***例子:*** 学生-学校
* ***uml中的表示:*** 
  * 如果不强调方向, 则认为彼此知道; 如果强调方向, 如下图就表示A知道B, B不知道A
  * ![image-20220212112435906](https://s2.loli.net/2022/02/12/DZ6TpVUKBPqNQIb.png)

#### 1.2.6 依赖关系

* ***定义:*** A和B存在依赖;  常以被调用方式出现
* ***例子:*** 学生-学校
* ***备注:*** 避免设计双向依赖关系
* ***uml中的表示:*** 
  * ![image-20220212112618690](https://s2.loli.net/2022/02/12/AzWsv8tlhSmaprV.png)

### 1.3 时序图

***时序图的意义是什么:***

​	时序图,通常被开发者用来对一个场景下的对象交互建模. 它解释了一个系统中的不同部件之间,彼此是通过怎样的交互来实现的某个功能, 以及特定场景下交互发生的顺序.

​	是将一个产品使用的完整流程, 是一份不带说明的使用流程.

>  这部分我了解不深, 待有机会深入使用时再做了解. 因此附上, 我认为比较好的资料
>
> [时序图教程-附有示例的完成教程](https://zhuanlan.zhihu.com/p/342655946)
>
> [uml建模之时序图](https://www.cnblogs.com/ywqu/archive/2009/12/22/1629426.html)

###  

## 2. 创建型模式

创建型模式对类的实例化过程进行了抽象, 说白了就是将对象的`创建`和`使用`进行分离. 外部对于这些对象只需要知道其接口, 而不需要知道具体实现细节. 

而一般来说创建模式, 包含以下几种

* 简单工厂模式

  * 常用指数: 4

* 工厂方法模式

  * 常用指数: 5

* 抽象工厂模式

  * 常用指数: 5

* 建造者模式

  * 常用指数: 2

* 原型模式

  * 常用指数: 3

* 单例模式

  * 常用指数: 4

  这里我们以具有代表性的工厂模式和单例模式进行讲解

### 2.1 工厂模式

#### 2.1.1 相关概念

* ***动机:*** 将实现和创建分离， 因此如果后期需要添加功能时，仅在类处修改即可，不需要改外部使用这个类时的调用。
* ***适用情况:***
  * 一个系统不依赖于产品实例的创建、组合和表达
  * 同时有多于一个的产品
  * 不同的产品尽可能使用类似的接口
  * 如软件系统中更换界面主题时，按钮、文本框、背景等产品的使用是相对固定的。只需要替换其产品具体实现即可。
* ***不足:***
  * 不便于修改产品的层级结构。

#### 2.1.2 实际例子

* ***时序图:***

  ![image-20220212131157096](https://s2.loli.net/2022/02/12/zwiC4T6GIx1QAX8.png)

* ***uml图:***

  ![image-20220212131137755](https://s2.loli.net/2022/02/12/8ZRNYQpwEmArHPt.png)

#### 2.1.3 总结

* ***工厂模式体现开闭原则的倾斜性：***倾斜性在于便于扩展产品族、不便于增加新的产品层级。
  * 增加产品族：对于换应用主题的场景，不需要修改任何其他代码，只需要增加新主题的实现即可。
  * 不便于产品层级：同样换应用主题，可如果哪天假如说win更新了，菜单栏和进程管理器相关（如进程管理器固定在菜单栏中），现在进程管理器隶属于菜单栏中，以往所有的菜单栏工厂都需要修改兼容进程管理器。这时候不是对修改封闭的。

### 2.2 单例模式

#### 2.2.1 相关概念

* ***动机：***对于系统中的某些类来说，有且只能有一个实例。而这个只能有一个，有时候是限制于应用场景，如打印机服务；有时候是出于设计理念，系统只能有一个窗口管理器。
* ***适用情况：***如打印机任务，你可以反复创建和提交打印请求，但是有且只能有一个正在进行的打印任务；一个系统也只能够拥有一个窗口管理器、文件系统；一个系统只能有一个计时工具。
* ***不足：***
  * 不便于扩展，这是因为单例模式缺乏抽象
  * 违背单一职责原则，往往单例都是既充当了工厂角色，又充当了产品角色。怎么创建，怎么使用都是这个类说了算。
  * 单例实例相对臃肿，有可能因为其实例长时间不被利用，被java中的自动垃圾回收机制进行销毁。造成状态的丢失

#### 2.2.2 实际例子

* ***时序图***

  ![image-20220212133443736](https://s2.loli.net/2022/02/12/UGi7It51BCs4rwO.png)

* ***uml图***

  ![image-20220212133456329](https://s2.loli.net/2022/02/12/ePXMA3CO1rdlmuk.png)

#### 2.3.3 总结

* 系统只需要一个实例对象
* 它必须提供一个静态的自行创建的方法，该方法加入判断，从而保证实例唯一。而不是通过依赖外接正确使用它，避免不必要的修改外部代码。
* 为了避免外部强行对其实例化，还需要将构造函数设为私有。
* 缺点就只有缺乏抽象，职责过重。

###  

## 3. 结构型模式

结构型模式描述如何将类或者对象的内部之间进行结合，好比搭积木。结构模型一般又分为`类结构模式`和`对象结构模式`。

* `类结构模式`：这种模式关心类的组合，由多个类组合成一个更大的系统，在类结构模型中一般只存在泛化(继承)关系和实现关系。
* `对象结构型模式`：这种模式关心类与对象的组合，通过关联关系使得在一个类中定义另一个类的实例对象。不同对象之间多为关联关系。

根据合成复用原则，应该尽量使用关联关系来代替继承关系，因此结构性模式常以`对象结构型模式`为主。

**包含模式**

- 适配器模式(Adapter)

  * 常用指数：4

- 桥接模式(Bridge)

  * 常用指数：3

- 组合模式(Composite)

  * 常用指数：4

- 装饰模式(Decorator)

  * 常用指数：3

- 外观模式(Facade)

  * 常用指数：5

- 享元模式(Flyweight)

  * 常用指数：1

- 代理模式(Proxy)

  * 常用指数：4

  这里以具有代表性的适配器模式和外观模式进行讲解。

### 3.1 适配器模式

#### 3.1.1 相关概念

* ***动机:*** 就是电源适配器或者称之为变压器的思想，已有的工具接口与系统不统一，那就为这个工具创建一个适配器，这样一来就可以保证系统的接口不发生较大变化，又不用修改工具内部。

  * `类适配器模式：`适配器类实现了目标抽象类接口并继承了适配者类，并在目标抽象类的实现方法中调用所继承的适配者类的方法
  * `对象适配器模式：`适配器类继承了目标抽象类并定义了一个适配者类的对象实例，在所继承的目标抽象类方法中调用适配者类的相应业务方法。

* ***适用情况:***

  * 比如说A公司要使用B公司的技术（如人脸识别技术等）进行二次开发，A公司本身是有自己的人脸识别技术的，但是出于某种因素，要有别人的，这时候别人的接口可能就不是自己所需要的。这时候就需要适配器

    > 适配器这里可以让别人的接口通过包装，变成自己想要的。
    >
    > 因为A-/->B(B无法直接使用A)，
    >
    > ​	要么就是A'-> B' (略微改变A和B)
    >
    > ​	要么就是A->适配器->B (增加适配器)
    >
    > 后者方法就是适配器，多数情况比第一个好。

* ***不足:***

  * `类适配器模式`
    * 在很多编程语言中，不能同时适配多个适配者类。即每个适配者，都需要单独设计一个适配器。
  * `对象适配器模式`
    * 适配者类的方法很难置换

#### 3.1.2 实际例子

* ***时序图：***

  ![image-20220212143959219](https://s2.loli.net/2022/02/12/uHYWEUrJCIfPemS.png)

* ***uml类图：***

  * *对象适配器*

    ![image-20220212144036929](https://s2.loli.net/2022/02/12/LdEjsoxtIbS3K7D.png)

  * *类适配器*

    ![image-20220212144053959](https://s2.loli.net/2022/02/12/vQG5TIz4WlgKF8E.png)

#### 3.1.3 总结

* 适配器模式的主要优点是将目标类和适配者类解耦，增加了类的透明性和复用性，同时系统的灵活性和扩展性都非常好，更换适配器或者增加新的适配器都非常方便，符合“开闭原则”；
* 系统需要使用现有的类，而这些类的接口不符合系统的需要；想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类一起工作。

### 3.2 外观模式

#### 3.2.1 相关概念

* ***动机:*** 提供一个中介、门面服务；外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统的一组接口提供一个一致的界面。
* ***适用情况:***
  * 例如系统api包装，系统api往往是具有高自由度、操作性的，但我们实际情况不需要用得这么复杂，只需要一个简单接口。而且用户也可以越过外观类直接访问子系统。
* ***不足:***
  * 不够灵活，用户对子系统的访问需要通过外观（中介），但这也是为了简洁的折衷方法
  * 可能违背开闭原则，增加新的子系统可能需要修改外观类。

#### 3.2.2 实际例子

* ***时序图：***

  ![image-20220212145931198](https://s2.loli.net/2022/02/12/GdeSHmrZKwu5fb2.png)

* ***uml类图：***

  ![image-20220212145947147](https://s2.loli.net/2022/02/12/e42zMnFgiOjHqYP.png)

#### 3.2.3 总结

* 外观模式包含两个角色：外观角色是在客户端直接调用的角色，在外观角色中可以知道相关的(一个或者多个)子系统的功能和责任，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理；在软件系统中可以同时有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能。

###  

## 4. 行为型模式

行为模式是在不同对象之间划分责任和算法的抽象化。不仅关注类和对象的结构，还关注他们之间的相互作用。

- `类行为型模式：`类的行为型模式使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责。
- `对象行为型模式：`对象的行为型模式则使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式。

- 职责链模式(Chain of Responsibility)

  * 重要程度：3

- 命令模式(Command)

  * 重要程度：4

- 解释器模式(Interpreter)

  * 重要程度：1

- 迭代器模式(Iterator)

  * 重要程度：5

- 中介者模式(Mediator)

  * 重要程度：2

- 备忘录模式(Memento)

  * 重要程度：2

- 观察者模式(Observer)

  * 重要程度：5

- 状态模式(State)

  * 重要程度：3

- 策略模式(Strategy)

  * 重要程度：4

- 模板方法模式(Template Method)

  * 重要程度：3

- 访问者模式(Visitor)

  * 重要程度：1

  这里选择具有代表性的观察者模式进行讲解。

### 4.1 观察者模式

#### 4.1.1 相关概念

* ***动机:*** 建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展，这就是观察者模式的模式动机。
* ***适用情况:***
  * 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。
  * 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。
  * 一个对象必须通知其他对象，而并不知道这些对象是谁。
  * 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。
  * 如某电子商务网站可以在执行发送操作后给用户多个发送商品打折信息，某团队战斗游戏中某队友牺牲将给所有成员提示等等，凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。
* ***不足:***
  * 如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。
  * 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。
  * 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

#### 4.1.2 实际例子

***时序图：***

![image-20220212151925213](https://s2.loli.net/2022/02/12/62yFvQS5b7ZhjVd.png)

***uml类图：***

![image-20220212151941571](https://s2.loli.net/2022/02/12/n2drlNICEkbmGxD.png)

