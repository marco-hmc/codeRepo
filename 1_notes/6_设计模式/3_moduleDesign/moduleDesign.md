## 模块设计
* 和业务不相关，聚焦于某个通用模块的实现。

### 1. 事务
除了数据库，事务的概念还广泛应用于其他领域。事务的核心思想是确保一组操作要么全部成功，要么全部失败，从而保证系统的一致性和完整性。以下是一些具有事务概念的领域和示例：

1. 文件系统
    - **文件操作**：在文件系统中，事务可以用于确保一组文件操作（如文件写入、删除、移动等）要么全部成功，要么全部失败。例如，某些文件系统支持事务性文件操作，以确保在系统崩溃或电源故障时不会导致文件损坏。

2. 消息队列
    - **消息处理**：在消息队列系统中，事务可以用于确保消息的可靠传递和处理。例如，Apache Kafka 和 RabbitMQ 等消息队列系统支持事务性消息处理，以确保消息要么被成功处理并确认，要么在失败时重新处理。

3. 分布式系统
    - **分布式事务**：在分布式系统中，事务可以用于确保跨多个服务或节点的一组操作要么全部成功，要么全部失败。例如，分布式数据库和微服务架构中常用的两阶段提交（2PC）和三阶段提交（3PC）协议。

4. 命令模式
    - **命令执行**：在命令模式中，事务可以用于确保一组命令的执行要么全部成功，要么在失败时回滚所有操作。例如，命令模式中的撤销（Undo）和重做（Redo）功能。

5. 业务流程管理
    - **工作流引擎**：在业务流程管理系统中，事务可以用于确保一组业务流程步骤要么全部成功，要么在失败时回滚到初始状态。例如，工作流引擎（如 Camunda 和 Activiti）支持事务性工作流处理。

6. 电子商务
    - **订单处理**：在电子商务系统中，事务可以用于确保订单处理的各个步骤（如库存检查、支付处理、订单确认等）要么全部成功，要么在失败时回滚所有操作。

7. 金融系统
    - **支付和结算**：在金融系统中，事务可以用于确保支付和结算操作的原子性。例如，银行转账操作需要确保从一个账户扣款和向另一个账户存款要么全部成功，要么在失败时回滚。

事务的概念不仅限于数据库，还广泛应用于文件系统、消息队列、分布式系统、命令模式、业务流程管理、电子商务和金融系统等领域。事务的核心思想是确保一组操作要么全部成功，要么全部失败，从而保证系统的一致性和完整性。通过在这些领域中应用事务，可以提高系统的可靠性和稳定性。

### 2. 事务怎么实现？
不管是什么场景下的业务，其本质都是这个范式。
```cpp
beginTransaction();
try {
    // business ...
    commitTransaction();
} catch (const std::exception& e) {
    rollbackTransaction();
}
```

* `beginTransaction()`
    用于记录消息，如果回滚，回滚到那个阶段
* `commitTransaction()`
    用于提交消息，因为有可能执行失败，因此之前的写入操作都不是实际写入，直到commit阶段才完成最终写入。
* `rollbackTransaction()`
    回滚数据。
