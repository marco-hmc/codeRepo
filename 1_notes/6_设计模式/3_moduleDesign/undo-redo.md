
#### undo-redo
Undo/Redo是业务场景中重要的功能之一，Undo/Redo功能常用的实现方式有如下几种：
（1）基于Command模式的Undo/Redo

实现Undo/Redo功能的经典方法是运用Comamnd设计模式，它将每步操作作为一个命令对象，并提供相应的Undo接口，如下所示：

Class Icommand
{
  void Do();
  void Undo();
};

其中Do函数执行功能，Undo函数回退功能。这样就把命令给实体化了，只要将命令对象给保存下来，需要撤销时执行Undo函数，重做时执行Do函数即可，其实现细节如下下：

    申请两个Stack来保存命令对象：UndoStack和RedoStack
    执行命令时，将命令序列化为Command对象，执行Do方法，存入UndoStack，清空RedoStack
    撤销命令时，从UndoStack中取出命令，执行Undo方法，存入RedoStack
    重做命令时，从RedoStack中取出命令，执行Do方法，存入UndoStack

这种方式的重点时Undo()接口的实现，对于一个命令，其Undo可以分为两种情况，一种是可逆向的操作，这种情况只需要执行一个反向操作就能回退，例如旋转一定角度的逆向操作是简单的反向旋转。另一种是更为复杂的操作，无法简单的逆操作，这个时候就需要备份数据在操作前的状态，Undo时恢复数据，例如两个体做完布尔操作，就很难通过逆操作回退，而不得不备份操作前的数据。

灵活运用Comamnd模式可以应对各种Undo操作，但是这种方式Undo和具体的命令业务会耦合在一起，一个可以Undo的操作越具体，它和实现应用的耦合关系就越紧，抽象性就越差，也就越难以复用。
（2）基于对象序列化的Undo/Redo

基于序列化对象的实现方案，调用命名前，将整个业务对象的所有Field序列化，并保存在UndoStack中。在Undo时，将保存在UndoStack中的序列化的值读出来，对现有的业务对象进行数值还原。由于使用对象序列化的方式来保存对象的历史。所以当UndoStack比较深，或是业务对象比较大的时候会占用比较多的内存，性能上也不尽如人意。但是这种Undo实现方式通用性较好。所以适用范围还是不小的。序列化可以按增量备份的方式进行保存，并且可以通过数据压缩的方式进行一定的优化，但是实现起来相对复杂。
（3）混合方式

为了解决上面两种Undo实现方式的缺点，既保证通用性，又能减少资源占用。可以将上面的两种方式结合起来， 当然这种方式也有不好的地方，由于抽象程度比较高，所以这种Undo机制并不能很好地和业务逻辑契合。

WK平台的Undo/Redo和回滚功能是基于对象序列化实现的，Undo/Redo/回滚操作高度业务依赖业务场景，实现细节较为困难，为了将Undo/Redo尽量和业务场景剥离开来，需要有一个抽象的数层。这个抽象的数据层只是关注数据的Undo/Redo，而并不关心这些数据属于什么对象，什么命令，这个抽象层就是Stream。

Stream是对流数据的抽象，通过Infield/ outfield将对象的数据备份到流上。UndoMemoryStream是用于Undo/Redo和回滚的流数据，其底层数据结构是pageBuffer，基于页管理的内存缓存。pageBuffer是一块块大小固定的缓存块，UndoMemoryStream负责管理这些缓存块，并将序列化数据写在这些缓存块之中。
