# 第 2 章 重构的原则

## 2.5 重构的挑战

### 分支

分支合并本来就是一个复杂的问题,随着特性分支存在的时间加长,合并的难度会指数上升.集成一个已经存在了 4 个星期的分支,较之集成存在了 2 个星期的分支,难度可不止翻倍.所以很多人认为,应该尽量缩短特性分支的生存周期,比如只有一两天.还有一些人(比如我本人)认为特性分支的生命还应该更短,我们采用的方法叫作持续集成(Continuous Integration,CI),也叫"基于主干开发"(Trunk-Based Development).在使用 CI 时,每个团队成员每天至少向主线集成一次.这个实践避免了任何分支彼此差异太大,从而极大地降低了合并的难度.不过 CI 也有其代价:你必须使用相关的实践以确保主线随时处于健康状态,必须学会将大功能拆分成小块,还必须使用特性开关(feature toggle,也叫特性旗标,feature flag)将尚未完成又无法拆小的功能隐藏掉.

CI 的粉丝之所以喜欢这种工作方式,部分原因是它降低了分支合并的难度,不过最重要的原因还是 CI 与重构能良好配合.重构经常需要对代码库中的很多地方做很小的修改(例如给一个广泛使用的函数改名),这样的修改尤其容易造成合并时的语义冲突.采用特性分支的团队常会发现重构加剧了分支合并的困难,并因此放弃了重构,这种情况我们曾经见过多次.CI 和重构能够良好配合,所以 Kent Beck 在极限编程中同时包含了这两个实践.

我并不是在说绝不应该使用特性分支.如果特性分支存在的时间足够短,它们就不会造成大问题.(实际上,使用 CI 的团队往往同时也使用分支,但他们会每天将分支与主线合并.)对于开源项目,特性分支可能是合适的做法,因为不时会有你不熟悉(因此也不信任)的程序员偶尔提交修改.但对全职的开发团队而言,特性分支对重构的阻碍太严重了.即便你没有完全采用 CI,我也一定会催促你尽可能频繁地集成.而且,用上 CI 的团队在软件交付上更加高效,我真心希望你认真考虑这个客观事实[Forsgren et al].

### 测试

不会改变程序可观察的行为,这是重构的一个重要特征.如果仔细遵循重构手法的每个步骤,我应该不会破坏任何东西,但万一我犯了个错误怎么办?(呃,就我这个粗心大意的性格来说,请去掉"万一"两字.)人总会有出错的时候,不过只要及时发现,就不会造成大问题.既然每个重构都是很小的修改,即便真的造成了破坏,我也只需要检查最后一步的小修改__就算找不到出错的原因,只要回滚到版本控制中最后一个可用的版本就行了.

这里的关键就在于"快速发现错误".要做到这一点,我的代码应该有一套完备的测试套件,并且运行速度要快,否则我会不愿意频繁运行它.也就是说,绝大多数情况下,如果想要重构,我得先有可以自测试的代码[mf-stc].

缺乏测试的现状还催生了另一种重构的流派:只使用一组经过验证是安全的重构手法.这个流派要求严格遵循重构的每个步骤,并且可用的重构手法是特定于语言的.使用这种方法,团队得以在测试覆盖率很低的大型代码库上开展一些有用的重构.这个重构流派比较新,涉及一些很具体/特定于编程语言的技巧与做法,行业里对这种方法的介绍和了解都还不足,因此本书不对其多做介绍.(不过我希望未来在我自己的网站上多讨论这个主题.感兴趣的读者可以查看 Jay Bazuzi 关于如何在 C++中安全地运用提炼函数(106)的描述[Bazuzi],借此获得一点儿对这个重构流派的了解.)

### 遗留代码

这个问题没有简单的解决办法,我能给出的最好建议就是买一本<修改代码的艺术>[Feathers],照书里的指导来做.别担心那本书太老,尽管已经出版十多年,其中的建议仍然管用.一言以蔽之,它建议你先找到程序的接缝,在接缝处插入测试,如此将系统置于测试覆盖之下.你需要运用重构手法创造出接缝__这样的重构很危险,因为没有测试覆盖,但这是为了取得进展必要的风险.在这种情况下,安全的自动化重构简直就是天赐福音.如果这一切听起来很困难,因为它确实很困难.很遗憾,一旦跌进这个深坑,没有爬出来的捷径,这也是我强烈倡导从一开始就写能自测试的代码的原因.

### 数据库

在本书的第 1 版中,我说过数据库是"重构经常出问题的一个领域".然而在第 1 版问世之后仅仅一年,情况就发生了改变:我的同事 Pramod Sadalage 发展出一套渐进式数据库设计[mf-evodb]和数据库重构[Ambler &amp; Sadalage]的办法,如今已经被广泛使用.这项技术的精要在于:借助数据迁移脚本,将数据库结构的修改与代码相结合,使大规模的/涉及数据库的修改可以比较容易地开展.

假设我们要对一个数据库字段(列)改名.和改变函数声明(124)一样,我要找出结构的声明处和所有调用处,然后一次完成所有修改.但这里的复杂之处在于,原来基于旧字段的数据,也要转为使用新字段.我会写一小段代码来执行数据转化的逻辑,并把这段代码放进版本控制,跟数据结构声明与使用代码的修改一并提交.此后如果我想把数据库迁移到某个版本,只要执行当前数据库版本与目标版本之间的所有迁移脚本即可.

跟通常的重构一样,数据库重构的关键也是小步修改并且每次修改都应该完整,这样每次迁移之后系统仍然能运行.由于每次迁移涉及的修改都很小,写起来应该容易;将多个迁移串联起来,就能对数据库结构及其中存储的数据做很大的调整.

与常规的重构不同,很多时候,数据库重构最好是分散到多次生产发布来完成,这样即便某次修改在生产数据库上造成了问题,也比较容易回滚.比如,要改名一个字段,我的第一次提交会新添一个字段,但暂时不使用它.然后我会修改数据写入的逻辑,使其同时写入新旧两个字段.随后我就可以修改读取数据的地方,将它们逐个改为使用新字段.这步修改完成之后,我会暂停一小段时间,看看是否有 bug 冒出来.确定没有 bug 之后,我再删除已经没人使用的旧字段.这种修改数据库的方式是并行修改(Parallel Change,也叫扩展协议/expand-contract)[mf-pc]的一个实例.

## 2.6 重构/架构和 YAGNI

重构极大地改变了人们考虑软件架构的方式.在我的职业生涯早期,我被告知:在任何人开始写代码之前,必须先完成软件的设计和架构.一旦代码写出来,架构就固定了,只会因为程序员的草率对待而逐渐腐败.

这种设计方法有很多名字:简单设计/增量式设计或者 YAGNI[mf-yagni]__"你不会需要它"(you arenʼt going to need it)的缩写.YAGNI 并不是"不做架构性思考"的意思,不过确实有人以这种欠考虑的方式做事.我把 YAGNI 视为将架构/设计与开发过程融合的一种工作方式,这种工作方式必须有重构作为基础才可靠.

采用 YAGNI 并不表示完全不用预先考虑架构.总有一些时候,如果缺少预先的思考,重构会难以开展.但两者之间的平衡点已经发生了很大的改变:如今我更倾向于等一等,待到对问题理解更充分,再来着手解决.演进式架构[Ford et al.]是一门仍在不断发展的学科,架构师们在不断探索有用的模式和实践,充分发挥迭代式架构决策的能力.

## 2.7 重构与软件开发过程

读完前面"重构的挑战"一节,你大概已经有这个印象:重构是否有效,与团队采用的其他软件开发实践紧密相关.重构起初是作为极限编程(XP)[mf-xp]的一部分被人们采用的,XP 本身就融合了一组不太常见而又彼此关联的实践,例如持续集成/自测试代码以及重构(后两者融汇成了测试驱动开发).

极限编程是最早的敏捷软件开发方法[mf-nm]之一.在一段历史时期,极限编程引领了敏捷的崛起.如今已经有很多项目使用敏捷方法,甚至敏捷的思维已经被视为主流,但实际上大部分"敏捷"项目只是徒有其名.要真正以敏捷的方式运作项目,团队成员必须在重构上有能力/有热情,他们采用的开发过程必须与常规的/持续的重构相匹配.

重构的第一块基石是自测试代码.我应该有一套自动化的测试,我可以频繁地运行它们,并且我有信心:如果我在编程过程中犯了任何错误,会有测试失败.这块基石如此重要,我会专门用一章篇幅来讨论它.

如果一支团队想要重构,那么每个团队成员都需要掌握重构技能,能在需要时开展重构,而不会干扰其他人的工作.这也是我鼓励持续集成的原因:有了 CI,每个成员的重构都能快速分享给其他同事,不会发生这边在调用一个接口那边却已把这个接口删掉的情况;如果一次重构会影响别人的工作,我们很快就会知道.自测试的代码也是持续集成的关键环节,所以这三大实践__自测试代码/持续集成/重构__彼此之间有着很强的协同效应.

有这三大实践在手,我们就能运用前一节介绍的 YAGNI 设计方法.重构和 YAGNI 交相呼应/彼此增效,重构(及其前置实践)是 YAGNI 的基础,YAGNI 又让重构更易于开展:比起一个塞满了想当然的灵活性的系统,当然是修改一个简单的系统要容易得多.在这些实践之间找到合适的平衡点,你就能进入良性循环,你的代码既牢固可靠又能快速响应变化的需求.

有这三大核心实践打下的基础,才谈得上运用敏捷思想的其他部分.持续交付确保软件始终处于可发布的状态,很多互联网团队能做到一天多次发布,靠的正是持续交付的威力.即便我们不需要如此频繁的发布,持续集成也能帮我们降低风险,并使我们做到根据业务需要随时安排发布,而不受技术的局限.有了可靠的技术根基,我们能够极大地压缩"从好点子到生产代码"的周期时间,从而更好地服务客户.这些技术实践也会增加软件的可靠性,减少耗费在 bug 上的时间.

这一切说起来似乎很简单,但实际做起来毫不容易.不管采用什么方法,软件开发都是一件复杂而微妙的事,涉及人与人之间/人与机器之间的复杂交互.我在这里描述的方法已经被证明可以应对这些复杂性,但__就跟其他所有方法一样__对使用者的实践和技能有要求.

## 2.10 自动化重构

重构工具不仅需要理解和修改语法树,还要知道如何把修改后的代码写回编辑器视图.总而言之,实现一个体面的自动化重构手法,是一个很有挑战的编程任务.尽管我一直开心地使用重构工具,对它们背后的实现却知之甚少.

在静态类型语言中,很多重构手法会更加安全.假设我想做一次简单的函数改名(124):在 Salesman 类和 Server 类中都有一个叫作 addClient 的函数,当然两者各有其用途.我想对 Salesman 中的 addClient 函数改名,Server 类中的函数则保持不变.如果不是静态类型,工具很难识别调用 addClient 的地方到底是在使用哪个类的函数.Smalltalk 的 Refactoring Browser 会列出所有调用点,我需要手工决定修改哪些调用点.这个重构是不安全的,我必须重新运行所有测试.这样的工具仍然有用,但在 Java 中的函数改名(124)重构则可以是完全安全/完全自动的,因为在静态类型的帮助下,工具可以识别函数所属的类,所以它只会修改应该修改的那些函数调用点,对此我可以完全放心.

能借助语法树来分析和重构程序代码,这是 IDE 与普通文本编辑器相比具有的一大优势.但很多程序员又喜欢用得顺手的文本编辑器的灵活性,希望鱼与熊掌兼得.语言服务器(Language Server)是一种正在引起关注的新技术:用软件生成语法树,给文本编辑器提供 API.语言服务器可以支持多种文本编辑器,并且为强大的代码分析和重构操作提供了命令.

## 2.11 延展阅读

本书的第 1 版教很多人学会了重构,不过我的关注点是组织一本重构的参考书,而不是带领读者走过学习过程.如果你需要一本面向入门者的教材,我推荐 Bill Wake 的<重构手册>[Wake],其中包含了很多有用的重构练习.

很多重构的先行者同时也活跃于软件模式社区.Josh Kerievsky 在<重构与模式>[Kerievsky]一书中紧密连接了这两个世界.他审视了影响巨大的 GoF[gof]书中一些最有价值的模式,并展示了如何通过重构使代码向这些模式的方向演化.

本书聚焦讨论通用编程语言中的重构技巧.还有一些专门领域的重构,例如已经引起关注的<数据库重构>[Ambler &amp; Sadalage](由 Scott Ambler 和 Pramod Sadalage 所著)和<重构 HTML>[Harold](由 Elliotte Rusty Harold 所著).

尽管标题中没有"重构"二字,Michael Feathers 的<修改代码的艺术>[Feathers]也不得不提.这本书主要讨论如何在缺乏测试覆盖的老旧代码库上开展重构.
