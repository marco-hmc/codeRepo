---
title: "MySQL隔离级别"
layout: post
author: "Marco"
header-style: text
hidden: true
tags:
  - 数据库
---

## MySQL隔离级别

### 1. 基本概念

- ***为什么要有隔离？***

  ​	如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离；在实际运用中主要有四种隔离级别，分别是读未提交、不可重复读、可重复读、串行化。

- ***为什么要有不同的事务隔离级别？***

  ​	事务隔离级别的本质是通过锁来实现的，选择隔离级别越低的，锁的粒度也就越小，对其他事务的影响也就越少，相应速度也就越快。而在数据库的角度，并行事务一般会导致的冲突有三种，分别是脏读、不可重复读以及幻读如下表所示。
  | 事务隔离级别                 |   脏读   | 不可重复读 |   幻读   |
  | ---------------------------- | :------: | :--------: | :------: |
  | 读未提交（read-uncommitted） | 不可避免 |  不可避免  | 不可避免 |
  | 已提交读（read-committed）   |  可避免  |  不可避免  | 不可避免 |
  | 可重复读（repeatable-read）  |  可避免  |   可避免   | 不可避免 |
  | 串行化（serializable）       |  可避免  |   可避免   |  可避免  |

- ***什么是脏读、不可重复读、幻读？***

  > [参考](https://www.cnblogs.com/yubaolee/p/10398633.html#%E7%AC%AC%E4%B8%80%E7%B1%BB%E4%B8%A2%E5%A4%B1%E6%9B%B4%E6%96%B0%EF%BC%88Lost%20Update%EF%BC%89)

  - 脏读

    [![微信截图_20190223000611](https://s2.loli.net/2022/03/27/nJbx8vT379pYMX5.png)](https://img2018.cnblogs.com/blog/42655/201902/42655-20190223001813296-1087539034.png)

    ​	A事务执行过程中，B事务读取了A事务的修改。但是由于某些原因，A事务可能没有完成提交，发生RollBack了操作，则B事务所读取的数据就会是不正确的。这个未提交数据就是脏读（Dirty Read）。

  - 不可重复读

    ![微信截图_20190223004632](https://s2.loli.net/2022/03/27/PdpIJFzwMnXO7fH.png)

    ​	B事务读取了两次数据，在这两次的读取过程中A事务修改了数据，B事务的这两次读取出来的数据不一样。B事务这种读取的结果，即为不可重复读（Nonrepeatable Read）。

  - 幻读

    [![微信截图_20190223102400](https://s2.loli.net/2022/03/27/mjqTMzFX9uKG4sn.png)](https://img2018.cnblogs.com/blog/42655/201902/42655-20190223103301213-1545516085.png)

    ​	B事务读取了两次数据，在这两次的读取过程中A事务添加了数据，B事务的这两次读取出来的集合不一样。

- 四种隔离级别的简单介绍

  - 读未提交（Read Uncommitted）

    ​	在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别是最低的隔离级别，虽然拥有超高的并发处理能力及很低的系统开销，但很少用于实际应用。因为采用这种隔离级别只能防止第一类更新丢失问题，不能解决脏读，不可重复读及幻读问题。

  - 读已提交（Read Committed）

    ​	**数据的读取不加锁，数据的写入、修改、删除需要加行锁，可以克服脏读，但无法避免不可重复读**

    ​	这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别可以防止脏读问题，但会出现不可重复读及幻读问题。

  - 可重复读（Repeatable Read）

    ​	通过MVCC机制实现。	

    ​	这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。这种隔离级别可以防止除幻读外的其他问题。
  
    > 单纯加行锁是无法解决的，T2先读取x值，T1之后经过加锁、解锁步骤，更新x的值，提交事务。T2再读的话，读出来的是T1更新后的值，两次读取结果不一致。
    >
    > ​	![img](https://s2.loli.net/2022/03/27/dxJMSUyz5riel7N.png)
  
  - 可串行化（Serializable）
  
    ​	这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读、第二类更新丢失问题。在这个级别，可以解决上面提到的所有并发问题，但可能导致大量的超时现象和锁竞争，通常数据库不会用这个隔离级别，我们需要其他的机制来解决这些问题:乐观锁和悲观锁。

