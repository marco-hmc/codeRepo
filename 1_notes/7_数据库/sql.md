数据库
虽然也没啥可问的，但基本都提一嘴，答增删改查授权这些用一用，其他都不怎么用，往这个方向引大概率是想问索引，索引原理，有家电话让我说授权语句，这玩意谁记啊，不都现用现查，说了俩关键字顺序也没整对，后来还是给了个口头

八、数据库
数据库首先要学会 SQL 的使用，这里推荐《MySQL必知必会》。

数据库原理方面可以看看《数据库系统概念》，这本书挺厚的，包含了从 SQL 到数据库设计再到数据库原理、分布式数据库都有，可以挑着看，比如关系模型、数据库设计（三大范式）、数据磁盘存储和组织方式、索引、并发控制等。

当然了整个数据库最重要的还是索引和并发控制（锁、MVCC等），这部分也是面试常考的：

索引存储结构：B树、B+树索引、Hash索引

索引的使用：主键索引、覆盖索引、最左前缀原则、索引下推等

锁：乐观锁、悲观锁、表锁，行锁，意向锁，读锁，写锁等等

MySQL InnoDB MVCC 实现机制

存储引擎：InnoDB、MyISAM等，各自的优缺点

事务：ACID理论

这部分推荐两本书：

《高性能MySQL》
《MySQL技术内幕》
这两本主要对索引、innodb存储引擎、锁、并发控制讲得比较清楚，建议挑对应章节看。


问的比较多的是 redis;
基于 Redis 的面试题既可以聊算法与数据结构

*  高性能MySQL 
  *  本书深度讲解了mysql引擎架构、索引设计、SQL查询优化的实战技巧、复制、分片等原理，还有运维技能。适合精读。 
* 《 经典原版书库：数据库系统概念（英文精编版·第6版） 》
* 数据库的知识面试问的不多，但是数据库对于以后工作是肯定会用到的，如果有时间建议将基础打好，可以先看**数据库系统概念**，了解数据库的基础知识，然后阅读**mysql必知必会**这本书，可以帮助你快速学习 *mysql* 的基本语法。


* [MongoDB_实践]
* [MongoDB基础教程]
* [MongoDB开发使用手册]
* [MongoDB开发应用实践_潘凡]
* [MongoDB权威指南]
* [10 Key Performance Indicators for MongoDB]
* [u dont know mongodb]
* [MongoDB.in.Action(2011.12).Kyle.Banker.文字版]
* [O'Reilly:深入学习MongoDB(霍多罗夫).巨成等.扫描版]


* [Google MapReduce-中文版]
* [Google MapReduce-英文版osdi04]
* [NoSQL数据库笔谈]
* [The Google File System]
* [高性能MySQL(第2版)中文版.施瓦茨.扫描版](http://pan.baidu.com/s/1zpaWY)


[sqlite3-c++](https://www.runoob.com/sqlite/sqlite-update.html)

[sqlite](https://www.geeksforgeeks.org/sql-using-c-c-and-sqlite/)

## 1. login
* `sudo systemctl start mysql`
* `sudo systemctl stop mysql`
* `mysql -u [username] -p`
* `sudo mysql -u root`
sudo gedit /etc/mysql/my.cnf

 show databases;
  use <数据库名>

  CREATE DATABASE mysql_shiyan;

CREATE TABLE employee (id int(10),name char(20),phone int(12));

DROP TABLE table_name;

    FOREIGN KEY(sid) REFERENCES student(sid),
    FOREIGN KEY(cid) REFERENCES course(cid)

在 MySQL 中，通常有这几种约束：

约束类型：	主键	默认值	唯一	外键	非空
关键字：	PRIMARY KEY	DEFAULT	UNIQUE	FOREIGN KEY	NOT NULL

source /home/shiyanlou/Desktop/MySQL-03-01.sql;

主键（PRIMARY KEY）作为数据表中一行数据的唯一标识符，在一张表中通过主键就能准确定位到某一行数据，因此主键十分重要，它不能有重复记录且不能为空。

在 MySQL-03-01.sql 中，这里有主键：
还有一种特殊的主键——复合主键。主键不仅可以是表中的一列，也可以由表中的两列或多列来共同标识，比如：

---
默认值约束 (DEFAULT) 规定，当有 DEFAULT 约束的列，插入数据为空时，将使用默认值。
people_num INT(10) DEFAULT 10,


---
关键字 LIKE 可用于实现模糊查询，常见于搜索功能中。

和 LIKE 联用的通常还有通配符，代表未知字符。SQL 中的通配符是 _ 和 % 。其中 _ 代表一个未指定字符，% 代表不定个未指定字符
---
SELECT name,age,salary,phone FROM employee ORDER BY salary DESC;
---
SELECT of_dpt,COUNT(proj_name) AS count_project FROM project GROUP BY of_dpt
HAVING of_dpt IN
(SELECT in_dpt FROM employee WHERE name='Tom');
---
SELECT id,name,people_num
FROM employee JOIN department
ON employee.in_dpt = department.dpt_name
ORDER BY id;

---
RENAME TABLE 原名 TO 新名字;

ALTER TABLE 原名 RENAME 新名;

ALTER TABLE 原名 RENAME TO 新名;

3.3.1 增加一列
在表中增加一列的语句格式为：

ALTER TABLE 表名字 ADD COLUMN 列名字 数据类型 约束;
或：
ALTER TABLE 表名字 ADD 列名字 数据类型 约束;

ALTER TABLE employee ADD weight INT(4) DEFAULT 120 AFTER age;

---

ALTER TABLE 表名字 ADD INDEX 索引名 (列名);

CREATE INDEX 索引名 ON 表名字 (列名);

在使用 SELECT 语句查询的时候，语句中 WHERE 里面的条件，会自动判断有没有可用的索引。

比如有一个用户表，它拥有用户名(username)和个人签名(note)两个字段。其中用户名具有唯一性，并且格式具有较强的限制，我们给用户名加上一个唯一索引；个性签名格式多变，而且允许不同用户使用重复的签名，不加任何索引。

这时候，如果你要查找某一用户，使用语句 select * from user where username=? 和 select * from user where note=? 性能是有很大差距的，对建立了索引的用户名进行条件查询会比没有索引的个性签名条件查询快几倍，在数据量大的时候，这个差距只会更大。

视图是从一个或多个表中导出来的表，是一种虚拟存在的表。它就像一个窗口，通过这个窗口可以看到系统专门提供的数据，这样，用户可以不用看到整个数据库中的数据，而只关心对自己有用的数据。

注意理解视图是虚拟的表：

数据库中只存放了视图的定义，而没有存放视图中的数据，这些数据存放在原来的表中；
使用视图查询数据时，数据库系统会从原来的表中取出对应的数据；
视图中的数据依赖于原来表中的数据，一旦表中数据发生改变，显示在视图中的数据也会发生改变；
在使用视图的时候，可以把它当作一张表。
创建视图的语句格式为：

CREATE VIEW 视图名(列a,列b,列c) AS SELECT 列1,列2,列3 FROM 表名字;

导入和导出

备份

mysqldump -u root 数据库名>备份文件名;   #备份整个数据库

mysqldump -u root 数据库名 表名字>备份文件名;  #备份整个表
##

# 3. 数据库
* [小林-数据库](https://www.xiaolincoding.com/mysql/base/how_select.html#mysql-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84)
* 并行事务引发的问题
  * 脏读
    * 如果一个事务'读到'了另一个'未提交事务修改过的数据',就意味着发生了'脏读'现象.
    * ![图片](https://img-blog.csdnimg.cn/img_convert/10b513008ea35ee880c592a88adcb12f.png)
  * 不可重复读
    * 在一个事务内多次读取同一个数据,如果出现前后两次读到的数据不一样的情况,就意味着发生了'不可重复读'现象.
    * ![图片](https://img-blog.csdnimg.cn/img_convert/f5b4f8f0c0adcf044b34c1f300a95abf.png)
  * 幻读
    * **在一个事务内多次查询某个符合查询条件的'记录数量',如果出现前后两次查询到的记录数量不一样的情况,就意味着发生了'幻读'现象.**
    * ![图片](https://img-blog.csdnimg.cn/img_convert/d19a1019dc35dfe8cfe7fbff8cd97e31.png)
* 数据库的四种隔离级别
  * 读未提交
    * 指一个事务还没提交时,它做的变更就能被其他事务看到;
  * 读已提交
    * 指一个事务提交之后,它做的变更才能被其他事务看到;
  * 可重复读
      * 指一个事务执行过程中看到的数据,一直跟这个事务启动时看到的数据是一致的,**MySQL InnoDB 引擎的默认隔离级别**;
  * 串行化
    * 会对记录加上读写锁,在多个事务对这条记录进行读写操作时,如果发生了读写冲突的时候,后访问的事务必须等前一个事务执行完成,才能继续执行;
    
#### (1) 关系型和非关系型数据库的区别(低频)
* 关系型数据库的优点
  1. 容易理解.因为它采用了关系模型来组织数据.
  2. 可以保持数据的一致性.
  3. 数据更新的开销比较小.
  4. 支持复杂查询(带where子句的查询)
* 非关系型数据库的优点
  1. 不需要经过sql层的解析,读写效率高.
  2. 基于键值对,数据的扩展性很好.
  3. 可以支持多种类型数据的存储,如图片,文档等等.
#### (2) 什么是非关系型数据库(低频)
非关系型数据库也叫nosql,采用键值对的形式进行存储.它的读写性能很高,易于扩展.例如Redis,Mongodb,hbase等等.

适合使用非关系型数据库的场景:
* 日志系统
* 地理位置存储
* 数据量巨大
* 高可用
#### (3) 说一下 MySQL 执行一条查询语句的内部执行过程?
* 连接器:客户端先通过连接器连接到 MySQL 服务器.
* 缓存:连接器权限验证通过之后,先查询是否有查询缓存,如果有缓存(之前执行过此语句)则直接返回缓存数据,如果没有缓存则进入分析器.
* 分析器:分析器会对查询语句进行语法分析和词法分析,判断 SQL 语法是否正确,如果查询语法错误会直接返回给客户端错误信息,如果语法正确则进入优化器.
* 优化器:优化器是对查询语句进行优化处理,例如一个表里面有多个索引,优化器会判别哪个索引性能更好.
* 执行器:优化器执行完就进入执行器,执行器就开始执行语句进行查询比对了,直到查询到满足条件的所有数据,然后进行返回.
#### (4) 数据库的索引类型
数据库的索引类型分为逻辑分类和物理分类<br>
逻辑分类:
* 主键索引 当关系表中定义主键时会自动创建主键索引.每张表中的主键索引只能有一个,要求主键中的每个值都唯一,即不可重复,也不能有空值.
* 唯一索引 数据列不能有重复,可以有空值.一张表可以有多个唯一索引,但是每个唯一索引只能有一列.如身份证,卡号等.
* 普通索引 一张表可以有多个普通索引,可以重复可以为空值
* 全文索引 可以加快模糊查询,不常用

物理分类:
* 聚集索引(聚簇索引) 数据在物理存储中的顺序跟索引中数据的逻辑顺序相同,比如以ID建立聚集索引,数据库中id从小到大排列,那么物理存储中该数据的内存地址值也按照从小到大存储.一般是表中的主键索引,如果没有主键索引就会以第一个非空的唯一索引作为聚集索引.一张表只能有一个聚集索引.
* 非聚集索引 数据在物理存储中的顺序跟索引中数据的逻辑顺序不同.非聚集索引因为无法定位数据所在的行,所以需要扫描两遍索引树.第一遍扫描非聚集索引的索引树,确定该数据的主键ID,然后到主键索引(聚集索引)中寻找相应的数据.
#### (5) 说一下事务是怎么实现的
https://blog.csdn.net/u013256816/article/details/103966510

https://www.cnblogs.com/takumicx/p/9998844.html

事务就是一组逻辑操作的集合.实现事务就是要保证可靠性和并发隔离,或者说,能够满足ACID特性的机制.而这些主要是靠日志恢复和并发控制实现的.

* 日志恢复:数据库里有两个日志,一个是redo log,一个是undo log.redo log记录的是已经成功提交的事务操作信息,用来恢复数据,保证事务的**持久性**.undo log记录的是事务修改之前的数据信息,用来回滚数据,保证事务的**原子性**.
* 并发控制:并发控制主要靠读写锁和MVCC(多版本并发控制)来实现.读写锁包括共享锁和排他锁,保证事务的**隔离性**.MVCC通过为数据添加时间戳来实现.

#### (6) MySQL怎么建立索引,怎么建立主键索引,怎么删除索引?
MySQL建立索引有两种方式:用alter table或者create index.
```
alter table table_name add primary key(column_list) #添加一个主键索引
alter table table_name add index (column_list)      #添加一个普通索引
alter table table_name add unique (column_list)     #添加一个唯一索引
```
```
create index index_name on table_name (column_list)   #创建一个普通索引
create unique index_name on table_name (column_list)  #创建一个唯一索引
```

Mysql删除索引同样也有两种方式:alter table 和 drop index
```
alter table table_name drop index index_name    #删除一个普通索引
alter table table_name drop primary key         #删除一个主键索引
```
```
drop index index_name on table table_name
```
#### (7) 索引的优缺点,什么时候使用索引,什么时候不能使用索引(重点)
https://www.cnblogs.com/wezheng/p/8399305.html
* 经常搜索的列上建索引
* 作为主键的列上要建索引
* 经常需要连接(where子句)的列上
* 经常需要排序的列
* 经常需要范围查找的列

哪些列不适合建索引?
* 很少查询的列
* 更新很频繁的列
* 数据值的取值比较少的列(比如性别)
#### (8) 索引的底层实现(重点)
数据库的索引是使用B+树来实现的.

(为什么要用B+树,为什么不用红黑树和B树)<br>
B+树是一种特殊的平衡多路树,是B树的优化改进版本,它把所有的数据都存放在叶节点上,中间节点保存的是索引.这样一来相对于B树来说,减少了数据对中间节点的空间占用,使得中间节点可以存放更多的指针,使得树变得更矮,深度更小,从而减少查询的磁盘IO次数,提高查询效率.另一个是由于叶节点之间有指针连接,所以可以进行范围查询,方便区间访问.

而红黑树是二叉的,它的深度相对B+树来说更大,更大的深度意味着查找次数更多,更频繁的磁盘IO,所以红黑树更适合在内存中进行查找.

#### (9) B树和B+树的区别(重点)
![./fig/Bptree.png](./fig/Bptree.png)

这都是由于B+树和B具有不同的存储结构所造成的区别,以一个m阶树为例.
1. 关键字的数量不同;B+树中分支结点有m个关键字,其叶子结点也有m个,其关键字只是起到了一个索引的作用,但是B树虽然也有m个子结点,但是其只拥有m-1个关键字.
2. 存储的位置不同;B+树中的数据都存储在叶子结点上,也就是其所有叶子结点的数据组合起来就是完整的数据,但是B树的数据存储在每一个结点中,并不仅仅存储在叶子结点上.
3. 分支结点的构造不同;B+树的分支结点仅仅存储着关键字信息和儿子的指针(这里的指针指的是磁盘块的偏移量),也就是说内部结点仅仅包含着索引信息.
4. 查询不同;B树在找到具体的数值以后,则结束,而B+树则需要通过索引找到叶子结点中的数据才结束,也就是说B+树的搜索过程中走了一条从根结点到叶子结点的路径.

B+树优点:由于B+树的数据都存储在叶子结点中,分支结点均为索引,方便扫库,只需要扫一遍叶子结点即可,但是B树因为其分支结点同样存储着数据,我们要找到具体的数据,需要进行一次中序遍历按序来扫,所以B+树更加适合在区间查询的情况,所以通常B+树用于数据库索引,而B树则常用于文件索引.
#### (10) 索引最左前缀/最左匹配
假如我们对a b c三个字段建立了联合索引,在联合索引中,从最左边的字段开始,任何连续的索引都能匹配上,当遇到范围查询的时候停止.比如对于联合索引index(a,b,c),能匹配a,ab,abc三组索引.并且对查询时字段的顺序没有限制,也就是a,b,c; b,a,c; c,a,b; c,b,a都可以匹配.
#### (11) Mysql的优化(高频,索引优化,性能优化)
高频访问:
* 分表分库:将数据库表进行水平拆分,减少表的长度
* 增加缓存: 在web和DB之间加上一层缓存层
* 增加数据库的索引:在合适的字段加上索引,解决高频访问的问题
  

并发优化:
* 主从读写分离:只在主服务器上写,从服务器上读
* 负载均衡集群:通过集群或者分布式的方式解决并发压力
#### (12) MYSQL数据库引擎介绍,innodb和myisam的特点与区别
* InnoDB : InnoDB是mysql的默认引擎,支持事务和外键,支持容灾恢复.适合更新频繁和多并发的表  行级锁
* MyISAM : 插入和查询速度比较高,支持大文件,但是不支持事务,适合在web和数据仓库场景下使用  表级锁
* MEMORY : memory将表中的数据保存在内存里,适合数据比较小而且频繁访问的场景
* CSV
* blackhole
#### (13) 数据库中事务的ACID(四大特性都要能够举例说明,理解透彻,比如原子性和一致性的关联,隔离性不好会出现的问题)
数据库事务是指逻辑上对数据的一种操作,这个事务要么全部成功,要么全部失败.

**A: atom 原子性**<br>
数据库事务的原子性是指:事务是一个不可分割的工作单位,这组操作要么全部发生,要么全部不发生.

**C: consistency 一致性**<br>
数据库事务的一致性是指:在事务开始以前,数据库中的数据有一个一致的状态.在事务完成后,数据库中的事务也应该保持这种一致性.事务应该将数据从一个一致性状态转移到另一个一致性状态.
比如在银行转账操作后两个账户的总额应当不变.

**I: isolation 隔离性**<br>
数据库事务的隔离性要求数据库中的事务不会受另一个并发执行的事务的影响,对于数据库中同时执行的每个事务来说,其他事务要么还没开始执行,要么已经执行结束,它都感觉不到还有别的事务正在执行.

**D:durability 持久性**<br>
数据库事务的持久性要求事务对数据库的改变是永久的,哪怕数据库发生损坏都不会影响到已发生的事务.
如果事务没有完成,数据库因故断电了,那么重启后也应该是没有执行事务的状态,如果事务已经完成后数据库断电了,那么重启后就应该是事务执行完成后的状态.
#### (14)什么是脏读,不可重复读和幻读?
详见[数据库的事务隔离级别总结](https://blog.csdn.net/fuzhongmin05/article/details/91126936)
* 脏读:脏读是指一个事务在处理过程中读取了另一个还没提交的事务的数据.
  
  > 比如A向B转账100,A的账户减少了100,而B的账户还没来得及修改,此时一个并发的事务访问到了B的账户,就是脏读
* 不可重复读:不可重复读是对于数据库中的某一个字段,一个事务多次查询却返回了不同的值,这是由于在查询的间隔中,该字段被另一个事务修改并提交了.
  > 比如A第一次查询自己的账户有1000元,此时另一个事务给A的账户增加了1000元,所以A再次读取他的账户得到了2000的结果,跟第一次读取的不一样.
  > 不可重复读与脏读的不同之处在于,脏读是读取了另一个事务没有提交的脏数据,不可重复读是读取了已经提交的数据,实际上并不是一个异常现象.
* 幻读:事务多次读取同一个范围的时候,查询结果的记录数不一样,这是由于在查询的间隔中,另一个事务新增或删除了数据.
  > 比如A公司一共有100个人,第一次查询总人数得到100条记录,此时另一个事务新增了一个人,所以下一次查询得到101条记录.
  > 不可重复度和幻读的不同之处在于,幻读是多次读取的结果行数不同,不可重复度是读取结果的值不同.

避免不可重复读需要锁行,避免幻读则需要锁表.

脏读,不可重复读和幻读都是数据库的读一致性问题,是在并行的过程中出现的问题,必须采用一定的隔离级别解决.
详见[脏读/不可重复读和幻读的区别](https://www.cnblogs.com/Hakuna-Matata/p/7772794.html)

#### (15) 数据库的隔离级别,mysql和Oracle的隔离级别分别是什么(重点)
详见[数据库的事务隔离级别总结](https://blog.csdn.net/fuzhongmin05/article/details/91126936)和[数据库隔离级别](https://blog.csdn.net/fg2006/article/details/6937413)

为了保证数据库事务一致性,解决脏读,不可重复读和幻读的问题,数据库的隔离级别一共有四种隔离级别:
* 读未提交 Read Uncommitted: 最低级别的隔离,不能解决以上问题
* 读已提交 Read committed:   可以避免脏读的发生 
* 可重复读 Reapeatable read:  确保事务可以多次从一个字段中读取相同的值,在该事务执行期间,禁止其他事务对此字段的更新,可以避免脏读和不可重复读. 通过锁行来实现 
* 串行化 Serializaion  最严格的事务隔离机制,要求所有事务被串行执行,可以避免以上所有问题. 通过锁表来实现

Oracle的默认隔离级别是**读已提交**,实现了四种隔离级别中的读已提交和串行化隔离级别

MySQL的默认隔离级别是**可重复读**,并且实现了所有四种隔离级别
#### (16) 数据库连接池的作用
#### (17) Mysql的表空间方式,各自特点
* 共享表空间:指的是数据库的所有的表数据,索引文件全部放在一个文件中,默认这个共享表空间的文件路径在 data 目录下. 
* 独立表空间:每一个表都将会生成以独立的文件方式来进行存储. 优点:当表被删除时这部分空间可以被回收;可以更快的恢复和备份单个表;将单个表复制到另一个实例会很方便; 缺点:mysqld会维持很多文件句柄,表太多会影响性能.如果很多表都增长会导致碎片问题
#### (18) 分布式事务
#### (19) 数据库的范式
https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html

* **第一范式(确保每列保持原子性)**<br>
第一范式是最基本的范式.如果数据库表中的所有字段值都是不可分解的原子值,就说明该数据库表满足了第一范式.

>比如 学生 选课(包括很多课程) 就不符合第一范式
* **第二范式(确保表中的每列都和主键相关)**<br>
在满足第一范式的前提下,(主要针对联合主键而言)第二范式需要确保数据库表中的每一列都和主键的所有成员直接相关,由整个主键才能唯一确定,而不能只与主键的某一部分相关或者不相关. 

>比如一张学生信息表,由主键(学号)可以唯一确定一个学生的姓名,班级,年龄等信息.但是主键 (学号,班级) 与列 姓名,班主任,教室 就不符合第二范式,因为班主任跟部分主键(班级)是依赖关系
* **第三范式(确保非主键的列没有传递依赖)**<br>
在满足第二范式的前提下,第三范式需要确保数据表中的每一列数据都和主键直接相关,而不能间接相关.非主键的列不能确定其他列,列与列之间不能出现传递依赖.

>比如一张学生信息表,主键是(学号)列包括 姓名,班级,班主任 就不符合第三范式,因为非主键的列中 班主任 依赖于 班级
* **BCNF范式(确保主键之间没有传递依赖)**<br>
主键有可能是由多个属性组合成的复合主键,那么多个主键之间不能有传递依赖.也就是复合主键之间谁也不能决定谁,相互之间没有关系.
#### (20) 数据的锁的种类,加锁的方式
以MYSQL为例,
* 按照类型来分有乐观锁和悲观锁
* 根据粒度来分有行级锁,页级锁,表级锁(粒度一个比一个大) (仅BDB,Berkeley Database支持页级锁)
* 根据作用来分有共享锁(读锁)和排他锁(写锁).
#### (21) 什么是共享锁和排他锁
* 共享锁是读操作的时候创建的锁,一个事务对数据加上共享锁之后,其他事务只能对数据再加共享锁,不能进行写操作直到释放所有共享锁.
* 排他锁是写操作时创建的锁,事务对数据加上排他锁之后其他任何事务都不能对数据加任何的锁(即其他事务不能再访问该数据)
  
  https://blog.csdn.net/qq_42743933/article/details/81236658
#### (22) 分库分表的理解和简介
#### (23) 
#### (24)数据库高并发的解决方案
1. 在web服务框架中加入缓存.在服务器与数据库层之间加入缓存层,将高频访问的数据存入缓存中,减少数据库的读取负担.
2. 增加数据库索引.提高查询速度.(不过索引太多会导致速度变慢,并且数据库的写入会导致索引的更新,也会导致速度变慢)
3. 主从读写分离,让主服务器负责写,从服务器负责读.
4. 将数据库进行拆分,使得数据库的表尽可能小,提高查询的速度.
5. 使用分布式架构,分散计算压力.
#### (25)乐观锁与悲观锁解释一下
一般的数据库都会支持并发操作,在并发操作中为了避免数据冲突,所以需要对数据上锁,乐观锁和悲观锁就是两种不同的上锁方式.

悲观锁假设数据在并发操作中一定会发生冲突,所以在数据开始读取的时候就把数据锁住.而乐观锁则假设数据一般情况下不会发生冲突,所以在数据提交更新的时候,才会检测数据是否有冲突.
#### (26)乐观锁与悲观锁是怎么实现的
悲观锁有行级锁和页级锁两种形式.行级锁对正在使用的单条数据进行锁定,事务完成后释放该行数据,而页级锁则对整张表进行锁定,事务正在对该表进行访问的时候不允许其他事务并行访问.

悲观锁要求在整个过程中一直与数据库有一条连接,因为上一个事务完成后才能让下一个事务执行,这个过程是串行的.

乐观锁有三种常用的实现形式:
* 一种是在执行事务时把整个数据都拷贝到应用中,在数据更新提交的时候比较数据库中的数据与新数据,如果两个数据一摸一样则表示没有冲突可以直接提交,如果有冲突就要交给业务逻辑去解决.
* 一种是使用版本戳来对数据进行标记,数据每发生一次修改,版本号就增加1.某条数据在提交的时候,如果数据库中的版本号与自己的一致,就说明数据没有发生修改,否则就认为是过期数据需要处理.
* 最后一种采用时间戳对数据最后修改的时间进行标记.与上一种类似.

#### (27)对数据库目前最新技术有什么了解吗

---
title: "数据库基础导论"
layout: post
author: "Marco"
header-style: text
hidden: true
tags:
  - 数据库
---

## 数据库基础导论

### 1. 基本概念

- ***数据库有什么用***

  ​	简单来说,数据库就是为了实现增删改查.一般面向的对象为服务器等.而且因为考虑到高并发情况,如双11的时候对淘宝发起的页面请求是非常恐怖的,要求加载非常非常多的数据,增删改查速度的影响非常大.

  ​	除此之外,数据库在实现基本增删改查的功能下,还希望有以下特性.

  - 减少数据冗余,相同数据尽量不要重复储存.
  - 故障恢复,或者说备份.
  - 数据一致性,主要是使得多个用户操作时不发生冲突

- ***数据库有哪些分类?***

  - 关系型数据库(SQL)

    - Orade
    - **MySQL**

  - 非关系型数据库(NoSQL)

    - 键值存储数据库

      > 含义:数据格式一般不特别限制,最常用,相对其他方法胜在简单,易部署和高并发.

      - **redis**
      - Memcached

    - 文档存储数据库

      > 含义:其数据以XML/JSON等文档为主.

      - MongoDB
      - CouchDB

    - 图结构数据库

      > 含义:其数据以图结构为主

      - Neo4J
      - InforGrid

    - 列存储数据库

      > 含义:按列存储,而其他数据库一般都是按行存储的,如果比如说我有一个学生成绩表,我想算全班平均分.如果是按行存储的,我只能一行一行读来得到学生成绩,再求平均分;如果是按列存储的,我直接读成绩一栏,就可以知道所有学生成绩了,而不是一行一行.
      >
      > [进一步资料](https://juejin.cn/post/6844904118872440840)

      - Hbase
      - Cassandra

- ***关系数据库和非关系数据库具体区别是什么?***

  ​	关系数据库采用了关系模式来组织数据格式,用人话来说就是数据都是类似于表格的,常用B树/B+树等方式存储.而且要求支持事务机制,比如说一系列的操作中数据可能位于不同的服务器,这时候是分布式的事务,为了实现原子性需要彼此协调,而这个协调的过程是耗时的,每台机器在一个大事务过程都必须依次确认.

  ​	非关系数据库采用了非关系模式来组织数据格式,最重要的是事务机制有所妥协,所以性能会达到优化.

### 2. MySQL

- ***MySQL语法学习***

  [SQL tutorial](https://www.w3school.com.cn/sql/index.asp)

  [MySQL入门教程](https://github.com/jaywcjlove/mysql-tutorial)

- ***特点***

  - 读写相对慢,哪怕使用了B+树减少了硬盘IO次数,而redis这种非关系型数据库是在内存的,所以更快.
  - 难扩展,如果加入很多新的数据,树的形状会发生极大改变,索引需要更改.
  - 支持复杂查询条件,比如说我想查询学生班级有没有两米的,我只需要在学生班级中逐个找就好了,可以基于关系简历多级索引.
  - 利于维护,一是因为表格数据,能给人类很大信息量;二是因为,数据不容易冗余

- ***MySQL中的基本概念有哪些?***

  如果想要深入地了解MySQL,需要对以下知识进行了解,因为篇幅受限,我会新开一篇博文进行介绍.

  - 事务
  - 锁
  - 隔离级别
  - 索引
  - 表优化

### 3 Redis

- ***特点***
  - 读写快,因为是基于键值对的,哈希映射,一步就能够到目标节点.
  - 便于扩展,用户自己根据`key`添加`value`即可.
  - 不支持复杂查询条件,同样地如果说我想查询学生班级有没有两米的,因为不存在学生班级这个概念,根本就无从下手.
  - 不利于维护,`key-value`不直观难理解,数据容易冗余

- **redis是什么?**

  ​	Redis是一种支持key-value等多种数据结构的存储系统.可用于缓存,事件发布或订阅,高速队列等场景.支持网络,提供字符串,哈希,列表,队列,集合结构直接存取,基于内存,可持久化.

- ***redis的缺点***

  - 数据库容量容易收到物理内存的限制,不能用于海量数据的高性能读写,只能适用于较小数据的高性能操作.
  - 不具备自动容错和回复功能.主机和从机的宕机都会导致请求失败,需要重启.
  - redis较难支持在线扩容.

- [redis知识总结](https://www.cnblogs.com/wmyskxz/p/12568926.html)

  

### 4. 附录

[SQL or NoSQL,看完这一篇你就懂了](https://www.cnblogs.com/xrq730/p/11039384.html)

[java全栈知识体系-数据库篇](https://pdai.tech/md/db/nosql-redis/db-redis-x-event.html)

