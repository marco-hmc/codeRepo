---
title: "(1)为什么用gtest"
layout: post
author: "Marco"
header-style: text
hidden: true
tags:
  - 单元测试
---

 ## 为什么用gtest

### 1. 基本概念

- ***C++有哪些单元测试库***

  - catch
    - 易上手、使用
    - 15.1k stars in github
  - boost.test
    - 支持数据驱动测试
  - google test(gtest)
    - 26.4k stars in github

  *总结：如果想要大而全的方法，上gtest；如果是数据驱动的测试，上boost.test；如果只是做一部分单元测试，上catch，简洁好用。但是，这里笔者作为学习的话，就研究gtest了，因为可能相对来gtest使用人更多。*


### 2. 基本概念

- 当使用gtest的时候，要多使用断言(assertions)。

  - gtest的assertions是宏。当这个宏断言失败的时候，会打印source file、行数以及错误信息。错误信息也可以是自定义的
  - `ASSERT_*`生成严重错误，会abort当前函数
  - `EXPECT_*`生成不严重错误，不会abort当前函数。
  - 建议使用后者，这样可以同时测试后面的；当然，如果这里错了，后面运行会受到影响的，还是要用前者。
  - 如果`ASSERT_*`生成错误的时候，可能会跳出析构函数部分，造成内存泄露。有可能会影响你的结果，心里有个底就行。
  - 自定义错误信息，可以通过`<<`来实现。
  - ```c++
      // 示例
      ASSERT_EQ(x.size(), y.size()) << "Vectors x and y are of unequal length";

      for (int i = 0; i < x.size(); ++i) {
        EXPECT_EQ(x[i], y[i]) << "Vectors x and y differ at index " << i;
      }
      ```

- 使用`TEST()`宏来定义测试函数。

  - 第一个参数表示测试函数名字，第二个参数表示测试名字(测试目的)

  - ```c++
    // Tests factorial of 0.
    TEST(FactorialTest, HandlesZeroInput) {
      EXPECT_EQ(Factorial(0), 1);
    }
    
    // Tests factorial of positive numbers.
    TEST(FactorialTest, HandlesPositiveInput) {
      EXPECT_EQ(Factorial(1), 1);
      EXPECT_EQ(Factorial(2), 2);
      EXPECT_EQ(Factorial(3), 6);
      EXPECT_EQ(Factorial(8), 40320);
    }
    ```

- 使用test fixtures

  - 如果你有几个test函数的操作对象是在类似的数据的，你可以使用test fixture。这个能够使得你在不同的test情况下复用配置。说白了就是类，不同的测试方法共享成员变量，就可以免去重复配置了。
  - 一个fixture的创建如下
    1. 继承`::testing::test`
    2. 如果有必要，可以写一个`SetUp()`函数作为默认构造函数，这里常见的错误是错拼为`Setup()`，可以视同override来让c11去保证你的拼写。
    3. 如果有必要，可以写`TearDown()`来释放`SetUp()`申请的资源。
  - 这个时候的`TEST_F()`要这么拼写，多了一个`_F`表示是fixture，因为c++的宏里面是没有重载的概念，所以要改拼写了



