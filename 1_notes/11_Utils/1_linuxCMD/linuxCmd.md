* find [path] -iname ""
* find /usr -iname "gdb"
https://linuxtools-rst.readthedocs.io/zh-cn/latest/index.html

### 99. quiz
在 Linux 系统中，`/usr/share` 目录通常包含与共享数据相关的文件和子目录。这些文件和数据通常是只读的，并且可以被多个用户和应用程序共享使用。以下是一些常见的文件和子目录：

### 系统监测

#### CPU，内存，IO监控

* **ps**命令用于显示当前进程的状态(cpu利用率， 占用内存，状态，运行时间等)，类似于 windows 的任务管理器

  ```shell
  ps [options] [--help]
  
  -A 列出所有的进程
  -w 显示加宽可以显示较多的资讯
  -au 显示较详细的资讯
  -aux 显示所有包含其他使用者的进程
  -ajx 获得当前所有的进程及父进程和进程组id
  -axjf/-ejH 查看所有进程的层次关系
  -ef 显示所有命令，连带命令行
  ```

  -aux 显示格式`USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND`

  * USER: 行程拥有者
  * PID: pid
  * %CPU: 占用的 CPU 使用率
  * %MEM: 占用的记忆体使用率
  * VSZ: 占用的虚拟记忆体大小
  * RSS: 占用的记忆体大小
  * TTY: 终端的次要装置号码 (minor device number of tty)
  * STAT: 该行程的状态:
    - D: 无法中断的休眠状态 (通常 IO 的进程)
    - R: 正在执行中
    - S: 静止状态
    - T: 暂停执行
    - Z: 不存在但暂时无法消除（僵尸进程）
    - W: 没有足够的记忆体分页可分配
    - <: 高优先序的行程
    - N: 低优先序的行程
    - L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)
  * START: 行程开始时间
  * TIME: 执行的时间
  * COMMAND:所执行的指令

* **vmstat**  可以展现给定时间间隔的服务器的状态值，包括服务器的**CPU使用率，内存使用，虚拟内存交换情况，IO读写情况**

  * 相比top，vmstat可以看到**整个机器**的CPU,内存,IO的使用情况，**而不是**单单看到**各个进程**的CPU使用率和内存使用率

  ```shell
  -a：显示活跃和非活跃内存
  -f：显示从系统启动至今的fork数量 。
  -m：显示slabinfo
  -n：只在开始时显示一次各字段名称。
  -s：显示内存相关统计信息及多种系统活动数量。
  delay：刷新时间间隔。如果不指定，只显示一条结果。
  count：刷新次数。如果不指定刷新次数，但指定了刷新时间间隔，这时刷新次数为无穷。
  -d：显示磁盘相关统计信息。
  -p：显示指定磁盘分区统计信息
  -S：使用指定单位显示。参数有 k 、K 、m 、M ，分别代表1000、1024、1000000、1048576字节（byte）。默认单位为K（1024 bytes）
  -V：显示vmstat版本信息
  ```

* **top** 实时监控系统状态，查看内存，端口 ，io访问量，读写速率

  ```shell
  top [-] [d delay] [q] [c] [S] [s] [i] [n] [b]
  d : 改变显示的更新速度，或是在交谈式指令列( interactive command)按 s
  q : 没有任何延迟的显示速度，如果使用者是有 superuser 的权限，则 top 将会以最高的优先序执行
  c : 切换显示模式，共有两种模式，一是只显示执行档的名称，另一种是显示完整的路径与名称
  S : 累积模式，会将己完成或消失的子行程 ( dead child process ) 的 CPU time 累积起来
  s : 安全模式，将交谈式指令取消, 避免潜在的危机
  i : 不显示任何闲置 (idle) 或无用 (zombie) 的行程
  n : 更新的次数，完成后将会退出 top
  b : 批次档模式，搭配 "n" 参数一起使用，可以用来将 top 的结果输出到档案内
  ```

  * top参数：load average，cpu使用率怎么算
    * 系统负载（System Load）是系统CPU繁忙程度的度量，即有多少进程在等待被CPU调度（**进程等待队列的长度**）
    * load average：1.97,2.14,2.99 来举例：
      - 第一位1.97：表示最近1分钟平均负载
      - 第二位2.14：表示最近5分钟平均负载
      - 第三位2.99：表示最近15分钟平均负载
    * Load < 0.7时：系统很闲，马路上没什么车，要考虑多部署一些服务
    * 0.7 < Load < 1时：系统状态不错，马路可以轻松应对
    * Load == 1时：系统马上要处理不多来了，赶紧找一下原因
    * Load > 1时：马路已经非常繁忙了，进入马路的每辆汽车都要无法很快的运行
    * 通常我们先看15分钟load，如果load很高，再看1分钟和5分钟负载，查看是否有下降趋势
    * 1分钟负载值 > 1，那么我们不用担心，但是如果15分钟负载都超过1，我们要赶紧看看发生了什么事情。所以我们要根据实际情况查看这三个值
    * "load average"一共返回三个平均值：1分钟系统负荷、5分钟系统负荷，15分钟系统负荷；
    * 如果只有1分钟的系统负荷大于1.0，其他两个时间段都小于1.0，这表明只是暂时现象，问题不大
    * 如果15分钟内，平均系统负荷大于1.0（调整CPU核心数之后），表明问题持续存在，不是暂时现象。所以，你应该主要观察"15分钟系统负荷"，将它作为电脑正常运行的指标。
    * 结合具体情况具体分析（单核）：
      - 1分钟Load>1，5分钟Load<1，15分钟Load<1：短期内繁忙，中长期空闲，初步判断是一个“抖动”，或者是“拥塞前兆”
      - 1分钟Load>1，5分钟Load>1，15分钟Load<1：短期内繁忙，中期内紧张，很可能是一个“拥塞的开始”
      - 1分钟Load>1，5分钟Load>1，15分钟Load>1：短、中、长期都繁忙，系统“正在拥塞”
      - 1分钟Load<1，5分钟Load>1，15分钟Load>1：短期内空闲，中、长期繁忙，不用紧张，系统“拥塞正在好转”

* **mpstat** 实时监测多处理器系统上的**每个CPU的使用情况**

* **iostat** 主要用于输出磁盘IO 和 CPU的统计信息

  ```shell
  iostat [选项] [<时间间隔>] [<次数>]
  -c： 显示CPU使用情况
  -d： 显示磁盘使用情况
  -N： 显示磁盘阵列(LVM) 信息
  -n： 显示NFS 使用情况
  -k： 以 KB 为单位显示
  -m： 以 M 为单位显示
  -t： 报告每秒向终端读取和写入的字符数和CPU的信息
  -V： 显示版本信息
  -x： 显示详细信息
  -p：[磁盘] 显示磁盘和分区的情况
  ```

* **free命令用于显示内存状态**，显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等

  ```shell
  free [-bkmotV][-s <间隔秒数>]
  -b 　以Byte为单位显示内存使用情况。
  -k 　以KB为单位显示内存使用情况。
  -m 　以MB为单位显示内存使用情况。
  -h 　以合适的单位显示内存使用情况，最大为三位数，自动计算对应的单位值。单位有B = bytes
       K = kilos
       M = megas
       G = gigas
       T = teras
  -o 　不显示缓冲区调节列。
  -s<间隔秒数> 　持续观察内存使用状况。
  -t 　显示内存总和列。
  -V 　显示版本信息。
  ```

#### 网络监控

* **tcpdump root权限下使用的抓包工具，只能抓取流经本机的数据包**

  ```shell
  tcpdump [-adeflnNOpqStvx][-c<数据包数目>][-dd][-ddd][-F<表达文件>][-i<网络界面>][-r<数据包文件>][-s<数据包大小>][-tt][-T<数据包类型>][-vv][-w<数据包文件>][输出数据栏位]
  -a 尝试将网络和广播地址转换成名称。
  -c <数据包数目> 收到指定的数据包数目后，就停止进行倾倒操作。
  -d 把编译过的数据包编码转换成可阅读的格式，并倾倒到标准输出。
  -dd 把编译过的数据包编码转换成C语言的格式，并倾倒到标准输出。
  -ddd 把编译过的数据包编码转换成十进制数字的格式，并倾倒到标准输出。
  -e 在每列倾倒资料上显示连接层级的文件头。
  -f 用数字显示网际网络地址。
  -F<表达文件> 指定内含表达方式的文件。
  -i<网络界面> 使用指定的网络截面送出数据包。
  -l 使用标准输出列的缓冲区。
  -n 不把主机的网络地址转换成名字。
  -N 不列出域名。
  -O 不将数据包编码最佳化。
  -p 不让网络界面进入混杂模式。
  -q 快速输出，仅列出少数的传输协议信息。
  -r <数据包文件> 从指定的文件读取数据包数据。
  -s<数据包大小> 设置每个数据包的大小。
  -S 用绝对而非相对数值列出TCP关联数。
  -t 在每列倾倒资料上不显示时间戳记。
  -tt 在每列倾倒资料上显示未经格式化的时间戳记。
  -T <数据包类型> 强制将表达方式所指定的数据包转译成设置的数据包类型。
  -v 详细显示指令执行过程。
  -vv 更详细显示指令执行过程。
  -x 用十六进制字码列出数据包资料。
  -w <数据包文件> 把数据包数据写入指定的文件。
  ```

* **netstat 用于显示网络状态**，可以打印本地网卡接口上的全部链接 路由表信息 网卡接口信息等

  ```shell
  -a或--all 显示所有连线中的Socket。
  -A<网络类型>或--<网络类型> 列出该网络类型连线中的相关地址。
  -c或--continuous 持续列出网络状态。
  -C或--cache 显示路由器配置的快取信息。
  -e或--extend 显示网络其他相关信息。
  -F或--fib 显示路由缓存。
  -g或--groups 显示多重广播功能群组组员名单。
  -h或--help 在线帮助。
  -i或--interfaces 显示网络界面信息表单。
  -l或--listening 显示监控中的服务器的Socket。
  -M或--masquerade 显示伪装的网络连线。
  -n或--numeric 直接使用IP地址，而不通过域名服务器。
  -N或--netlink或--symbolic 显示网络硬件外围设备的符号连接名称。
  -o或--timers 显示计时器。
  -p或--programs 显示正在使用Socket的程序识别码和程序名称。
  -r或--route 显示Routing Table。
  -s或--statistics 显示网络工作信息统计表。
  -t或--tcp 显示TCP传输协议的连线状况。
  -u或--udp 显示UDP传输协议的连线状况。
  -v或--verbose 显示指令执行过程。
  -V或--version 显示版本信息。
  -w或--raw 显示RAW传输协议的连线状况。
  -x或--unix 此参数的效果和指定"
  -A unix"参数相同。
  --ip或--inet 此参数的效果和指定"-A inet"参数相同。
  ```

* **ifstat** 简单的网络流量监测工具

  ```shell
  -a 监测系统上的所有网卡接口
  -i 指定要监测的网卡接口
  -t 在每行输出信息前加上时间戳
  ```

* **iptables 对Linux系统中通信的数据包进行一定的检测，达到防火墙的目的**

* iptables 查看端口流量

  * 输入监控

    ```shell
    # 下面示例是监控目标端口是8080的输入流量 --dport(destination port 的缩写)
    iptables -A INPUT -p tcp --dport 8080
    ```

  * 输出监控

    ```shell
    # 下面示例是监控来源端口是8080的输出流量 --sport(source port 的缩写)
    iptables -A OUTPUT -p tcp --sport 8080
    ```

  * **查看统计数据**

    ```
    iptable -L -v -n -x
    
    Chain INPUT (policy ACCEPT 202 packets, 25187 bytes)
      pkts   bytes target   prot opt in   out   source        destination     
       18   2885      tcp -- *   *    0.0.0.0/0      0.0.0.0/0      tcp dpt:8080
    
    Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
      pkts   bytes target   prot opt in   out   source        destination     
    
    Chain OUTPUT (policy ACCEPT 184 packets, 45774 bytes)
      pkts   bytes target   prot opt in   out   source        destination     
       12   8240      tcp -- *   *    0.0.0.0/0      0.0.0.0/0      tcp spt:8080
    
    ```

  * **重置统计数据**

    ```shell
    # 重置所有输入端口
    Iptable -Z INPUT
    # 重置所有输出端口
    Iptable -Z OUTPUT
    ```

  * **移除统计端口**

    ```shell
    # 移除输入端口
    iptables -D INPUT -p tcp --dport 8080
    # 移除输出端口
    iptables -D OUTPUT -p tcp --sport 8080
    ```

* **lsof**查看一个进程打开了哪些文件，文件被哪些进程使用

  ```shell
  -p 18400 （按照进程ID查看）
  -d type (按照FD的类型查看）
  -i 4 (查看进程打开的网络连接，使用IPV4协议）
  -i:80 (查看进程打开的网络连接，端口号为80）
  -i @127.0.0.1 (查看进程打开的网络连接，IP为127.0.0.1）
  lsof file-name：查看文件对应的进程
  ```


#### 监测消息列表、共享内存和信号量的信息

* **ipcs**：用于报告Linux中进程间通信设施的状态

  ```shell
  ipcs [resource ...] [output-format]ipcs [resource] -i 
  <id>选项：
  -i, --id <id>  打印由 id 标识的资源的详细信息
  -h, --help     显示此帮助并退出
  -V, --version  输出版本信息并退出
  资源选项:
  -m, --shmems      共享内存段
  -q, --queues      消息队列
  -s, --semaphores  信号量
  -a, --all         全部(默认)
  输出格式：
  -t, --time        显示附加、脱离和更改时间
  -p, --pid         显示 PID 的创建者和最后操作
  -c, --creator     显示创建者和拥有者
  -l, --limits      显示资源限制
  -u, --summary     显示状态摘要    
  --human       以易读格式显示大小
  -b, --bytes       以字节数显示大小
  ```

* **ipcrm**：删除一个或更多的消息队列、信号量集或者共享内存标识，同时会将与ipc对象相关链的数据也一起移除

  ```shell
  ipcrm [options]ipcrm <shm|msg|sem> <id> [...]
  -m, --shmem-id <id>        按 id 号移除共享内存段
  -M, --shmem-key <键>       按键值移除共享内存段
  -q, --queue-id <id>        按 id 号移除消息队列
  -Q, --queue-key <键>       按键值移除消息队列
  -s, --semaphore-id <id>    按 id 号移除信号量
  -S, --semaphore-key <键>  按键值移除信号量
  -a, --all[=<shm|msg|sem>]  全部移除
  -v, --verbose              解释正在进行的操作
  -h, --help     显示此帮助并退出
  -V, --version  输出版本信息并退出
  ```

* [**ulimit**](https://blog.csdn.net/FreeApe/article/details/101058393) 

  * shell内建指令，可用来控制shell执行程序的资源

  * 设置项仅在当前shell作用(类似`export`命令，永久生效可以写入相关配置文件)

  * 写入`~/.profile或~/.bashrc`**只对当前用户持久性生效**

  * 写入`/etc/security/limits.conf`可针对性配置，**系统级持久性生效**

    ```shell
    ulimit [-aHS][-c <core文件上限>][-d <数据节区大小>][-f <文件大小>][-m <内存大小>][-n <文件数目>][-p <缓冲区大小>][-s <堆叠大小>][-t <CPU时间>][-u <程序数目>][-v <虚拟内存大小>]
    
    -a 　显示目前资源限制的设定。
    -c <core文件上限> 　设定core文件的最大值，单位为区块。
    -d <数据节区大小> 　程序数据节区的最大值，单位为KB。
    -f <文件大小> 　shell所能建立的最大文件，单位为区块。
    -H 　设定资源的硬性限制，也就是管理员所设下的限制。
    -m <内存大小> 　指定可使用内存的上限，单位为KB。
    -n <文件数目> 　指定同一时间最多可开启的文件数。
    -p <缓冲区大小> 　指定管道缓冲区的大小，单位512字节。
    -s <进程栈大小> 　指定进程栈的上限，单位为KB。
    -S 　设定资源的弹性限制。
    -t <CPU时间> 　指定CPU使用时间的上限，单位为秒。
    -u <程序数目> 　用户最多可开启的程序数目。
    -v <虚拟内存大小> 　指定可使用的虚拟内存上限，单位为KB。
    ```

* linux的fd数量限制查询

  * 所有进程允许打开的最大fd数量

  ```shell
  cat /proc/sys/fs/file-max   // 9223372036854775807
  ```

  * 所有进程已经打开的fd数量及允许的最大数量

  ```shell
  cat /proc/sys/fs/file-nr
  ```

  * 单个进程允许打开的最大fd数量

  ```shell
  ulimit -n
  ```

  * 单个进程（例如进程id为5454）已经打开的fd

  ```shell
  ls -l /proc/5454/fd/lsof -p 5454
  ```

#### 进程/线程绑定cpu

* 意义
  * 一是现代服务器大多采用NUMA多处理器架构，一台服务器会安装多颗处理器（称为NUMA节点），而NUMA架构各节点资源较为独立的设计，决定了在不同NUMA节点共享数据的成本高昂，因此尽量将数据交互较为频繁的程序绑定在同一NUMA节点上是很重要的
  * 二是进程/线程**如果从一个核心切换至另一个核心上运行，需要面临上下文切换、缓存失效等问题，成本也很高**。在对性能要求较高的软件中，这已经是造成时延抖动的一大来源之一

* 进程/线程绑定

  * 在Linux系统下，进程都有一个CPU亲和力属性（affinity），通过以下命令可以查询

    ```bash
    # 查看cpu信息
    cat /proc/cpuinfo | grep processor
    processor	: 0
    # 查看某个进程可以运行的cpu
    taskset -pc 26419 
    pid 26419's current affinity list: 0
    ```

    以上查询结果的含义是，进程id为26419的进程，可以在0号CPU上运行，默认情况下，进程是可以在任意一个核心上运行的

  * 绑定cpu

    ```
    taskset -pc 0,1,2... pid	# 表示将pid进程绑定到0，1，2...号cpu执行
    ```

  * taskset命令依然适用于线程

  * 不能通过taskset+程序名直接启动程序并实现各个线程**绑定不同核心**了，该命令只能支持到进程级别，也就是说它会把进程下的所有线程都设置为相同的亲和度

  * 如果需要将同一进程中线程绑定到不同cpu，需要手动taskset tid：可以编写脚本启动并获取线程id，再多次调用taskset，指定线程id，将其绑定到不同核心上即可

* 编程绑定

  * sched_getaffinity、sched_setaffinity
  * pthread_setaffinity_np

#### 查看某个服务是否启动

* 方法一：查看redis服务进程情况，这里拿redis服务举例,其他服务查询更改名字即可

  ```
  ps -ef|grep redis
  ```

* 方法二：查看6379（为redis的端口号）端口号是否被占用

  ```
  lsof -i :6379
  ```

* 方法三：显示tcp的端口和进程等相关情况

  ```
  netstat -tnlp
  ```

#### ar, nm, ldd, readelf, objdump

* ar：建立或修改备存文件，或是从备存文件中抽取文件

  ```shell
  ar[-dmpqrtx][cfosSuvV][a<成员文件>][b<成员文件>][i<成员文件>][备存文件][成员文件]
  必要参数：
  -d 　删除备存文件中的成员文件。
  -m 　变更成员文件在备存文件中的次序。
  -p 　显示备存文件中的成员文件内容。
  -q 　将文件附加在备存文件末端。
  -r 　将文件插入备存文件中。
  -t 　显示备存文件中所包含的文件。  # 常用
  -x 　自备存文件中取出成员文件。
  选项参数：
  a <成员文件> 　将文件插入备存文件中指定的成员文件之后。
  b <成员文件> 　将文件插入备存文件中指定的成员文件之前。
  c 　建立备存文件。
  f 　为避免过长的文件名不兼容于其他系统的ar指令指令，因此可利用此参数，截掉要放入备存文件中过长的成员文件名称。
  i <成员文件> 　将文件插入备存文件中指定的成员文件之前。
  o 　保留备存文件中文件的日期。
  s 　若备存文件中包含了对象模式，可利用此参数建立备存文件的符号表。
  S 　不产生符号表。
  u 　只将日期较新文件插入备存文件中。
  v 　程序执行时显示详细的信息。
  V 　显示版本信息。
  ```

* nm：nm用来列出目标文件的**符号表清单**

* ldd

  * 首先ldd不是一个可执行程序，而只是一个shell脚本
  * ldd能够显示**可执行模块的dependency**，其原理是通过设置一系列的环境变量，如下：LD_TRACE_LOADED_OBJECTS、LD_WARN、LD_BIND_NOW、LD_LIBRARY_VERSION、LD_VERBOSE等
  * ldd显示**可执行模块**的dependency的工作原理，其实质是通过ld-linux.so（elf动态库的装载器）来实现

* **readelf**：一般用于查看**ELF格式的文件信息**，常见的文件如在Linux上的**可执行文件**，**动态库(*.so)或者静态库(*.a) 等包含ELF格式**的文件

  * **系统里的目标文件是按照特定的目标文件格式来组织的，各个系统的目标文件格式都不相同**

  * ELF(Executable and Linking Format)**可执行可链接格式**是一种对象文件的格式，**用于定义不同类型的对象文件(Object files)中都放了什么东西、以及都以什么样的格式去放这些东西**。它自最早在 System V 系统上出现后，被 xNIX 世界所广泛接受，作为缺省的二进制文件格式来使用。可以说，ELF是构成众多xNIX系统的基础之一

    * ELF文件有三种类型：
      * **可重定位的对象文件**(Relocatable file) 由汇编器汇编生成的 .o 文件	
      * **可执行的对象文件**(Executable file) 可执行应用程序
      * **可被共享的对象文件**(Shared object file) 动态库文件，也即 .so 文件

    * 在Unix下使用**readelf命令来显示可执行程序的信息，功能与objdump相似，但是显示的更加具体**

  * ELF格式的文件在Linux系统下有.axf、 .bin、 .elf、 .o、 .prx、 .puff、 .ko、 .mod和.so等等

* objdump是用来**显示目标文件相关信息**的
