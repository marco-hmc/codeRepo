[toc]

### nc
nc
    **nc** 即 **n**et**c**at 命令,这个工具在排查网络故障时非常有用,功能非常强大,因而被业绩称为网络界的"瑞士军刀",请读者务必掌握.
    **nc** 命令常见的用法是模拟一个服务器程序被其他客户端连接,或者模拟一个客户端连接其他服务器,连接之后就可以进行数据收发.我们来逐一介绍一下:
    * -v: 这是verbose(详细)模式的开关,会显示更多的信息.
    * -l: 这是listen(监听)模式的开关,使得netcat在指定端口监听进来的连接.
    * nc -v -l 127.0.0.1 6000


- **模拟一个服务器程序**

  使用 **-l** 选项(单词 **l**isten 的第一个字母)在某个 ip 地址和端口号上开启一个侦听服务,以便让其他客户端连接.通常为了显示更详细的信息,会带上 **-v** 选项.


  这样就在 **6000** 端口开启了一个侦听服务器,我们可以通过 **127.0.0.1:6000** 去连接上去;如果你的机器可以被外网访问,你可以使用 **0.0.0.0** 这样的侦听地址,示例:

  ```
  [root@iZ238vnojlyZ ~]# nc -v -l 0.0.0.0 6000
  Ncat: Version 6.40 ( http://nmap.org/ncat )
  Ncat: Listening on 0.0.0.0:6000
  ```

- 模拟一个客户端程序

  用 **nc** 命令模拟一个客户端程序时,我们不需要使用 **-l** 选项,直接写上 ip 地址(或域名,**nc** 命令可以自动解析域名)和端口号即可,示例如下:

  ```
  ## 连接百度 web 服务器
  [root@iZ238vnojlyZ ~]# nc -v www.baidu.com 80
  Ncat: Version 6.40 ( http://nmap.org/ncat )
  Ncat: Connected to 115.239.211.112:80.
  ```

  输出提示我们成功连接上百度 Web 服务器.

我们知道客户端连接服务器一般都是操作系统随机分配一个可用的端口号连接到服务器上去,使用 **nc** 命令作为客户端时可以使用 **-p** 选项指定使用哪个端口号连接服务器,例如,我们希望通过本地 5555 端口连接百度的 Web 服务器,可以这么输入:

```
[root@iZ238vnojlyZ ~]# nc -v -p 5555 www.baidu.com 80
Ncat: Version 6.40 ( http://nmap.org/ncat )
Ncat: Connected to 115.239.211.112:80.
```

再开一个 shell 窗口,我们使用上文中介绍的 **lsof** 命令验证一下,是否确实通过 **5555** 端口连接上了百度 Web 服务器.

```
[root@iZ238vnojlyZ ~]# lsof -Pni | grep nc
nc        32610    root    3u  IPv4 113369437      0t0  TCP 120.55.94.78:5555->115.239.211.112:80 (ESTABLISHED)
```

结果确实如我们所期望的.

当然,当使用 **nc** 命令与对端建立连接后,我们可以发送消息.下面通过一个具体的例子来演示一下这个过程

1. 使用 **nc -v -l 0.0.0.0 6000** 模拟一个侦听服务,再新建一个 shell 窗口利用 **nc -v 127.0.0.1 6000** 模拟一个客户端程序连接刚才的服务器.
2. 此时在客户端和服务器就可以相互发消息了.我们可以达到一个简化版的 IM 软件聊天效果:

**客户端效果:**

![](../imgs/nc1.png)

**服务器端效果:**

![](../imgs/nc2.jpeg)





> 果你在使用 nc 命令发消息时不小心输入错误,可以使用 **Ctrl + Backspace** 键删除.

**nc** 命令默认会将 **\n** 作为每条消息的结束标志,如果你指定了 **-C** 选项,将会使用 **\r\n** 作为消息结束标志.

**nc** 命令不仅可以发消息,同时也能发文件.我们也来演示一下:

需要注意的是是**接收文件的一方是服务器端,发送文件的一方是客户端**.

1. 服务器端命令:

   ```
   nc -l ip地址 端口号 > 接收的文件名
   ```

2. 客户端命令:

   ```
   nc ip地址 端口号 < 发送的文件名
   ```

**服务器端效果**:

![img](../imgs/nc3.jpeg)

**客户端效果:**

![img](https://mmbiz.qpic.cn/mmbiz_png/ic8RqseyjxMM4O9PrQeYEZ96kC0aP9fXq02fwwzmOXVibyIyH5Qa4Sc7BMZrOBjibg4wibnWmdFalicBMXpNicR3MOjA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



> 意:这里客户端发送一个文件叫 **index.html**,服务器端以文件名 **xxx.html** 来保存,也就是说服务器端保存接收的文件名时不一定要使用客户端发送的文件名.

根据上面的介绍,当我们需要调试我们自己的服务器或者客户端程序时,又不想自己开发相应的对端,我们就可以使用 **nc** 命令去模拟.

当然,**nc** 命令非常强大,其功能远非本节介绍的这些,读者如果有兴趣可以去 **nc** 的 man 手册上获取更多的信息.


### netstat

### ifstat

### telnet

* telnet命令
`telnet` 是一个网络协议和命令行工具,用于在互联网或局域网中的主机之间创建一个基于文本的交互式通信连接.以下是一些常见的 `telnet` 用法:

    1. 连接到远程主机:最基本的 `telnet` 用法是连接到远程主机.你只需要提供主机名(或 IP 地址)和端口号.例如,`telnet example.com 80` 会尝试连接到 `example.com` 的 80 端口.

    2. 检查端口是否开放:你可以使用 `telnet` 来检查远程主机的特定端口是否开放.如果 `telnet` 能够成功连接,那么端口就是开放的.例如,`telnet example.com 22` 会尝试连接到 `example.com` 的 22 端口(通常用于 SSH).

    3. 发送 HTTP 请求:你可以使用 `telnet` 来手动发送 HTTP 请求.首先,连接到 Web 服务器的 80 端口(或 443 端口用于 HTTPS),然后手动输入 HTTP 请求头.例如:

    ```bash
    telnet example.com 80
    GET / HTTP/1.1
    Host: example.com
    ```

    4. 使用 `telnet` 进行邮件传输协议(SMTP)会话:你可以使用 `telnet` 连接到邮件服务器的 25 端口(SMTP 的默认端口),然后手动输入 SMTP 命令来发送电子邮件.

    请注意,`telnet` 不提供任何加密,所有的通信内容都是明文的.因此,对于需要安全通信的场景,应该使用 SSH 或其他加密的协议,而不是 `telnet`.

### tcpdump
#### (19)tcpdump常用命令
用简单的话来定义tcpdump,就是:dump the traffic on a network,根据使用者的定义对网络上的数据包进行截获的包分析工具. tcpdump可以将网络中传送的数据包的"头"完全截获下来提供分析.它支持针对网络层/协议/主机/网络或端口的过滤,并提供and/or/not等逻辑语句来帮助你去掉无用的信息.

实用命令实例

将某端口收发的数据包保存到文件<br>
`sudo tcpdump -i any port 端口 -w 文件名.cap`


打印请求到屏幕<br>
`sudo tcpdump -i any port 端口 -Xnlps0`

默认启动<br>
`tcpdump`
普通情况下,直接启动tcpdump将监视第一个网络接口上所有流过的数据包.
监视指定网络接口的数据包<br>
`tcpdump -i eth1`
如果不指定网卡,默认tcpdump只会监视第一个网络接口,一般是eth0,下面的例子都没有指定网络接口.　


## Linux tcpdump 使用介绍

**tcpdump** 是 Linux 系统提供一个非常强大的抓包工具,熟练使用它,对我们排查网络问题非常有用.如果你的机器上还没有安装,可以使用如下命令安装:

```
yum install tcpdump
```

如果要使用 **tcpdump** 命令必须具有 **sudo** 权限.

**tcpdump** 常用的选项有:

- **-i** 指定要捕获的目标网卡名,网卡名可以使用前面章节中介绍的 **ifconfig** 命令获得;如果要抓所有网卡的上的包,可以使用 **any** 关键字.

  ```
  ## 抓取网卡ens33上的包
  tcpdump -i ens33
  ## 抓取所有网卡上的包
  tcpdump -i any
  ```

- **-X** 以 ASCII 和十六进制的形式输出捕获的数据包内容,减去链路层的包头信息;**-XX** 以 ASCII 和十六进制的形式输出捕获的数据包内容,包括链路层的包头信息.

- **-n** 不要将 ip 地址显示成别名的形式;**-nn** 不要将 ip 地址和端口以别名的形式显示.

- **-S** 以绝对值显示包的 ISN 号(包序列号),默认以上一包的偏移量显示.

- **-vv** 抓包的信息详细地显示;**-vvv** 抓包的信息更详细地显示.

- **-w** 将抓取的包的原始信息(不解析,也不输出)写入文件中,后跟文件名:

  ```
  tcpdump -i any -w filename  
  ```

- **-r** 从利用 **-w** 选项保存的包文件中读取数据包信息.

除了可以使用选项以外,**tcpdump** 还支持各种数据包过滤的表达式,常见的形式如下:

```
## 仅显示经过端口 8888 上的数据包(包括tcp:8888和udp:8888)
tcpdump -i any 'port 8888'

## 仅显示经过端口是 tcp:8888 上的数据包
tcpdump -i any 'tcp port 8888'

## 仅显示从源端口是 tcp:8888 的数据包
tcpdump -i any 'tcp src port 8888'

## 仅显示源端口是 tcp:8888 或目标端口是 udp:9999 的包 
tcpdump -i any 'tcp src port 8888 or udp dst port 9999'

## 仅显示地址是127.0.0.1 且源端口是 tcp:9999 的包 ,以 ASCII 和十六进制显示详细输出,
## 不显示 ip 地址和端口号的别名
tcpdump -i any 'src host 127.0.0.1 and tcp src port 9999' -XX -nn -vv
```

下面我们通过三个具体的操作实例来演示一下使用 **tcpdump** 的抓包过程.

**实例一 :连接一个正常的侦听端口**

假设我的服务器端的地址是 **127.0.0.0.1:12345**,使用 nc 命令在一个 shell 窗口创建一个服务器程序并在这个地址上进行侦听.

```
nc –v -l 127.0.0.0.112345
```

效果如下图所示:

![](../imgs/tcpdump1.webp)

在另外一个 shell 窗口开启 tcpdump 抓包:

```
tcpdump -i any 'port 12345' -XX -nn -vv
```

效果如下:

![](../imgs/tcpdump2.webp)

然后再开一个 shell 窗口,利用 nc 命令创建一个客户端去连接服务器:

```
nc -v 127.0.0.1 12345
```

效果如下:

![](../imgs/tcpdump3.webp)

我们抓到的包如下:

![](../imgs/tcpdump4.webp)

由于我们没有在客户端和服务器之间发送任何消息,其实抓到的包就是 TCP 连接的三次握手数据包,分析如下:

三次握手过程是客户端先给服务器发送一个 **SYN**,然后服务器应答一个 **SYN + ACK**,应答的序列号是递增 **1** 的,表示应答哪个请求,即从 **4004096087** 递增到 **4004096088**,接着客户端再应答一个 **ACK**.这个时候,我们发现发包序列号和应答序列号都变成 **1**了,这是 tcpdump 使用相对序号,我们加上 **-S** 选项后就变成绝对序列号了.

我们按 Ctrl + C 中断 tcpdump 抓包过程,并停止用 nc 开启的客户端和服务器程序,然后在前面的 tcpdump 命令后面加上 **-S** 选项重新开启抓包,使用命令如下:

```
tcpdump -i any 'port 12345' -XX -nn -vv -S
```

然后再按顺序用 nc 命令再次启动下服务器和客户端程序.再次得到抓包结果:

![](../imgs/tcpdump5.webp)

这次得到的包的序号就是绝对序号了.

**实例二:连接一个不存在的侦听端口**

**实例一**演示的是正常的 TCP 连接三次握手过程捕获到的数据包.假如我们连接的**服务器 ip 地址存在**,但**监听端口号不存在**,我们看下 tcpdump 抓包结果.除了在一个 shell 窗口启动一个 tcpdump 抓包监测,在另外一个 shell 窗口用 nc 命令去连接一个不存在的侦听端口即可.

![](../imgs/tcpdump6.webp)

抓包数据如下:

![](../imgs/tcpdump7.webp)

这个时候客户端发送 **SYN**,服务器应答 **ACK+RST**,这个应答包会导致客户端的 connect 连接失败返回.

**实例三:连接一个很遥远的 ip,或者网络繁忙的情形**

实际情形中,还存在一种情况就是客户端访问一个很遥远的 ip,或者网络繁忙,服务器对客户端发送的 TCP 三次握手的网络 SYN 报文没有应答,会出现什么情况呢?

我们通过设置防火墙规则来模拟一下这种情况.使用 **iptables -F** 先将防火墙的已有规则都清理掉,然后给防火墙的 INPUT 链上增加一个规则:丢弃本地网卡 lo(也就是 127.0.0.1 这个回环地址)上的所有 SYN 包.

```
iptables -F
iptables -I INPUT -p tcp --syn -i lo -j DROP
```

![](../imgs/tcpdump8.png)



> 如果读者对 CentOS 的防火墙 iptables 命令有兴趣,可以使用 man iptables 在 man 手册中查看更详细的帮助.

在开启 tcpdump 抓包之后和设置防火墙规则之后,利用 nc 命令去连接 127.0.0.1:12345 这个地址.整个过程操作效果图如下:

![](../imgs/tcpdump9.png)

接着,我们得到 tcpdump 抓到的数据包如下:

![](../imgs/tcpdump10.webp)

通过抓包数据我们可以看到:如果连接不上,一共重试了 **5** 次,重试的时间间隔是 1 秒,2秒,4秒,8秒,16秒,最后返回超时失败.这个重试次数在 **/proc/sys/net/ipv4/tcp_syn_retries** 内核参数中设置,默认为 **6** .

> TCP 四次挥手与三次握手基本上类似,这里就不贴出 tcpdump 抓包的详情了,强烈建议不熟悉这块的读者实际练习一遍.
