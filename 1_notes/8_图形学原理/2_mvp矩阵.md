## mvp矩阵

在了解了矩阵变换后，我们可以定义一个世界坐标系和物体坐标系，并在物体坐标系下完成变换。这些操作解决了基本的位置定义问题，但要将这些物体的位置关系转换到屏幕空间，还需要进一步的步骤。这些步骤包括相机信息、投影方式和视口变换方式的补充。在此过程中，MVP 矩阵的概念尤为重要。

### 1. 粗略认识

* **世界坐标系与物体坐标系**
    1. **世界坐标系**：这是一个全局的坐标系统，所有的物体都在这个空间中。世界坐标系中的坐标是相对于一个固定的原点（通常是场景的中心）定义的。
    2. **物体坐标系**：这是物体的本地坐标系统。在物体坐标系中，物体的中心通常位于原点，物体的大小和方向都是相对于这个原点定义的。

* **从物体坐标系到屏幕空间的转换**
    1. **模型矩阵（Model Matrix）**：将物体的顶点坐标从物体坐标系转换到世界坐标系。模型矩阵通常包含了物体的位置、旋转和缩放信息。
    2. **视图矩阵（View Matrix）**：将物体的顶点坐标从世界坐标系转换到视图坐标系（相机坐标系）。视图矩阵通常包含了相机的位置和朝向信息。
    3. **投影矩阵（Projection Matrix）**：将物体的顶点坐标从视图坐标系转换到裁剪坐标系。投影矩阵通常包含了相机的视野（FOV）、长宽比（Aspect Ratio）、近裁剪面（Near Clipping Plane）和远裁剪面（Far Clipping Plane）信息。
    4. **视口变换（Viewport Transformation）**：将物体的顶点坐标从裁剪坐标系转换到屏幕坐标系。这通常涉及到将物体的坐标从裁剪空间的 -1 到 1 范围映射到屏幕的像素坐标。

也就是说，每一个物体都有一个物体坐标系，物体的形状在这个坐标系下表示。
物体的位置左乘模型矩阵，则得到世界坐标系的位置。
接着左乘视图矩阵，则得到了在相机坐标系下的位置。
接着左乘投影矩阵，则得到了裁剪坐标系下的位置。
然后再进行视口变化，则得到了屏幕坐标系的位置，这个变化是三维变成二维的过程。

模型矩阵，视图矩阵，投影矩阵三个矩阵相乘则是mvp矩阵，这一个矩阵能够将物体变换到裁剪坐标系。

### 2 详解各个变换流程

#### 2.1 视图变换

用于将物体的顶点坐标从世界空间转换到视图空间（相机空间）。视图空间是以相机为中心的坐标系统，在视图空间中，相机位于原点，朝向 -z 轴，上方向是 y 轴。视图变换的目的是将整个场景从世界坐标系转换到相机的视角，使得相机的位置是固定的，而所有的物体都相对于相机进行变换。

1. **相机位置（Camera Position）**：
   - 相机在世界空间中的位置，通常用一个Point3d表示，记为 `cameraPos`。
2. **相机目标（Camera Target）**：
   - 相机所看的目标位置，通常用一个Point3d表示，记为 `cameraTarget`。相机方向是从相机位置指向相机目标的向量。
3. **相机上方向（Camera Up Vector）**：
   - 相机的上方向，通常用一个Vector3d表示，记为 `cameraUp`。上方向用于确定相机的旋转角度。


#### 2.2 投影变换

**裁剪空间（Clip Space）**：在裁剪空间中，所有可见的物体都在一个定义好的立方体（通常是[-1, 1] x [-1, 1] x [-1, 1]）内。投影矩阵用于将物体的顶点坐标从视图空间转换到裁剪空间。然后，通过进行透视除法，将裁剪空间的坐标转换到归一化设备坐标（NDC）空间。在这个阶段,任何在这个立方体之外的物体都会被裁剪掉.

简单来说，世界坐标系上已经有很多模型了，相机的位置也已经确定了，现在就显示到屏幕了。
可以当成是相机坐标系上有一个平面，将世界坐标系上朝向这个平面的点，投影到这个平面。
这个平面就是所谓的裁剪空间，也是显示设备，即屏幕了。
> 投影矩阵是用来将3D空间中的点投影到2D平面上的，它包含了相机的视野（FOV）、长宽比（Aspect Ratio）、近裁剪面（Near Clipping Plane）和远裁剪面（Far Clipping Plane）等信息。
> 常见的有两种类型的投影矩阵：正交投影矩阵和透视投影矩阵。

##### 2.2.1 正交投影矩阵：
* 正交投影是一种线性投影,其中物体的大小不会随着深度的变化而变化.
* 这意味着远离相机的物体和靠近相机的物体大小看起来是一样的.这种投影常用于工程图/建筑图等需要精确测量的场合.
* 这个函数需要你提供视口的左/右/底/顶边界以及近/远裁剪面的距离

##### 2.2.2  透视投影矩阵：
* 透视投影是一种非线性投影,其中物体的大小会随着深度的变化而变化.
* 这意味着远离相机的物体看起来会比靠近相机的物体小.
* 这种投影更符合人眼看世界的方式,因此常用于3D游戏和其他需要真实感的应用.
* 这个函数需要设置包括视野角度(FOV)/宽高比(aspect ratio)/近裁剪面(near clipping plane)和远裁剪面(far clipping plane)


#### 2.3 视口变换
5. **屏幕空间(Screen Space)**:这是最后的空间,物体的坐标是像素值,左上角是(0,0),右下角是(宽度,高度).这是通过视口变换实现的.

这些空间的转换是通过矩阵乘法实现的，MVP矩阵就是这些转换矩阵的乘积。
注意裁剪空间到屏幕空间的变换时通过视口变换实现的，因为这个不是通过矩阵运算表示的，所以mvp矩阵只包括从模型空间到裁剪空间，但不代表屏幕空间这个概念没有。

视口变换（Viewport Transform）是3D图形渲染流程中的一个步骤，它将裁剪空间中的坐标转换到屏幕空间的像素坐标系。

在裁剪空间中，所有可见的物体都在一个由-1到1的立方体中。视口变换将这个立方体映射到屏幕的像素坐标系，这通常涉及到将x和y坐标乘以屏幕的宽度和高度，然后再加上屏幕的左上角坐标。

视口变换包括两个步骤：

1. **透视除法（Perspective Division）**：这一步将裁剪空间中的坐标除以它们的w分量。这一步将立方体变成了一个单位立方体，所有的坐标都在-1到1的范围内。

2. **视口变换（Viewport Transform）**：这一步将单位立方体映射到屏幕的像素坐标系。

以下是一个简单的视口变换的例子：

```cpp
vec2 viewportTransform(vec3 clipSpace)
{
    float x = (clipSpace.x + 1.0) * 0.5 * screenWidth;
    float y = (1.0 - clipSpace.y) * 0.5 * screenHeight;
    return vec2(x, y);
}
```

这个函数首先将裁剪空间的坐标映射到0到1的范围，然后乘以屏幕的宽度和高度。注意，我们需要将y坐标翻转，因为在屏幕空间中，y轴是向下的，而在裁剪空间中，y轴是向上的。

### 99. quiz

#### 1. 为什么要引入模型空间，而不是直接使用世界空间呢？

引入模型空间（Model Space）的主要原因是为了方便地描述和操作物体。

在模型空间中，物体的中心通常位于原点，物体的大小和方向都是相对于这个原点定义的。这样，我们可以在一个简单和一致的坐标系统中定义和操作物体，而不需要考虑物体在世界中的具体位置和方向。

例如，如果我们想要旋转一个物体，我们可以简单地在模型空间中围绕原点进行旋转，而不需要考虑物体在世界空间中的位置。如果我们直接在世界空间中进行旋转，我们需要首先将物体移动到原点，然后进行旋转，最后再将物体移动回原来的位置。这显然比在模型空间中进行旋转要复杂得多。

此外，模型空间还允许我们独立地操作每个物体。每个物体都有自己的模型空间，我们可以在这个空间中独立地移动、旋转和缩放物体，而不会影响到其他物体。

总的来说，模型空间提供了一个简单、一致和独立的环境，使得我们可以更方便地描述和操作物体。


#### 2. 视图矩阵的eye, center, up是什么?
在MVP矩阵中,"eye"和"center"是相机的位置和观察目标的位置,up是相机的上方向(通常,我们选择(0.0, 1.0, 0.0)作为up参数,表示相机的顶部指向世界空间的上方)

- "eye"代表相机的位置,即相机在世界空间中的坐标.它定义了相机的位置和朝向.
- "center"代表观察目标的位置,即相机所看的点在世界空间中的坐标.它定义了相机的视线方向.也可以理解为焦点
- up是相机的上方向(通常,我们选择(0.0, 1.0, 0.0)作为up参数,表示相机的顶部指向世界空间的上方)

这三个参数一起定义了相机的位置和朝向,用于计算视图矩阵.视图矩阵将物体从世界空间转换到相机空间,使得物体相对于相机的位置和方向进行变换.
一般设定了eye center和up，函数库会自动求解4*4的视图矩阵。

#### 4. 屏幕空间的坐标系是怎么样的？
在计算机图形学中，屏幕的坐标系通常是这样的：

- 原点（0,0）位于屏幕的左上角。
- x轴的正方向是向右，所以当你增加x值时，你会向屏幕的右边移动。
- y轴的正方向是向下，所以当你增加y值时，你会向屏幕的下方移动。


#### 3. 视锥体
这是一个在3D空间中定义了相机视野的体积.任何在这个体积之外的物体都不会被渲染.



