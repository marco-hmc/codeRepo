## mvp矩阵

在了解了矩阵变换后，我们可以定义一个世界坐标系和物体坐标系，并在物体坐标系下完成变换。这些操作解决了基本的位置定义问题，但要将这些物体的位置关系转换到屏幕空间，还需要进一步的步骤。这些步骤包括相机信息、投影方式和视口变换方式的补充。在此过程中，MVP 矩阵的概念尤为重要。

### 1. 粗略认识

* **从物体坐标系到屏幕空间的转换**
    1. **模型矩阵（Model Matrix）**：将物体的顶点坐标从物体坐标系转换到世界坐标系。模型矩阵通常包含了物体的位置、旋转和缩放信息。
    2. **视图矩阵（View Matrix）**：将物体的顶点坐标从世界坐标系转换到视图坐标系（相机坐标系）。视图矩阵通常包含了相机的位置和朝向信息。
    3. **投影矩阵（Projection Matrix）**：将物体的顶点坐标从视图坐标系转换到裁剪坐标系。投影矩阵通常包含了相机的视野（FOV）、长宽比（Aspect Ratio）、近裁剪面（Near Clipping Plane）和远裁剪面（Far Clipping Plane）信息。
    4. **视口变换（Viewport Transformation）**：将物体的顶点坐标从裁剪坐标系转换到屏幕坐标系。这通常涉及到将物体的坐标从裁剪空间的 -1 到 1 范围映射到屏幕的像素坐标。

也就是说，每一个物体都有一个物体坐标系，物体的形状在这个坐标系下表示。
物体的位置左乘模型矩阵，则得到世界坐标系的位置。
接着左乘视图矩阵，则得到了在相机坐标系下的位置。
接着左乘投影矩阵，则得到了裁剪坐标系下的位置。
然后再进行视口变化，则得到了屏幕坐标系的位置，这个变化是三维变成二维的过程。

模型矩阵，视图矩阵，投影矩阵三个矩阵相乘则是mvp矩阵，这一个矩阵能够将物体变换到裁剪坐标系。

### 2 详解各个变换流程

#### 2.0 位置变换-模型矩阵
这个前文有提过，就不再赘叙了。

#### 2.1 视图变换-视图矩阵

* **视图空间与变换意义**
    用于将物体的顶点坐标从世界空间转换到视图空间（相机空间）。
    视图空间是以相机为中心的坐标系统，在视图空间中，相机位于原点，朝向 -z 轴，上方向是 y 轴。
    视图变换的目的是将整个场景从世界坐标系转换到相机的视角，使得相机的位置是固定的，而所有的物体都相对于相机进行变换。

* **矩阵意义**
    设定了`eye`，`center`和`up`，函数库会根据这些信息自动求解相应的`4*4`的视图矩阵。

    1. **eye：相机位置（Camera Position）**：
    - 相机在世界空间中的位置，通常用一个Point3d表示，记为 `cameraPos`。
    2. **center：相机目标（Camera Target）**：
    - 相机所看的目标位置，通常用一个Point3d表示，记为 `cameraTarget`。相机方向是从相机位置指向相机目标的向量。
    3. **up：相机上方向（Camera Up Vector）**：
    - 相机的上方向，通常用一个Vector3d表示，记为 `cameraUp`。上方向用于确定相机的旋转角度。


#### 2.2 投影变换-投影矩阵

* **裁剪空间与变换意义**

    裁剪空间（Clipping Space）是投影变换后的中间空间，其主要目的是确定哪些物体或物体部分会被最终渲染到屏幕上。裁剪空间位于投影变换与屏幕坐标之间，它的作用是过滤掉那些不在视锥体内的物体，避免不必要的渲染工作。

    在裁剪空间中，所有可见的物体都在一个定义好的立方体（通常是`[-1, 1] x [-1, 1] x [-1, 1]`）内。投影矩阵用于将物体的顶点坐标从视图空间转换到裁剪空间。

    在计算机图形学中，投影变换是将三维空间中的物体投影到二维视图平面（如屏幕）上的过程。这个变换不仅仅是坐标的线性变换，还涉及到如何将三维物体的深度（Z值）映射到二维图像上。投影变换的意义在于通过矩阵将世界空间或视图空间的坐标转换为裁剪空间中的坐标。这些坐标在裁剪空间中的具体位置会决定它们是否需要被进一步的裁剪、透视分割（如深度测试）和最终渲染。

    投影变换有两种主要类型：正交投影和透视投影。

简单来说，现在已经统一到了世界坐标系，相机的位置也已经确定了，如果从相机位置看向物体位置，还需要确定一个视锥体，然后视锥体截取一个平面，将视锥体底部显示数据全部投影到平面，这个才是完整的显示。

可以当成是相机坐标系上有一个平面，将世界坐标系上朝向这个平面的点，投影到这个平面。
这个平面就是所谓的裁剪空间，也是显示设备，即屏幕了。
> 投影矩阵是用来将3D空间中的点投影到2D平面上的，它包含了相机的视野（FOV）、长宽比（Aspect Ratio）、近裁剪面（Near Clipping Plane）和远裁剪面（Far Clipping Plane）等信息。
> 常见的有两种类型的投影矩阵：正交投影矩阵和透视投影矩阵。

##### 2.2.1 正交投影矩阵：
   * 正交投影（Orthographic Projection）是指不考虑物体深度的变化，所有物体的投影 都被放置在一个平行的平面上，物体的大小不会随着距离的增加而变化。也就是说，无论物体距离摄像机有多远，它的大小都保持不变。这种投影常用于技术绘图、工程图或一些非现实主义的图像风格。

   * 正交投影是一种线性投影,其中物体的大小不会随着深度的变化而变化.
   * 这意味着远离相机的物体和靠近相机的物体大小看起来是一样的.这种投影常用于工程图/建筑图等需要精确测量的场合.
   * 这个函数需要你提供视口的左/右/底/顶边界以及近/远裁剪面的距离
    - 技术绘图：正交投影常用于需要准确显示尺寸比例的场景，比如建筑设计、CAD模型等。
    - 一些游戏和图形效果：例如战略游戏、2D游戏或一些特殊的视觉效果中，正交投影能够提供简洁而清晰的视图。
这个矩阵的作用是将世界空间中的坐标映射到裁剪空间中。正交投影的关键特点是：
- 物体的大小不随其与观察者的距离变化（平行投影）。
- 所有的点都在投影平面上没有“透视”效果。

- `L` 和 `R` 是视口的左右边界，
- `B` 和 `T` 是视口的上下边界，
- `N` 和 `F` 是视口的近剪裁面和远剪裁面。


##### 2.2.2  透视投影矩阵：
   * 透视投影是一种非线性投影,其中物体的大小会随着深度的变化而变化.
   * 这意味着远离相机的物体看起来会比靠近相机的物体小.
   * 这种投影更符合人眼看世界的方式,因此常用于3D游戏和其他需要真实感的应用.
   * 这个函数需要设置包括视野角度(FOV)/宽高比(aspect ratio)/近裁剪面(near clipping plane)和远裁剪面(far clipping plane)

- `\text{fov}` 是视场角（垂直视场角，一般用弧度表示），
- `\text{aspect}` 是宽高比（宽度除以高度），
- `N` 是近裁剪面的距离，
- `F` 是远裁剪面的距离。

透视投影矩阵通常用于模拟现实世界中的透视效果。它依赖于摄像机的视场角（FOV，Field of View）、宽高比（Aspect Ratio）、近裁剪面和远裁剪面等参数。

透视投影的特点：
1. **远小近大**：物体离摄像机越远，它的投影越小，离得越近则越大。
2. **消失点**：透视投影使得物体看起来有消失点，尤其在平行线消失的地方，这种效果在绘画、建筑设计和电影制作中有广泛应用。
3. **空间感**：透视投影能够有效地表现空间深度和立体感，广泛用于视频游戏、电影和虚拟现实等需要真实感的场景中。

透视投影的应用：
- **三维游戏和动画**：透视投影广泛应用于需要表现空间深度的场景，能有效地模拟现实世界的视觉效果。
- **虚拟现实和增强现实**：透视投影帮助构建更自然、真实的虚拟环境。
- **电影与视觉效果**：在电影中的场景模拟真实世界视角，提供更真实的视觉体验。


#### 2.3 视口变换
    然后，通过进行透视除法，将裁剪空间的坐标转换到归一化设备坐标（NDC）空间。在这个阶段,任何在这个立方体之外的物体都会被裁剪掉.

5. **屏幕空间(Screen Space)**:这是最后的空间,物体的坐标是像素值,左上角是(0,0),右下角是(宽度,高度).这是通过视口变换实现的.

这些空间的转换是通过矩阵乘法实现的，MVP矩阵就是这些转换矩阵的乘积。
注意裁剪空间到屏幕空间的变换时通过视口变换实现的，因为这个不是通过矩阵运算表示的，所以mvp矩阵只包括从模型空间到裁剪空间，但不代表屏幕空间这个概念没有。

视口变换（Viewport Transform）是3D图形渲染流程中的一个步骤，它将裁剪空间中的坐标转换到屏幕空间的像素坐标系。

在裁剪空间中，所有可见的物体都在一个由-1到1的立方体中。视口变换将这个立方体映射到屏幕的像素坐标系，这通常涉及到将x和y坐标乘以屏幕的宽度和高度，然后再加上屏幕的左上角坐标。

视口变换包括两个步骤：

1. **透视除法（Perspective Division）**：这一步将裁剪空间中的坐标除以它们的w分量。这一步将立方体变成了一个单位立方体，所有的坐标都在-1到1的范围内。

2. **视口变换（Viewport Transform）**：这一步将单位立方体映射到屏幕的像素坐标系。

以下是一个简单的视口变换的例子：

```cpp
vec2 viewportTransform(vec3 clipSpace)
{
    float x = (clipSpace.x + 1.0) * 0.5 * screenWidth;
    float y = (1.0 - clipSpace.y) * 0.5 * screenHeight;
    return vec2(x, y);
}
```

这个函数首先将裁剪空间的坐标映射到0到1的范围，然后乘以屏幕的宽度和高度。注意，我们需要将y坐标翻转，因为在屏幕空间中，y轴是向下的，而在裁剪空间中，y轴是向上的。

### 99. quiz

#### 1. 为什么要引入模型空间，而不是直接使用世界空间呢？

引入模型空间（Model Space）的主要原因是为了方便地描述和操作物体。

在模型空间中，物体的中心通常位于原点，物体的大小和方向都是相对于这个原点定义的。这样，我们可以在一个简单和一致的坐标系统中定义和操作物体，而不需要考虑物体在世界中的具体位置和方向。

例如，如果我们想要旋转一个物体，我们可以简单地在模型空间中围绕原点进行旋转，而不需要考虑物体在世界空间中的位置。如果我们直接在世界空间中进行旋转，我们需要首先将物体移动到原点，然后进行旋转，最后再将物体移动回原来的位置。这显然比在模型空间中进行旋转要复杂得多。

此外，模型空间还允许我们独立地操作每个物体。每个物体都有自己的模型空间，我们可以在这个空间中独立地移动、旋转和缩放物体，而不会影响到其他物体。

总的来说，模型空间提供了一个简单、一致和独立的环境，使得我们可以更方便地描述和操作物体。

#### 2. 左手坐标系，右手坐标系

#### 4. 屏幕空间的坐标系是怎么样的？
在计算机图形学中，屏幕的坐标系通常是这样的：

- 原点（0,0）位于屏幕的左上角。
- x轴的正方向是向右，所以当你增加x值时，你会向屏幕的右边移动。
- y轴的正方向是向下，所以当你增加y值时，你会向屏幕的下方移动。


#### 3. 视锥体
这是一个在3D空间中定义了相机视野的体积.任何在这个体积之外的物体都不会被渲染.
