## mvp矩阵与矩阵变换

### 1. 矩阵基础

#### 1.1 什么是笛卡尔坐标，什么是齐次坐标？
```
   // 三维笛卡尔坐标
   x = 3
   y = 4
   z = 5

   // 三维齐次坐标
   x = 3
   y = 4
   z = 5
   w = 1
```

简单来说齐次坐标在传统的笛卡尔坐标系（所有轴互相正交）的基础上增加了一个额外的维度，通常表示为(x， y， z， w)。这是在计算机图形学中常用的一种坐标表示方法。
* 若`w==1`，则向量`(x， y， z， 1)`为空间中的点。
* 若`w==0`，则向量`(x， y， z， 0)`为方向。
除了能表示点和方向之外，并且可以通过一个矩阵乘法来表示旋转、缩放、平移等变换，这在计算机图形学中是非常有用的。

而之所以叫“齐次”来源于齐次坐标系中所有的坐标分量都是成比例的，换句话说，坐标点的所有分量在尺度变换下是“齐平”的。例如，在三维空间中的点 `(x,y,z)` 可以写成 `(kx,ky,kz,k)`（其中 kk 是一个常数），这两个表示的是相同的点。

#### 1.2 矩阵变换
矩阵变换是一种在计算机图形学中常用的方法，用于表示和计算几何变换，如旋转、缩放和平移。这些变换通常用于改变物体的位置、方向和大小。**换句话说，选择、缩放和平移操作都可以看成是一种矩阵变换**。通过将这些矩阵与物体的顶点坐标相乘，我们可以得到变换后的顶点坐标。如果有多个变换需要应用，我们根据矩阵结合律调整运算顺序，得到一个总的变换矩阵，然后再与顶点坐标相乘。

比如说顶点坐标就是`p=[x y z w]`，其中w取1，表示是一个点。那矩阵变换就是`M_(平移)M_(旋转)p = p'`，而`M_(平移)M_(旋转)`可以通过矩阵结合律进行一个合并得到旋转平移矩阵，至于是先旋转还是平移就看运算顺序，按照从右往左的顺序。

而矩阵的平移需要多一个维度，所以矩阵变化是`4*4`的。如果有若干个旋转平移缩放操作，这些操作都可以看成一个矩阵变换，这些矩阵变换又可以通过矩阵结合律去合并，所以一个矩阵就能够表示对一个坐标进行任意旋转、缩放和平移了。

#### 1.3 空间变换
在矩阵变换的基础上，我们已经掌握了如何对一个点进行旋转、平移、缩放到另一个位置。接下来就开始讨论空间变换。

首先，假定我们已经获得了模型矩阵。
   1. **模型矩阵的作用**：
      - 模型矩阵可以看作是将模型空间的原点转换到世界空间原点的变换。即上面矩阵变换的操作。
   2. **对模型空间下的所有点进行相同的变换**：
      - 对模型空间下的所有点（组成一个模型的所有点）乘上模型矩阵，相当于将这些点按照相同的方式进行转换。这样，模型空间中的所有点就从原来的模型空间被移动到了新的世界空间。
   3. **矩阵变换与坐标系变换**：
      - 因此，如果矩阵变换操作的点是某个坐标系的原点，也可以看成是对那个坐标系的空间变换。即从模型空间，到世界空间。

#### 1.4 开发中的矩阵

在计算机图形学和游戏开发中，每个物体都有一个模型矩阵，这个模型矩阵反映的是物体自身所在坐标系的原点到上一级坐标系的矩阵变换。

假设有一个世界坐标系，我们在这个世界坐标系中放置一个物体 A。物体 A 带有一个模型矩阵，这个模型矩阵描述的是物体 A 从自身坐标系到世界坐标系的变换。一般来说，这个原始的模型矩阵是单位矩阵，表示物体在自身坐标系中的位置、旋转和缩放都保持不变。

随后如果对物体A进行旋转平移拉伸等操作的时候，改变矩阵即可。例如，物体 A 有一个顶点坐标 `pt(0,0,0)`。通过模型矩阵进行变换，`pt.transformBy(matrix)` 得到的新坐标 `pt'` 就是在世界坐标系中的位置。

进一步的，如果物体 A 的概念不断扩大，比如说物体 A 代表一个国家。对于世界坐标系来说，它不关心国家 A 内部的具体细分。因此，当国家 A 内部增加了一个省级行政单位 B 时，B 的坐标系是相对于 A 的。也就是说，B 的模型矩阵描述的是 B 的原点到 A 坐标系的变换。

#### 1.5 多级模型坐标

假设我们有一个机器人手臂，它由多个关节和一个末端执行器组成。每个关节和末端执行器都有自己的局部坐标系。我们需要通过多级相对矩阵变换来计算末端执行器在世界坐标系中的位置。

1. **基座（Base）**：机器人手臂的基座固定在地面上，基座的坐标系就是世界坐标系。
2. **关节1（Joint 1）**：关节1相对于基座旋转。
3. **关节2（Joint 2）**：关节2相对于关节1旋转。
4. **末端执行器（End Effector）**：末端执行器相对于关节2移动。

每个关节和末端执行器都有一个模型矩阵，用于描述它们相对于上一级坐标系的变换。通过将这些模型矩阵相乘，我们可以计算末端执行器在世界坐标系中的位置。

也就是说，模型矩阵的是将模型控件的原点转换的上一级坐标系原点的位置。并不总是转换到世界空间，这取决于物体相对关系。

### 99. quiz

#### 1. 模型的位置既可以由模型坐标决定，也可以由模型矩阵决定，对吗？
理论上，你可以通过直接修改模型坐标来改变物体的位置/方向和大小，但这通常不是一个好的做法。

首先，直接修改模型坐标会更加复杂和耗时。例如，如果你想将一个物体向右移动10个单位，你需要遍历所有的顶点，并将每个顶点的x坐标增加10.而如果你使用模型矩阵，你只需要将模型矩阵的平移部分增加10即可。

最后，使用模型矩阵可以更好地利用图形硬件的能力。图形硬件可以高效地处理矩阵运算，而且许多图形API(如OpenGL和DirectX)都提供了对模型矩阵的直接支持。

因此，在实际中，都是这么操作的。
* 当你需要改变物体的位置/方向或大小时，你需要更改模型矩阵。
    更改大小"通常通过改变模型矩阵中的缩放因子来实现，
* 当你需要改变物体的形状时，你需要更改模型坐标。
    "更改形状"则需要直接修改模型的顶点坐标。

### 附录

#### 1. 点乘和叉乘
* **点乘**
点乘是一种二元运算，它接受两个向量作为输入，并产生一个标量作为输出。在二维或三维空间中，两个向量 A 和 B 的点乘定义为：
   `A · B = |A| |B| cos(θ)`
   `A · B = Ax * Bx + Ay * By + Az * Bz`

其中，|A| 和 |B| 分别是 A 和 B 的长度，θ 是 A 和 B 之间的角度。在计算机图形学中，点乘常常用来计算两个向量之间的角度，或者判断两个向量是否垂直。

* **叉乘**
叉乘也是一种二元运算，但它接受两个向量作为输入，并产生一个新的向量作为输出。在三维空间中，两个向量 A 和 B 的叉乘定义为：
   `A × B = |A| |B| sin(θ) n`
   `A × B = [Ay * Bz - Az * By, Az * Bx - Ax * Bz, Ax * By - Ay * Bx]`
其中，n 是垂直于 A 和 B 的单位向量，方向由右手法则决定。叉乘的结果向量的长度等于原来两个向量构成的平行四边形的面积，方向垂直于这两个向量。在计算机图形学中，叉乘常常用来计算两个向量的法向量，或者判断两个向量是否平行。

#### 2. 点乘和投影
点乘和投影之间有着密切的关系。在向量运算中，点乘可以用来计算一个向量在另一个向量上的投影。

假设我们有两个向量 A 和 B，我们想要找到 A 在 B 上的投影。这个投影是一个向量，它的方向与 B 相同，长度等于 A 在 B 方向上的分量。我们可以通过以下步骤计算这个投影：

1. 首先，我们计算 A 和 B 的点乘，得到一个标量值：
      `A · B = |A| |B| cos(θ)`
2. 然后，我们将这个标量值除以 B 的长度，得到 A 在 B 方向上的分量：
      `A · B / |B| = |A| cos(θ)`

3. 最后，我们将这个分量乘以 B 的单位向量，得到投影向量：
      `(A · B / |B|) * (B / |B|) = (A · B / |B|^2) * B`

所以，A 在 B 上的投影可以通过点乘和除法运算得到，公式如下：
   `Proj_B(A) = (A · B / |B|^2) * B`

#### 3. 矩阵变换
* **旋转**（θ 为旋转角度）：
```
[ cosθ  -sinθ ]
[ sinθ   cosθ ]
```

* **缩放**（sx 和 sy 分别为 x 轴和 y 轴的缩放因子）：
```
[ sx  0 ]
[ 0   sy ]
```

* **平移**（tx 和 ty 分别为 x 轴和 y 轴的平移距离）：
```
[ 1  0  tx ]
[ 0  1  ty ]
[ 0  0  1  ]
```