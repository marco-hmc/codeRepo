marco-hmc: 怎么理解所有存储在图形系统中的几何数据都已节点的形式存储?上下的背景信息都可以介绍一下

GitHub Copilot: 在计算机图形学中,场景通常被组织为一种称为"场景图"(Scene Graph)的数据结构.场景图是一种树形结构,其中每个节点代表场景中的一个对象或一组对象.这些对象可以是几何形状(如三角形/立方体等)/光源/摄像机或者其他的图形实体.

场景图的一个关键特性是,每个节点的变换(位置/旋转和缩放)是相对于其父节点的.这意味着,如果你移动一个节点,那么所有的子节点也会跟着移动.这使得一些操作变得非常方便,例如旋转一个节点以及其所有的子节点,或者在不改变相对位置的情况下移动一组节点.

在这种结构中,几何数据(即模型的顶点/边和面)通常存储在叶子节点中,而变换/材质和其他属性则存储在内部节点中.当渲染场景时,图形系统会遍历场景图,并将每个节点的变换应用到其几何数据上,然后将结果发送到图形硬件进行渲染.

这种方式的优点是可以方便地组织和管理复杂的场景,以及方便地实现一些复杂的效果,例如层级动画/物体的相对运动等.缺点是需要更多的内存来存储场景图,以及更多的计算资源来处理场景图的遍历和变换的应用.

marco-hmc: 一般来说包围盒是怎么计算的?
GitHub Copilot: 计算一个物体的包围盒通常涉及到找出物体所有顶点在每个维度上的最小和最大值.对于一个三维物体,这通常涉及到在x/y和z轴上找出最小和最大值.

以下是计算包围盒的伪代码:

```cpp
// 初始化包围盒的最小和最大点为物体的第一个顶点
vec3 minPoint = object.vertices[0];
vec3 maxPoint = object.vertices[0];

// 遍历物体的所有顶点
for (int i = 1; i < object.vertices.size(); i++) {
    vec3 vertex = object.vertices[i];

    // 更新包围盒的最小和最大点
    minPoint = min(minPoint, vertex);
    maxPoint = max(maxPoint, vertex);
}

// 创建包围盒
BoundingBox boundingBox;
boundingBox.min = minPoint;
boundingBox.max = maxPoint;
```

在这个伪代码中,`min`和`max`函数分别返回两个向量的分量最小值和最大值.`BoundingBox`是一个简单的结构体,包含一个最小点和一个最大点.