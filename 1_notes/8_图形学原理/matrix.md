* 什么时候需要更改模型矩阵,什么时候更改模型坐标?
    总的来说,当你需要改变物体的位置/方向或大小时,你需要更改模型矩阵.当你需要改变物体的形状时,你需要更改模型坐标.
    更改大小"通常通过改变模型矩阵中的缩放因子来实现,而"更改形状"则需要直接修改模型的顶点坐标.

* 可以统一都改模型坐标,而不改模型矩阵吗?
    理论上,你可以通过直接修改模型坐标来改变物体的位置/方向和大小,但这通常不是一个好的做法.

    首先,直接修改模型坐标会更加复杂和耗时.例如,如果你想将一个物体向右移动10个单位,你需要遍历所有的顶点,并将每个顶点的x坐标增加10.而如果你使用模型矩阵,你只需要将模型矩阵的平移部分增加10即可.

    其次,直接修改模型坐标会破坏物体的原始数据.如果你需要恢复物体的原始位置/方向或大小,你需要保存一份原始的模型坐标,这会增加内存的使用.

    最后,使用模型矩阵可以更好地利用图形硬件的能力.图形硬件可以高效地处理矩阵运算,而且许多图形API(如OpenGL和DirectX)都提供了对模型矩阵的直接支持.

    因此,通常我们会优先使用模型矩阵来改变物体的位置/方向和大小,而只在需要改变物体的形状时才直接修改模型坐标.

* 视图矩阵的eye, center, up是什么?
    在MVP矩阵中,"eye"和"center"是相机的位置和观察目标的位置,up是相机的上方向(通常,我们选择(0.0, 1.0, 0.0)作为up参数,表示相机的顶部指向世界空间的上方)

    - "eye"代表相机的位置,即相机在世界空间中的坐标.它定义了相机的位置和朝向.
    - "center"代表观察目标的位置,即相机所看的点在世界空间中的坐标.它定义了相机的视线方向.也可以理解为焦点
    - up是相机的上方向(通常,我们选择(0.0, 1.0, 0.0)作为up参数,表示相机的顶部指向世界空间的上方)

    这三个参数一起定义了相机的位置和朝向,用于计算视图矩阵.视图矩阵将物体从世界空间转换到相机空间,使得物体相对于相机的位置和方向进行变换.

* 投影矩阵
    * 正交投影矩阵.正交投影是一种线性投影,其中物体的大小不会随着深度的变化而变化.这意味着远离相机的物体和靠近相机的物体大小看起来是一样的.这种投影常用于工程图/建筑图等需要精确测量的场合.
    > 这个函数需要你提供视口的左/右/底/顶边界以及近/远裁剪面的距离
    * 设置的是透视投影矩阵.透视投影是一种非线性投影,其中物体的大小会随着深度的变化而变化.这意味着远离相机的物体看起来会比靠近相机的物体小.这种投影更符合人眼看世界的方式,因此常用于3D游戏和其他需要真实感的应用.
    > 这个函数需要设置包括视野角度(FOV)/宽高比(aspect ratio)/近裁剪面(near clipping plane)和远裁剪面(far clipping plane)

* 裁剪空间是如何到屏幕空间的?
    裁剪空间到屏幕空间的转换是通过视口变换(Viewport Transform)实现的.在裁剪空间中,所有可见的物体都在一个由-1到1的立方体中.视口变换将这个立方体映射到屏幕的像素坐标系.

    视口变换包括两个步骤:

    1. **透视除法(Perspective Division)**:这一步将裁剪空间中的坐标除以它们的w分量.这一步将立方体变成了一个单位立方体,所有的坐标都在-1到1的范围内.

    2. **视口变换(Viewport Transform)**:这一步将单位立方体映射到屏幕的像素坐标系.这通常涉及到将x和y坐标乘以屏幕的宽度和高度,然后再加上屏幕的左上角坐标.

    以下是一个简单的视口变换的例子:

    ```cpp
    vec2 viewportTransform(vec3 clipSpace)
    {
        float x = (clipSpace.x + 1.0) * 0.5 * screenWidth;
        float y = (1.0 - clipSpace.y) * 0.5 * screenHeight;
        return vec2(x, y);
    }
    ```

    这个函数首先将裁剪空间的坐标映射到0到1的范围,然后乘以屏幕的宽度和高度.注意,我们需要将y坐标翻转,因为在屏幕空间中,y轴是向下的,而在裁剪空间中,y轴是向上的.

* 一般来说需要经过什么矩阵变换,才能够表示一个物体完整的从操作旋转,到显示的完整过程?
    一个物体从操作旋转到显示的完整过程通常需要经过以下矩阵变换:

    1. **模型矩阵**:首先,我们需要一个模型矩阵来将物体从其本地空间转换到世界空间.这通常涉及到旋转/缩放和平移物体.

    2. **视图矩阵**:然后,我们需要一个视图矩阵来将物体从世界空间转换到相机空间.这通常涉及到移动和旋转相机.

    3. **投影矩阵**:最后,我们需要一个投影矩阵来将物体从相机空间转换到裁剪空间.这通常涉及到定义相机的视野和裁剪平面.

    4. **视口变换**:在所有这些变换之后,我们还需要一个视口变换,将物体从裁剪空间转换到屏幕空间.这通常涉及到将物体的坐标从裁剪空间的-1到1范围映射到屏幕的像素坐标.

    这些变换通常以以下方式应用:

    ```c++
    vec4 clipSpace = projectionMatrix * viewMatrix * modelMatrix * vec4(objectPosition, 1.0);
    vec2 screenSpace = viewportTransform(clipSpace);
    ```

    这里,`objectPosition`是物体在其本地空间中的位置,`modelMatrix`/`viewMatrix`和`projectionMatrix`是我们之前讨论的矩阵,`viewportTransform`是将裁剪空间坐标转换为屏幕空间坐标的函数.
    * 也就是说有五个空间
      1. **本地空间(Local Space)**:也被称为物体空间,是指物体的原始空间.在这个空间中,物体的中心通常位于原点,物体的大小不受任何变换的影响.

      2. **世界空间(World Space)**:所有的物体都在世界空间中定位.在这个空间中,物体的位置/旋转和缩放都被应用,这是通过模型矩阵实现的.

      3. **相机空间(Camera Space)**:也被称为视图空间,是从相机的视角看世界的空间.在这个空间中,相机位于原点,朝向-z轴.这是通过视图矩阵实现的.

      4. **裁剪空间(Clip Space)**:在这个空间中,所有可见的物体都在一个由-1到1的立方体中.这是通过投影矩阵实现的.在这个阶段,任何在这个立方体之外的物体都会被裁剪掉.
        * 为什么是-1到1的立方体
      5. **屏幕空间(Screen Space)**:这是最后的空间,物体的坐标是像素值,左上角是(0,0),右下角是(宽度,高度).这是通过视口变换实现的.

* mvp矩阵是什么?
    MVP矩阵是模型(Model)/视图(View)和投影(Projection)矩阵的组合.这是一个常用的术语,用于描述如何将一个物体从其本地空间(模型空间)转换到裁剪空间.

    - **模型矩阵(Model)**:将物体从其本地空间转换到世界空间.
    - **视图矩阵(View)**:将物体从世界空间转换到相机空间.相机矩阵,也被称为视图矩阵(View Matrix),是用于将物体从世界空间转换到相机空间的矩阵.在相机空间中,相机位于原点,通常朝向-z轴.

    视图矩阵通常由相机的位置/方向和上向量(指定相机的旋转)决定.视图矩阵的作用是创建一个新的坐标系统,使得相机位于原点,并且朝向正确的方向.
    - **投影矩阵(Projection)**:将物体从相机空间转换到裁剪空间.

    这三个矩阵通常首先相乘,然后再用来变换物体的顶点.在顶点着色器中,这通常看起来像这样:

    ```c++
    vec4 clipSpace = projectionMatrix * viewMatrix * modelMatrix * vec4(objectPosition, 1.0);
    ```

    这里,`objectPosition`是物体在其本地空间中的位置,`modelMatrix`/`viewMatrix`和`projectionMatrix`是我们之前讨论的矩阵.结果`clipSpace`是物体在裁剪空间中的位置.

   - 视锥体
     - 这是一个在3D空间中定义了相机视野的体积.任何在这个体积之外的物体都不会被渲染.

* 裁剪空间是如何到屏幕空间的?
    裁剪空间到屏幕空间的转换是通过视口变换(Viewport Transform)实现的.在裁剪空间中,所有可见的物体都在一个由-1到1的立方体中.视口变换将这个立方体映射到屏幕的像素坐标系.

    视口变换包括两个步骤:

    1. **透视除法(Perspective Division)**:这一步将裁剪空间中的坐标除以它们的w分量.这一步将立方体变成了一个单位立方体,所有的坐标都在-1到1的范围内.

    2. **视口变换(Viewport Transform)**:这一步将单位立方体映射到屏幕的像素坐标系.这通常涉及到将x和y坐标乘以屏幕的宽度和高度,然后再加上屏幕的左上角坐标.

    以下是一个简单的视口变换的例子:

    ```cpp
    vec2 viewportTransform(vec3 clipSpace)
    {
        float x = (clipSpace.x + 1.0) * 0.5 * screenWidth;
        float y = (1.0 - clipSpace.y) * 0.5 * screenHeight;
        return vec2(x, y);
    }
    ```

    这个函数首先将裁剪空间的坐标映射到0到1的范围,然后乘以屏幕的宽度和高度.注意,我们需要将y坐标翻转,因为在屏幕空间中,y轴是向下的,而在裁剪空间中,y轴是向上的.